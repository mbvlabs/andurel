package models

import (
{{- if .HasRelations }}
	"{{.ModulePath}}/models/internal/db"
	"context"
	"errors"
	"time"

{{- /* Separate external imports when relations exist */}}
{{- range .Imports}}
{{- if isExternal .}}
	"{{.}}"
{{- end}}
{{- end}}
{{- else }}
    	"context"
	"errors"
	"time"
{{- /* No relations: keep externals in same group */}}
{{- range .Imports}}
{{- if isExternal .}}
	"{{.}}"
{{- end}}
{{- end}}

	"{{.ModulePath}}/models/internal/db"
{{- end }}
)

type {{.Name}} struct {
{{- range .Fields}}
	{{.Name}} {{.Type}}
{{- end}}
}

func Find{{.Name}}(
	ctx context.Context,
	exec bob.Executor,
	id uuid.UUID,
) ({{.Name}}, error) {
	row, err := db.Find{{.Name}}(ctx, exec, id)
	if err != nil {
		return {{.Name}}{}, err
	}

	return rowTo{{.Name}}(*row), nil
}

type Create{{.Name}}Data struct {
{{- range .Fields}}
{{- if and (ne .Name "ID") (ne .Name "CreatedAt") (ne .Name "UpdatedAt")}}
	{{.Name}} {{.Type}}
{{- end}}
{{- end}}
}

func Create{{.Name}}(
	ctx context.Context,
	exec bob.Executor,
	data Create{{.Name}}Data,
) ({{.Name}}, error) {
	if err := validate.Struct(data); err != nil {
		return {{.Name}}{}, errors.Join(ErrDomainValidation, err)
	}

	setter := &db.{{.Name}}Setter{
{{- range .Fields}}
{{- if not (or (eq .Name "ID") (eq .Name "CreatedAt") (eq .Name "UpdatedAt"))}}
		{{.Name}}: {{.ConversionToDB}},
{{- end}}
{{- end}}
{{- $hasID := false}}
{{- $hasCreatedAt := false}}
{{- $hasUpdatedAt := false}}
{{- range .Fields}}
{{- if eq .Name "ID"}}{{$hasID = true}}{{end}}
{{- if eq .Name "CreatedAt"}}{{$hasCreatedAt = true}}{{end}}
{{- if eq .Name "UpdatedAt"}}{{$hasUpdatedAt = true}}{{end}}
{{- end}}
{{- if $hasID}}
		ID:        omit.From(uuid.New()),
{{- end}}
{{- if $hasCreatedAt}}
{{- range .Fields}}{{if eq .Name "CreatedAt"}}
		CreatedAt: {{if .IsNullable}}omitnull.From(time.Now()){{else}}omit.From(time.Now()){{end}},
{{- end}}{{end}}
{{- end}}
{{- if $hasUpdatedAt}}
{{- range .Fields}}{{if eq .Name "UpdatedAt"}}
		UpdatedAt: {{if .IsNullable}}omitnull.From(time.Now()){{else}}omit.From(time.Now()){{end}},
{{- end}}{{end}}
{{- end}}
	}

	row, err := db.{{.Name}}s.Insert(setter).One(ctx, exec)
	if err != nil {
		return {{.Name}}{}, err
	}

	return rowTo{{.Name}}(*row), nil
}

type Update{{.Name}}Data struct {
	ID uuid.UUID
{{- range .Fields}}
{{- if and (ne .Name "ID") (ne .Name "CreatedAt")}}
	{{.Name}} {{.Type}}
{{- end}}
{{- end}}
}

func Update{{.Name}}(
	ctx context.Context,
	exec bob.Executor,
	data Update{{.Name}}Data,
) ({{.Name}}, error) {
	if err := validate.Struct(data); err != nil {
		return {{.Name}}{}, errors.Join(ErrDomainValidation, err)
	}

	// First get the existing record
	existing, err := db.Find{{.Name}}(ctx, exec, data.ID)
	if err != nil {
		return {{.Name}}{}, err
	}

	setter := &db.{{.Name}}Setter{
{{- range .Fields}}
{{- if and (ne .Name "ID") (ne .Name "CreatedAt") (ne .Name "UpdatedAt")}}
		{{.Name}}: {{.ConversionToDB}},
{{- end}}
{{- end}}
	}

	err = existing.Update(ctx, exec, setter)
	if err != nil {
		return {{.Name}}{}, err
	}

	return rowTo{{.Name}}(*existing), nil
}

func Destroy{{.Name}}(
	ctx context.Context,
	exec bob.Executor,
	id uuid.UUID,
) error {
	existing, err := db.Find{{.Name}}(ctx, exec, id)
	if err != nil {
		return err
	}

	return existing.Delete(ctx, exec)
}

func All{{.Name}}s(
	ctx context.Context,
	exec bob.Executor,
) ([]{{.Name}}, error) {
	rows, err := db.{{.Name}}s.Query().All(ctx, exec)
	if err != nil {
		return nil, err
	}

	{{lower .Name}}s := make([]{{.Name}}, len(rows))
	for i, row := range rows {
		{{lower .Name}}s[i] = rowTo{{.Name}}(*row)
	}

	return {{lower .Name}}s, nil
}

func rowTo{{.Name}}(row db.{{.Name}}) {{.Name}} {
	return {{.Name}}{
{{- range .Fields}}
		{{.Name}}: {{.ConversionFromDB}},
{{- end}}
	}
}
