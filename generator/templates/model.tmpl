package models

import (
	"context"
	"errors"
{{- range .StandardImports}}
	"{{.}}"
{{- end}}
{{if and (gt (len .StandardImports) 0) (gt (len .ExternalImports) 0)}}

{{end}}
{{- range .ExternalImports}}
	"{{.}}"
{{- end}}

	"{{.ModulePath}}/models/internal/db"
	"{{.ModulePath}}/internal/storage"
)

type {{.Name}} struct {
{{- range .Fields}}
	{{.Name}} {{.Type}}
{{- end}}
}

func Find{{.Name}}(
	ctx context.Context,
	exec storage.Executor,
	id {{if .IDType}}{{.IDType}}{{else}}uuid.UUID{{end}},
) ({{.Name}}, error) {
	row, err := queries.Query{{.Name}}ByID(ctx, exec, {{uuidParam "id"}})
	if err != nil {
		return {{.Name}}{}, err
	}

{{if hasErrorHandling}}	result, err := rowTo{{.Name}}(row)
	if err != nil {
		return {{.Name}}{}, err
	}
	return result, nil{{else}}	return rowTo{{.Name}}(row), nil{{end}}
}

type Create{{.Name}}Data struct {
{{- range .Fields}}
{{- if and (ne .Name "ID") (ne .Name "CreatedAt") (ne .Name "UpdatedAt")}}
	{{.Name}} {{.Type}}
{{- end}}
{{- end}}
{{- if not .IsAutoIncrementID}}
{{- if and .IDType (ne .IDType "uuid.UUID")}}
	ID {{.IDType}}
{{- end}}
{{- end}}
}

func Create{{.Name}}(
	ctx context.Context,
	exec storage.Executor,
	data Create{{.Name}}Data,
) ({{.Name}}, error) {
	if err := Validate.Struct(data); err != nil {
		return {{.Name}}{}, errors.Join(ErrDomainValidation, err)
	}

{{- if .HasSingleInsertParam}}
	row, err := queries.Insert{{.Name}}(ctx, exec, {{.SingleInsertField.ConversionToDB}})
{{- else}}
	params := db.Insert{{.Name}}Params{
{{- if not .IsAutoIncrementID}}
{{- if or (not .IDType) (eq .IDType "uuid.UUID")}}
		ID: uuid.New(),
{{- else}}
		ID: data.ID,
{{- end}}
{{- end}}
{{- range .Fields}}
{{- if not (or (eq .Name "ID") (eq .Name "CreatedAt") (eq .Name "UpdatedAt"))}}
		{{.Name}}: {{.ConversionToDB}},
{{- end}}
{{- end}}
	}
	row, err := queries.Insert{{.Name}}(ctx, exec, params)
{{- end}}
	if err != nil {
		return {{.Name}}{}, err
	}

{{if hasErrorHandling}}	result, err := rowTo{{.Name}}(row)
	if err != nil {
		return {{.Name}}{}, err
	}
	return result, nil{{else}}	return rowTo{{.Name}}(row), nil{{end}}
}

type Update{{.Name}}Data struct {
	ID {{if .IDType}}{{.IDType}}{{else}}uuid.UUID{{end}}
{{- range .Fields}}
{{- if and (ne .Name "ID") (ne .Name "CreatedAt")}}
	{{.Name}} {{.Type}}
{{- end}}
{{- end}}
}

func Update{{.Name}}(
	ctx context.Context,
	exec storage.Executor,
	data Update{{.Name}}Data,
) ({{.Name}}, error) {
	if err := Validate.Struct(data); err != nil {
		return {{.Name}}{}, errors.Join(ErrDomainValidation, err)
	}

	params := db.Update{{.Name}}Params{
		ID: data.ID,
{{- range .Fields}}
{{- if and (ne .Name "ID") (ne .Name "CreatedAt") (ne .Name "UpdatedAt")}}
		{{.Name}}: {{.ConversionToDBForUpdate}},
{{- end}}
{{- end}}
	}

	row, err := queries.Update{{.Name}}(ctx, exec, params)
	if err != nil {
		return {{.Name}}{}, err
	}

{{if hasErrorHandling}}	result, err := rowTo{{.Name}}(row)
	if err != nil {
		return {{.Name}}{}, err
	}
	return result, nil{{else}}	return rowTo{{.Name}}(row), nil{{end}}
}

func Destroy{{.Name}}(
	ctx context.Context,
	exec storage.Executor,
	id {{if .IDType}}{{.IDType}}{{else}}uuid.UUID{{end}},
) error {
	return queries.Delete{{.Name}}(ctx, exec, {{uuidParam "id"}})
}

func All{{.PluralName}}(
	ctx context.Context,
	exec storage.Executor,
) ([]{{.Name}}, error) {
	rows, err := queries.Query{{.PluralName}}(ctx, exec)
	if err != nil {
		return nil, err
	}

	{{lower .PluralName}} := make([]{{.Name}}, len(rows))
	for i, row := range rows {
{{if hasErrorHandling}}		result, err := rowTo{{.Name}}(row)
		if err != nil {
			return nil, err
		}
		{{lower .PluralName}}[i] = result{{else}}		{{lower .PluralName}}[i] = rowTo{{.Name}}(row){{end}}
	}

	return {{lower .PluralName}}, nil
}

type Paginated{{.PluralName}} struct {
	{{.PluralName}} []{{.Name}}
	TotalCount int64
	Page       int64
	PageSize   int64
	TotalPages int64
}

func Paginate{{.PluralName}}(
	ctx context.Context,
	exec storage.Executor,
	page int64,
	pageSize int64,
) (Paginated{{.PluralName}}, error) {
	if page < 1 {
		page = 1
	}
	if pageSize < 1 {
		pageSize = 10
	}
	if pageSize > 100 {
		pageSize = 100
	}

	offset := (page - 1) * pageSize

	totalCount, err := queries.Count{{.PluralName}}(ctx, exec)
	if err != nil {
		return Paginated{{.PluralName}}{}, err
	}

	rows, err := queries.QueryPaginated{{.PluralName}}(
		ctx,
		exec,
		db.QueryPaginated{{.PluralName}}Params{
			Limit:  pageSize,
			Offset: offset,
		},
	)
	if err != nil {
		return Paginated{{.PluralName}}{}, err
	}

	{{lower .PluralName}} := make([]{{.Name}}, len(rows))
	for i, row := range rows {
{{if hasErrorHandling}}		result, err := rowTo{{.Name}}(row)
		if err != nil {
			return Paginated{{.PluralName}}{}, err
		}
		{{lower .PluralName}}[i] = result{{else}}		{{lower .PluralName}}[i] = rowTo{{.Name}}(row){{end}}
	}

	totalPages := (totalCount + int64(pageSize) - 1) / int64(pageSize)

	return Paginated{{.PluralName}}{
		{{.PluralName}}:    {{lower .PluralName}},
		TotalCount: totalCount,
		Page:       page,
		PageSize:   pageSize,
		TotalPages: totalPages,
	}, nil
}

func Upsert{{.Name}}(
	ctx context.Context,
	exec storage.Executor,
	data Create{{.Name}}Data,
) ({{.Name}}, error) {
	if err := Validate.Struct(data); err != nil {
		return {{.Name}}{}, errors.Join(ErrDomainValidation, err)
	}

{{- if .HasSingleInsertParam}}
	row, err := queries.Upsert{{.Name}}(ctx, exec, {{.SingleInsertField.ConversionToDB}})
{{- else}}
	params := db.Upsert{{.Name}}Params{
{{- if not .IsAutoIncrementID}}
{{- if or (not .IDType) (eq .IDType "uuid.UUID")}}
		ID: uuid.New(),
{{- else}}
		ID: data.ID,
{{- end}}
{{- end}}
{{- range .Fields}}
{{- if not (or (eq .Name "ID") (eq .Name "CreatedAt") (eq .Name "UpdatedAt"))}}
		{{.Name}}: {{.ConversionToDB}},
{{- end}}
{{- end}}
	}
	row, err := queries.Upsert{{.Name}}(ctx, exec, params)
{{- end}}
	if err != nil {
		return {{.Name}}{}, err
	}

{{if hasErrorHandling}}	result, err := rowTo{{.Name}}(row)
	if err != nil {
		return {{.Name}}{}, err
	}
	return result, nil{{else}}	return rowTo{{.Name}}(row), nil{{end}}
}

{{if hasErrorHandling}}
func rowTo{{.Name}}(row db.{{.Name}}) ({{.Name}}, error) {
{{- range .Fields}}
{{- if .RequiresErrorHandling}}
	{{lower .Name}}, err := {{.ConversionFromDB}}
	if err != nil {
		return {{$.Name}}{}, err
	}
{{- end}}
{{- end}}

	return {{.Name}}{
{{- range .Fields}}
{{- if .RequiresErrorHandling}}
		{{.Name}}: {{lower .Name}},
{{- else}}
		{{.Name}}: {{.ConversionFromDB}},
{{- end}}
{{- end}}
	}, nil
}
{{else}}
func rowTo{{.Name}}(row db.{{.Name}}) {{.Name}} {
	return {{.Name}}{
{{- range .Fields}}
		{{.Name}}: {{.ConversionFromDB}},
{{- end}}
	}
}
{{end}}
