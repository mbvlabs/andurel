package models

import (
	"context"
	"errors"
	"fmt"
{{- range .Imports}}
	"{{.}}"
{{- end}}

	"{{.ModulePath}}/models/internal/db"
)

type {{.Name}} struct {
{{- range .Fields}}
	{{.Name}} {{.Type}}
{{- end}}
}

func Find{{.Name}}(
	ctx context.Context,
	dbtx db.DBTX,
	id uuid.UUID,
) ({{.Name}}, error) {
	row, err := db.New().Query{{.Name}}ByID(ctx, dbtx, {{uuidParam "id"}})
	if err != nil {
		return {{.Name}}{}, err
	}

{{if hasErrorHandling}}	result, err := rowTo{{.Name}}(row)
	if err != nil {
		return {{.Name}}{}, err
	}
	return result, nil{{else}}	return rowTo{{.Name}}(row), nil{{end}}
}

type Create{{.Name}}Data struct {
{{- range .Fields}}
{{- if and (ne .Name "ID") (ne .Name "CreatedAt") (ne .Name "UpdatedAt")}}
	{{.Name}} {{.Type}}
{{- end}}
{{- end}}
}

func Create{{.Name}}(
	ctx context.Context,
	dbtx db.DBTX,
	data Create{{.Name}}Data,
) ({{.Name}}, error) {
	if err := validate.Struct(data); err != nil {
		return {{.Name}}{}, errors.Join(ErrDomainValidation, err)
	}

	params := db.NewInsert{{.Name}}Params(
{{- range .Fields}}
{{- if not (or (eq .Name "ID") (eq .Name "CreatedAt") (eq .Name "UpdatedAt"))}}
		{{.ConversionToDB}},
{{- end}}
{{- end}}
	)
	row, err := db.New().Insert{{.Name}}(ctx, dbtx, params)
	if err != nil {
		return {{.Name}}{}, err
	}

{{if hasErrorHandling}}	result, err := rowTo{{.Name}}(row)
	if err != nil {
		return {{.Name}}{}, err
	}
	return result, nil{{else}}	return rowTo{{.Name}}(row), nil{{end}}
}

type Update{{.Name}}Data struct {
	ID uuid.UUID
{{- range .Fields}}
{{- if and (ne .Name "ID") (ne .Name "CreatedAt")}}
	{{.Name}} {{.Type}}
{{- end}}
{{- end}}
}

func Update{{.Name}}(
	ctx context.Context,
	dbtx db.DBTX,
	data Update{{.Name}}Data,
) ({{.Name}}, error) {
	if err := validate.Struct(data); err != nil {
		return {{.Name}}{}, errors.Join(ErrDomainValidation, err)
	}

	currentRow, err := db.New().Query{{.Name}}ByID(ctx, dbtx, {{uuidParam "data.ID"}})
	if err != nil {
		return {{.Name}}{}, err
	}

	params := db.NewUpdate{{.Name}}Params(
		{{uuidParam "data.ID"}},
{{- range .Fields}}
{{- if and (ne .Name "ID") (ne .Name "CreatedAt") (ne .Name "UpdatedAt")}}
		func() {{.SQLCType}} {
			if {{.ZeroCheck}} {
				return {{.ConversionToDBForUpdate}}
			}
			return currentRow.{{.Name}}
		}(),
{{- end}}
{{- end}}
	)

	row, err := db.New().Update{{.Name}}(ctx, dbtx, params)
	if err != nil {
		return {{.Name}}{}, err
	}

{{if hasErrorHandling}}	result, err := rowTo{{.Name}}(row)
	if err != nil {
		return {{.Name}}{}, err
	}
	return result, nil{{else}}	return rowTo{{.Name}}(row), nil{{end}}
}

func Destroy{{.Name}}(
	ctx context.Context,
	dbtx db.DBTX,
	id uuid.UUID,
) error {
	return db.New().Delete{{.Name}}(ctx, dbtx, {{uuidParam "id"}})
}

func All{{.Name}}s(
	ctx context.Context,
	dbtx db.DBTX,
) ([]{{.Name}}, error) {
	rows, err := db.New().QueryAll{{.Name}}s(ctx, dbtx)
	if err != nil {
		return nil, err
	}

	{{lower .Name}}s := make([]{{.Name}}, len(rows))
	for i, row := range rows {
{{if hasErrorHandling}}		result, err := rowTo{{.Name}}(row)
		if err != nil {
			return nil, err
		}
		{{lower .Name}}s[i] = result{{else}}		{{lower .Name}}s[i] = rowTo{{.Name}}(row){{end}}
	}

	return {{lower .Name}}s, nil
}

type Paginated{{.Name}}s struct {
	{{.Name}}s []{{.Name}}
	TotalCount int64
	Page       int64
	PageSize   int64
	TotalPages int64
}

func Paginate{{.Name}}s(
	ctx context.Context,
	dbtx db.DBTX,
	page int64,
	pageSize int64,
) (Paginated{{.Name}}s, error) {
	if page < 1 {
		page = 1
	}
	if pageSize < 1 {
		pageSize = 10
	}
	if pageSize > 100 {
		pageSize = 100
	}

	offset := (page - 1) * pageSize

	totalCount, err := db.New().Count{{.Name}}s(ctx, dbtx)
	if err != nil {
		return Paginated{{.Name}}s{}, err
	}

	rows, err := db.New().QueryPaginated{{.Name}}s(
		ctx,
		dbtx,
		db.NewQueryPaginated{{.Name}}sParams(pageSize, offset),
	)
	if err != nil {
		return Paginated{{.Name}}s{}, err
	}

	{{lower .Name}}s := make([]{{.Name}}, len(rows))
	for i, row := range rows {
{{if hasErrorHandling}}		result, err := rowTo{{.Name}}(row)
		if err != nil {
			return Paginated{{.Name}}s{}, err
		}
		{{lower .Name}}s[i] = result{{else}}		{{lower .Name}}s[i] = rowTo{{.Name}}(row){{end}}
	}

	totalPages := (totalCount + int64(pageSize) - 1) / int64(pageSize)

	return Paginated{{.Name}}s{
		{{.Name}}s:    {{lower .Name}}s,
		TotalCount: totalCount,
		Page:       page,
		PageSize:   pageSize,
		TotalPages: totalPages,
	}, nil
}

{{if hasErrorHandling}}
func rowTo{{.Name}}(row db.{{SQLCTypeName .TableName}}) ({{.Name}}, error) {
{{- range .Fields}}
{{- if .RequiresErrorHandling}}
	{{lower .Name}}, err := {{.ConversionFromDB}}
	if err != nil {
		return {{$.Name}}{}, err
	}
{{- end}}
{{- end}}

	return {{.Name}}{
{{- range .Fields}}
{{- if .RequiresErrorHandling}}
		{{.Name}}: {{lower .Name}},
{{- else}}
		{{.Name}}: {{.ConversionFromDB}},
{{- end}}
{{- end}}
	}, nil
}
{{else}}
func rowTo{{.Name}}(row db.{{SQLCTypeName .TableName}}) {{.Name}} {
	return {{.Name}}{
{{- range .Fields}}
		{{.Name}}: {{.ConversionFromDB}},
{{- end}}
	}
}
{{end}}

{{/* Relation Methods */}}
{{- range .Relations}}

{{- if eq .Type "one_to_many"}}
// {{.LoaderMethod}} loads all {{.RelatedModel}}s that belong to this {{$.Name}}
func ({{$.Name | lower}} {{$.Name}}) {{.LoaderMethod}}(
	ctx context.Context,
	dbtx db.DBTX,
) ([]{{.RelatedModel}}, error) {
	// TODO: Implement one-to-many relation loading
	// This would query {{.RelatedTable}} WHERE {{.ForeignKey}} = {{$.Name | lower}}.ID
	return nil, fmt.Errorf("{{.LoaderMethod}} relation not implemented yet")
}

// Add{{.RelatedModel}} creates a new {{.RelatedModel}} associated with this {{$.Name}}
func ({{$.Name | lower}} {{$.Name}}) Add{{.RelatedModel}}(
	ctx context.Context,
	dbtx db.DBTX,
	data Create{{.RelatedModel}}Data,
) ({{.RelatedModel}}, error) {
	// TODO: Implement relation creation
	// This would set data.{{.ForeignKey}} = {{$.Name | lower}}.ID and create the record
	return {{.RelatedModel}}{}, fmt.Errorf("Add{{.RelatedModel}} relation not implemented yet")
}

// Count{{.LoaderMethod}} counts all {{.RelatedModel}}s that belong to this {{$.Name}}
func ({{$.Name | lower}} {{$.Name}}) Count{{.LoaderMethod}}(
	ctx context.Context,
	dbtx db.DBTX,
) (int64, error) {
	// TODO: Implement one-to-many relation counting
	return 0, fmt.Errorf("Count{{.LoaderMethod}} relation not implemented yet")
}
{{- end}}

{{- if eq .Type "many_to_one"}}
// {{.LoaderMethod}} loads the {{.RelatedModel}} that this {{$.Name}} belongs to
func ({{$.Name | lower}} {{$.Name}}) {{.LoaderMethod}}(
	ctx context.Context,
	dbtx db.DBTX,
) (*{{.RelatedModel}}, error) {
	// TODO: Implement many-to-one relation loading
	// This would load the {{.RelatedModel}} by {{$.Name | lower}}.{{.ForeignKey}}
	return nil, fmt.Errorf("{{.LoaderMethod}} relation not implemented yet")
}
{{- end}}

{{- if eq .Type "many_to_many"}}
// {{.LoaderMethod}} loads all {{.RelatedModel}}s associated with this {{$.Name}} through {{.JoinTable}}
func ({{$.Name | lower}} {{$.Name}}) {{.LoaderMethod}}(
	ctx context.Context,
	dbtx db.DBTX,
) ([]{{.RelatedModel}}, error) {
	// TODO: Implement many-to-many relation loading
	return nil, fmt.Errorf("{{.LoaderMethod}} relation not implemented yet")
}

// Add{{.RelatedModel}} creates an association between this {{$.Name}} and a {{.RelatedModel}}
func ({{$.Name | lower}} {{$.Name}}) Add{{.RelatedModel}}(
	ctx context.Context,
	dbtx db.DBTX,
	{{.RelatedModel | lower}}ID uuid.UUID,
) error {
	// TODO: Implement many-to-many association creation
	return fmt.Errorf("Add{{.RelatedModel}} association not implemented yet")
}

// Remove{{.RelatedModel}} removes the association between this {{$.Name}} and a {{.RelatedModel}}
func ({{$.Name | lower}} {{$.Name}}) Remove{{.RelatedModel}}(
	ctx context.Context,
	dbtx db.DBTX,
	{{.RelatedModel | lower}}ID uuid.UUID,
) error {
	// TODO: Implement many-to-many association removal
	return fmt.Errorf("Remove{{.RelatedModel}} association not implemented yet")
}
{{- end}}

{{- end}}

