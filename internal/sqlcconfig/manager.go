package sqlcconfig

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"gopkg.in/yaml.v3"
)

const (
	baseRelativePath      = "internal/storage/sqlc_base.yaml"
	userRelativePath      = "database/sqlc.yaml"
	effectiveRelativePath = "internal/storage/sqlc.yaml"
)

const defaultBaseConfig = `version: "2"
sql:
  - schema: ../../database/migrations
    queries: ../../database/queries
    engine: postgresql
    gen:
      go:
        package: db
        out: ../../models/internal/db
        output_db_file_name: db.go
        output_models_file_name: entities.go
        emit_sql_as_comment: true
        emit_methods_with_db_argument: true
        sql_package: pgx/v5
        overrides:
          - db_type: uuid
            go_type: github.com/google/uuid.UUID
`

const defaultUserOverlay = `# User SQLC overlay.
#
# This file is merged on top of internal/storage/sqlc_base.yaml to produce
# internal/storage/sqlc.yaml, which is used by andurel sqlc commands.
#
# Example (append another SQL block):
# sql:
#   - schema: ../../database/migrations
#     queries: ../../database/queries
#     engine: postgresql
`

const generatedHeader = "# generated by andurel; DO NOT EDIT\n"

type config struct {
	SQL []struct {
		Engine string `yaml:"engine"`
		Gen    struct {
			Go struct {
				Package                   string `yaml:"package"`
				Out                       string `yaml:"out"`
				OutputDBFileName          string `yaml:"output_db_file_name"`
				OutputModelsFileName      string `yaml:"output_models_file_name"`
				EmitMethodsWithDBArgument bool   `yaml:"emit_methods_with_db_argument"`
				SQLPackage                string `yaml:"sql_package"`
				Overrides                 []struct {
					DBType string `yaml:"db_type"`
					GoType string `yaml:"go_type"`
				} `yaml:"overrides"`
			} `yaml:"go"`
		} `yaml:"gen"`
	} `yaml:"sql"`
}

func BasePath(rootDir string) string {
	return filepath.Join(rootDir, baseRelativePath)
}

func UserPath(rootDir string) string {
	return filepath.Join(rootDir, userRelativePath)
}

func EffectivePath(rootDir string) string {
	return filepath.Join(rootDir, effectiveRelativePath)
}

func Init(rootDir string) ([]string, error) {
	created := make([]string, 0, 2)

	basePath := BasePath(rootDir)
	createdBase, err := ensureFile(basePath, defaultBaseConfig)
	if err != nil {
		return nil, err
	}
	if createdBase {
		created = append(created, baseRelativePath)
	}

	userPath := UserPath(rootDir)
	createdUser, err := ensureFile(userPath, defaultUserOverlay)
	if err != nil {
		return nil, err
	}
	if createdUser {
		created = append(created, userRelativePath)
	}

	if _, err := EnsureEffectiveConfig(rootDir); err != nil {
		return nil, err
	}

	return created, nil
}

func EnsureEffectiveConfig(rootDir string) (string, error) {
	if _, err := ensureFile(BasePath(rootDir), defaultBaseConfig); err != nil {
		return "", err
	}
	if _, err := ensureFile(UserPath(rootDir), defaultUserOverlay); err != nil {
		return "", err
	}

	baseMap, err := readYAMLMap(BasePath(rootDir))
	if err != nil {
		return "", fmt.Errorf("failed to parse base sqlc config: %w", err)
	}

	userMap, err := readYAMLMap(UserPath(rootDir))
	if err != nil {
		return "", fmt.Errorf("failed to parse user sqlc config: %w", err)
	}

	merged := mergeMaps(baseMap, userMap)
	if err := validateConfig(merged); err != nil {
		return "", err
	}

	encoded, err := yaml.Marshal(merged)
	if err != nil {
		return "", fmt.Errorf("failed to encode effective sqlc config: %w", err)
	}

	effectivePath := EffectivePath(rootDir)
	if err := os.MkdirAll(filepath.Dir(effectivePath), 0o755); err != nil {
		return "", fmt.Errorf("failed to create sqlc config directory: %w", err)
	}

	if err := os.WriteFile(effectivePath, []byte(generatedHeader+string(encoded)), 0o644); err != nil {
		return "", fmt.Errorf("failed to write effective sqlc config: %w", err)
	}

	return effectivePath, nil
}

func Validate(rootDir string) error {
	_, err := EnsureEffectiveConfig(rootDir)
	return err
}

func ensureFile(path, content string) (bool, error) {
	if _, err := os.Stat(path); err == nil {
		return false, nil
	} else if !errors.Is(err, os.ErrNotExist) {
		return false, fmt.Errorf("failed to stat %s: %w", path, err)
	}

	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return false, fmt.Errorf("failed to create directory for %s: %w", path, err)
	}

	if err := os.WriteFile(path, []byte(content), 0o644); err != nil {
		return false, fmt.Errorf("failed to create %s: %w", path, err)
	}

	return true, nil
}

func readYAMLMap(path string) (map[string]any, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read %s: %w", path, err)
	}

	if strings.TrimSpace(string(data)) == "" {
		return map[string]any{}, nil
	}

	result := map[string]any{}
	if err := yaml.Unmarshal(data, &result); err != nil {
		return nil, err
	}
	if result == nil {
		return map[string]any{}, nil
	}

	return result, nil
}

func mergeMaps(base, overlay map[string]any) map[string]any {
	result := make(map[string]any, len(base))
	for key, value := range base {
		result[key] = value
	}

	for key, overlayVal := range overlay {
		baseVal, exists := result[key]
		if !exists {
			result[key] = overlayVal
			continue
		}

		baseMap, baseIsMap := baseVal.(map[string]any)
		overlayMap, overlayIsMap := overlayVal.(map[string]any)
		if baseIsMap && overlayIsMap {
			result[key] = mergeMaps(baseMap, overlayMap)
			continue
		}

		baseSlice, baseIsSlice := baseVal.([]any)
		overlaySlice, overlayIsSlice := overlayVal.([]any)
		if baseIsSlice && overlayIsSlice {
			combined := make([]any, 0, len(baseSlice)+len(overlaySlice))
			combined = append(combined, baseSlice...)
			combined = append(combined, overlaySlice...)
			result[key] = combined
			continue
		}

		result[key] = overlayVal
	}

	return result
}

func validateConfig(data map[string]any) error {
	encoded, err := yaml.Marshal(data)
	if err != nil {
		return fmt.Errorf("failed to encode sqlc config for validation: %w", err)
	}

	var cfg config
	if err := yaml.Unmarshal(encoded, &cfg); err != nil {
		return fmt.Errorf("failed to parse effective sqlc config: %w", err)
	}

	if len(cfg.SQL) == 0 {
		return errors.New("effective sqlc config must include at least one sql entry")
	}

	for i, sqlCfg := range cfg.SQL {
		if sqlCfg.Engine != "postgresql" {
			return fmt.Errorf("sql[%d].engine must be postgresql", i)
		}
	}

	goCfg := cfg.SQL[0].Gen.Go
	if goCfg.Package != "db" {
		return fmt.Errorf("sql[0].gen.go.package must be db")
	}
	if goCfg.Out != "../../models/internal/db" {
		return fmt.Errorf("sql[0].gen.go.out must be ../../models/internal/db")
	}
	if goCfg.OutputDBFileName != "db.go" {
		return fmt.Errorf("sql[0].gen.go.output_db_file_name must be db.go")
	}
	if goCfg.OutputModelsFileName != "entities.go" {
		return fmt.Errorf("sql[0].gen.go.output_models_file_name must be entities.go")
	}
	if !goCfg.EmitMethodsWithDBArgument {
		return fmt.Errorf("sql[0].gen.go.emit_methods_with_db_argument must be true")
	}
	if goCfg.SQLPackage != "pgx/v5" {
		return fmt.Errorf("sql[0].gen.go.sql_package must be pgx/v5")
	}

	for i, sqlCfg := range cfg.SQL {
		for j, override := range sqlCfg.Gen.Go.Overrides {
			if override.DBType == "uuid" && override.GoType == "github.com/google/uuid.UUID" {
				continue
			}
			return fmt.Errorf("invalid override at sql[%d].gen.go.overrides[%d]: only uuid -> github.com/google/uuid.UUID is supported", i, j)
		}
	}

	return nil
}
