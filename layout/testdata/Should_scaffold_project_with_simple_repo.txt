=== PROJECT STRUCTURE ===
.env.example
.gitignore
assets/assets.go
assets/css/style.css
assets/js/datastar_1-0-0-rc6.min.js
assets/js/scripts.js
clients/email/mailhog.go
cmd/app/main.go
cmd/console/main.go
cmd/migration/main.go
cmd/run/main.go
config/app.go
config/config.go
config/database.go
config/email.go
config/telemetry.go
controllers/api.go
controllers/assets.go
controllers/cache.go
controllers/controller.go
controllers/pages.go
css/base.css
css/theme.css
database/database.go
database/migrations/.gitkeep
database/migrations/00001_create_river_migration_table.sql
database/migrations/00002_create_river_job_and_leader_tables.sql
database/migrations/00003_alter_river_job_tags.sql
database/migrations/00004_alter_river_job_args_metadata_add_queue.sql
database/migrations/00005_add_river_job_unique_key_and_clients.sql
database/migrations/00006_add_river_job_unique_states.sql
database/queries/.gitkeep
database/sqlc.yaml
email/base_layout.templ
email/base_layout_templ.go
email/components.templ
email/components_templ.go
email/email.go
models/errors.go
models/internal/db/db.go
models/model.go
pkg/telemetry/helpers.go
pkg/telemetry/log_exporters.go
pkg/telemetry/logger.go
pkg/telemetry/metric_exporters.go
pkg/telemetry/metrics.go
pkg/telemetry/options.go
pkg/telemetry/telemetry.go
pkg/telemetry/trace_exporters.go
pkg/telemetry/tracer.go
queue/jobs/send_transactional_email.go
queue/queue.go
queue/workers/send_transactional_email.go
queue/workers/workers.go
router/cookies/cookies.go
router/cookies/flash.go
router/middleware/middleware.go
router/router.go
router/routes/api.go
router/routes/assets.go
router/routes/pages.go
router/routes/route_group.go
router/routes/routes.go
views/bad_request.templ
views/bad_request_templ.go
views/components/form_elements.templ
views/components/form_elements_templ.go
views/components/head.templ
views/components/head_templ.go
views/components/toasts.templ
views/components/toasts_templ.go
views/datastar.go
views/home.templ
views/home_templ.go
views/internal_error.templ
views/internal_error_templ.go
views/layout.templ
views/layout_templ.go
views/not_found.templ
views/not_found_templ.go

=== .env.example ===
ENVIRONMENT=development

DEFAULT_SENDER_SIGNATURE=info@andurel.com

DB_KIND=postgres
DB_PORT=5432
DB_HOST=127.0.0.1
DB_NAME=andurel
DB_USER=postgres
DB_PASSWORD=postgres
DB_SSL_MODE=disable

PROJECT_NAME=webapp
DOMAIN=localhost:8080
PROTOCOL=http

SESSION_KEY=test_session_key_value
SESSION_ENCRYPTION_KEY=test_session_encryption_key_value

TOKEN_SIGNING_KEY=test_token_signing_key_value

PEPPER=test_pepper_value


=== .gitignore ===
node_modules
.env
bin
webapp.db


=== assets/assets.go ===
// Package assets contains embedded static assets.
package assets

import "embed"

//go:embed *
var Files embed.FS


=== assets/css/style.css ===



=== assets/js/datastar_1-0-0-rc6.min.js ===
// Datastar v1.0.0-RC.6
var nt=/ðŸ–•JS_DSðŸš€/.source,De=nt.slice(0,5),Ve=nt.slice(4),q="datastar-fetch",z="datastar-signal-patch";var de=e=>e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").replace(/([a-z])([0-9]+)/gi,"$1-$2").replace(/([0-9]+)([a-z])/gi,"$1-$2").toLowerCase();var rt=e=>de(e).replace(/-/g,"_");var re=e=>{try{return JSON.parse(e)}catch{return Function(`return (${e})`)()}},st={camel:e=>e.replace(/-[a-z]/g,t=>t[1].toUpperCase()),snake:e=>e.replace(/-/g,"_"),pascal:e=>e[0].toUpperCase()+st.camel(e.slice(1))},R=(e,t,n="camel")=>{for(let r of t.get("case")||[n])e=st[r]?.(e)||e;return e},Q=e=>`data-${e}`;var _=Object.hasOwn??Object.prototype.hasOwnProperty.call;var se=e=>e!==null&&typeof e=="object"&&(Object.getPrototypeOf(e)===Object.prototype||Object.getPrototypeOf(e)===null),it=e=>{for(let t in e)if(_(e,t))return!1;return!0},Z=(e,t)=>{for(let n in e){let r=e[n];se(r)||Array.isArray(r)?Z(r,t):e[n]=t(r)}},Te=e=>{let t={};for(let[n,r]of e){let s=n.split("."),i=s.pop(),a=s.reduce((o,c)=>o[c]??={},t);a[i]=r}return t};var Ae=[],Ie=[],Fe=0,Re=0,$e=0,qe,G,we=0,w=()=>{Fe++},M=()=>{--Fe||(ct(),Y())},V=e=>{qe=G,G=e},I=()=>{G=qe,qe=void 0},me=e=>It.bind(0,{previousValue:e,t:e,e:1}),Ge=Symbol("computed"),Ne=e=>{let t=$t.bind(0,{e:17,getter:e});return t[Ge]=1,t},E=e=>{let t={d:e,e:2};G&&Be(t,G),V(t),w();try{t.d()}finally{M(),I()}return dt.bind(0,t)},ct=()=>{for(;Re<$e;){let e=Ie[Re];Ie[Re++]=void 0,ut(e,e.e&=-65)}Re=0,$e=0},ot=e=>"getter"in e?lt(e):ft(e,e.t),lt=e=>{V(e),mt(e);try{let t=e.t;return t!==(e.t=e.getter(t))}finally{I(),pt(e)}},ft=(e,t)=>(e.e=1,e.previousValue!==(e.previousValue=t)),je=e=>{let t=e.e;if(!(t&64)){e.e=t|64;let n=e.r;n?je(n.o):Ie[$e++]=e}},ut=(e,t)=>{if(t&16||t&32&&gt(e.s,e)){V(e),mt(e),w();try{e.d()}finally{M(),I(),pt(e)}return}t&32&&(e.e=t&-33);let n=e.s;for(;n;){let r=n.c,s=r.e;s&64&&ut(r,r.e=s&-65),n=n.i}},It=(e,...t)=>{if(t.length){if(e.t!==(e.t=t[0])){e.e=17;let r=e.r;return r&&(qt(r),Fe||ct()),!0}return!1}let n=e.t;if(e.e&16&&ft(e,n)){let r=e.r;r&&Le(r)}return G&&Be(e,G),n},$t=e=>{let t=e.e;if(t&16||t&32&&gt(e.s,e)){if(lt(e)){let n=e.r;n&&Le(n)}}else t&32&&(e.e=t&-33);return G&&Be(e,G),e.t},dt=e=>{let t=e.s;for(;t;)t=xe(t,e);let n=e.r;n&&xe(n),e.e=0},Be=(e,t)=>{let n=t.a;if(n&&n.c===e)return;let r=n?n.i:t.s;if(r&&r.c===e){r.m=we,t.a=r;return}let s=e.p;if(s&&s.m===we&&s.o===t)return;let i=t.a=e.p={m:we,c:e,o:t,l:n,i:r,f:s};r&&(r.l=i),n?n.i=i:t.s=i,s?s.n=i:e.r=i},xe=(e,t=e.o)=>{let n=e.c,r=e.l,s=e.i,i=e.n,a=e.f;if(s?s.l=r:t.a=r,r?r.i=s:t.s=s,i?i.f=a:n.p=a,a)a.n=i;else if(!(n.r=i))if("getter"in n){let o=n.s;if(o){n.e=17;do o=xe(o,n);while(o)}}else"previousValue"in n||dt(n);return s},qt=e=>{let t=e.n,n;e:for(;;){let r=e.o,s=r.e;if(s&60?s&12?s&4?!(s&48)&&Gt(e,r)?(r.e=s|40,s&=1):s=0:r.e=s&-9|32:s=0:r.e=s|32,s&2&&je(r),s&1){let i=r.r;if(i){let a=(e=i).n;a&&(n={t,u:n},t=a);continue}}if(e=t){t=e.n;continue}for(;n;)if(e=n.t,n=n.u,e){t=e.n;continue e}break}},mt=e=>{we++,e.a=void 0,e.e=e.e&-57|4},pt=e=>{let t=e.a,n=t?t.i:e.s;for(;n;)n=xe(n,e);e.e&=-5},gt=(e,t)=>{let n,r=0,s=!1;e:for(;;){let i=e.c,a=i.e;if(t.e&16)s=!0;else if((a&17)===17){if(ot(i)){let o=i.r;o.n&&Le(o),s=!0}}else if((a&33)===33){(e.n||e.f)&&(n={t:e,u:n}),e=i.s,t=i,++r;continue}if(!s){let o=e.i;if(o){e=o;continue}}for(;r--;){let o=t.r,c=o.n;if(c?(e=n.t,n=n.u):e=o,s){if(ot(t)){c&&Le(o),t=e.o;continue}s=!1}else t.e&=-33;if(t=e.o,e.i){e=e.i;continue e}}return s}},Le=e=>{do{let t=e.o,n=t.e;(n&48)===32&&(t.e=n|16,n&2&&je(t))}while(e=e.n)},Gt=(e,t)=>{let n=t.a;for(;n;){if(n===e)return!0;n=n.l}return!1},ie=e=>{let t=X,n=e.split(".");for(let r of n){if(t==null||!_(t,r))return;t=t[r]}return t},Me=(e,t="")=>{let n=Array.isArray(e);if(n||se(e)){let r=n?[]:{};for(let i in e)r[i]=me(Me(e[i],`${t+i}.`));let s=me(0);return new Proxy(r,{get(i,a){if(!(a==="toJSON"&&!_(r,a)))return n&&a in Array.prototype?(s(),r[a]):typeof a=="symbol"?r[a]:((!_(r,a)||r[a]()==null)&&(r[a]=me(""),Y(t+a,""),s(s()+1)),r[a]())},set(i,a,o){let c=t+a;if(n&&a==="length"){let l=r[a]-o;if(r[a]=o,l>0){let f={};for(let d=o;d<r[a];d++)f[d]=null;Y(t.slice(0,-1),f),s(s()+1)}}else _(r,a)?o==null?delete r[a]:_(o,Ge)?(r[a]=o,Y(c,"")):r[a](Me(o,`${c}.`))&&Y(c,o):o!=null&&(_(o,Ge)?(r[a]=o,Y(c,"")):(r[a]=me(Me(o,`${c}.`)),Y(c,o)),s(s()+1));return!0},deleteProperty(i,a){return delete r[a],s(s()+1),!0},ownKeys(){return s(),Reflect.ownKeys(r)},has(i,a){return s(),a in r}})}return e},Y=(e,t)=>{if(e!==void 0&&t!==void 0&&Ae.push([e,t]),!Fe&&Ae.length){let n=Te(Ae);Ae.length=0,document.dispatchEvent(new CustomEvent(z,{detail:n}))}},C=(e,{ifMissing:t}={})=>{w();for(let n in e)e[n]==null?t||delete X[n]:ht(e[n],n,X,"",t);M()},S=(e,t)=>C(Te(e),t),ht=(e,t,n,r,s)=>{if(se(e)){_(n,t)&&(se(n[t])||Array.isArray(n[t]))||(n[t]={});for(let i in e)e[i]==null?s||delete n[t][i]:ht(e[i],i,n[t],`${r+t}.`,s)}else s&&_(n,t)||(n[t]=e)},at=e=>typeof e=="string"?RegExp(e.replace(/^\/|\/$/g,"")):e,D=({include:e=/.*/,exclude:t=/(?!)/}={},n=X)=>{let r=at(e),s=at(t),i=[],a=[[n,""]];for(;a.length;){let[o,c]=a.pop();for(let l in o){let f=c+l;se(o[l])?a.push([o[l],`${f}.`]):r.test(f)&&!s.test(f)&&i.push([f,ie(f)])}}return Te(i)},X=Me({});var W=e=>e instanceof HTMLElement||e instanceof SVGElement||e instanceof MathMLElement;var jt="https://data-star.dev/errors",pe=(e,t,n={})=>{Object.assign(n,e);let r=new Error,s=rt(t),i=new URLSearchParams({metadata:JSON.stringify(n)}).toString(),a=JSON.stringify(n,null,2);return r.message=`${t}
More info: ${jt}/${s}?${i}
Context: ${a}`,r},Oe=new Map,vt=new Map,bt=new Map,Et=new Proxy({},{get:(e,t)=>Oe.get(t)?.apply,has:(e,t)=>Oe.has(t),ownKeys:()=>Reflect.ownKeys(Oe),set:()=>!1,deleteProperty:()=>!1}),ge=new Map,Ce=[],We=new Set,p=e=>{Ce.push(e),Ce.length===1&&setTimeout(()=>{for(let t of Ce)We.add(t.name),vt.set(t.name,t);Ce.length=0,Jt(),We.clear()})},O=e=>{Oe.set(e.name,e)};document.addEventListener(q,e=>{let t=bt.get(e.detail.type);t&&t.apply({error:pe.bind(0,{plugin:{type:"watcher",name:t.name},element:{id:e.target.id,tag:e.target.tagName}})},e.detail.argsRaw)});var he=e=>{bt.set(e.name,e)},yt=e=>{for(let t of e){let n=ge.get(t);if(ge.delete(t)){for(let r of n.values())r();n.clear()}}},St=Q("ignore"),Bt=`[${St}]`,Tt=e=>e.hasAttribute(`${St}__self`)||!!e.closest(Bt),Pe=(e,t)=>{for(let n of e)if(!Tt(n))for(let r in n.dataset)At(n,r.replace(/[A-Z]/g,"-$&").toLowerCase(),n.dataset[r],t)},Wt=e=>{for(let{target:t,type:n,attributeName:r,addedNodes:s,removedNodes:i}of e)if(n==="childList"){for(let a of i)W(a)&&(yt([a]),yt(a.querySelectorAll("*")));for(let a of s)W(a)&&(Pe([a]),Pe(a.querySelectorAll("*")))}else if(n==="attributes"&&r.startsWith("data-")&&W(t)&&!Tt(t)){let a=r.slice(5),o=t.getAttribute(r);if(o===null){let c=ge.get(t);c&&(c.get(a)?.(),c.delete(a))}else At(t,a,o)}},Ut=new MutationObserver(Wt),Jt=(e=document.documentElement)=>{W(e)&&Pe([e],!0),Pe(e.querySelectorAll("*"),!0),Ut.observe(e,{subtree:!0,childList:!0,attributes:!0})},At=(e,t,n,r)=>{{let s=t,[i,...a]=s.split("__"),[o,c]=i.split(/:(.+)/),l=vt.get(o);if((!r||We.has(o))&&l){let f={el:e,rawKey:s,mods:new Map,error:pe.bind(0,{plugin:{type:"attribute",name:l.name},element:{id:e.id,tag:e.tagName},expression:{rawKey:s,key:c,value:n}}),key:c,value:n,rx:void 0},d=l.requirement&&(typeof l.requirement=="string"?l.requirement:l.requirement.key)||"allowed",x=l.requirement&&(typeof l.requirement=="string"?l.requirement:l.requirement.value)||"allowed";if(c){if(d==="denied")throw f.error("KeyNotAllowed")}else if(d==="must")throw f.error("KeyRequired");if(n){if(x==="denied")throw f.error("ValueNotAllowed")}else if(x==="must")throw f.error("ValueRequired");if(d==="exclusive"||x==="exclusive"){if(c&&n)throw f.error("KeyAndValueProvided");if(!c&&!n)throw f.error("KeyOrValueRequired")}if(n){let m;f.rx=(...h)=>(m||(m=Kt(n,{returnsValue:l.returnsValue,argNames:l.argNames})),m(e,...h))}for(let m of a){let[h,...v]=m.split(".");f.mods.set(h,new Set(v))}let u=l.apply(f);if(u){let m=ge.get(e);m?m.get(s)?.():(m=new Map,ge.set(e,m)),m.set(s,u)}}}},Kt=(e,{returnsValue:t=!1,argNames:n=[]}={})=>{let r="";if(t){let o=/(\/(\\\/|[^/])*\/|"(\\"|[^"])*"|'(\\'|[^'])*'|`(\\`|[^`])*`|\(\s*((function)\s*\(\s*\)|(\(\s*\))\s*=>)\s*(?:\{[\s\S]*?\}|[^;){]*)\s*\)\s*\(\s*\)|[^;])+/gm,c=e.trim().match(o);if(c){let l=c.length-1,f=c[l].trim();f.startsWith("return")||(c[l]=`return (${f});`),r=c.join(`;
`)}}else r=e.trim();let s=new Map,i=RegExp(`(?:${De})(.*?)(?:${Ve})`,"gm"),a=0;for(let o of r.matchAll(i)){let c=o[1],l=`__escaped${a++}`;s.set(l,c),r=r.replace(De+c+Ve,l)}r=r.replace(/\$\['([a-zA-Z_$\d][\w$]*)'\]/g,"$$$1").replace(/\$([a-zA-Z_\d]\w*(?:[.-]\w+)*)/g,(o,c)=>c.split(".").reduce((l,f)=>`${l}['${f}']`,"$")).replace(/\[(\$[a-zA-Z_\d]\w*)\]/g,(o,c)=>`[$['${c.slice(1)}']]`),r=r.replaceAll(/@(\w+)\(/g,'__action("$1",evt,');for(let[o,c]of s)r=r.replace(o,c);try{let o=Function("el","$","__action","evt",...n,r);return(c,...l)=>{let f=(d,x,...u)=>{let m=pe.bind(0,{plugin:{type:"action",name:d},element:{id:c.id,tag:c.tagName},expression:{fnContent:r,value:e}}),h=Et[d];if(h)return h({el:c,evt:x,error:m},...u);throw m("UndefinedAction")};try{return o(c,X,f,void 0,...l)}catch(d){throw console.error(d),pe({element:{id:c.id,tag:c.tagName},expression:{fnContent:r,value:e},error:d.message},"ExecuteExpression")}}}catch(o){throw console.error(o),pe({expression:{fnContent:r,value:e},error:o.message},"GenerateExpression")}};var P=new Map,ae=new Set,oe=new Map,ye=new Set,ce=document.createElement("div");ce.hidden=!0;var ve=Q("ignore-morph"),zt=`[${ve}]`,Ke=(e,t,n="outer")=>{if(W(e)&&W(t)&&e.hasAttribute(ve)&&t.hasAttribute(ve)||e.parentElement?.closest(zt))return;let r=document.createElement("div");r.append(t),document.body.insertAdjacentElement("afterend",ce);let s=e.querySelectorAll("[id]");for(let{id:o,tagName:c}of s)oe.has(o)?ye.add(o):oe.set(o,c);e instanceof Element&&e.id&&(oe.has(e.id)?ye.add(e.id):oe.set(e.id,e.tagName)),ae.clear();let i=r.querySelectorAll("[id]");for(let{id:o,tagName:c}of i)ae.has(o)?ye.add(o):oe.get(o)===c&&ae.add(o);for(let o of ye)ae.delete(o);oe.clear(),ye.clear(),P.clear();let a=n==="outer"?e.parentElement:e;wt(a,s),wt(r,i),Mt(a,r,n==="outer"?e:null,e.nextSibling),ce.remove()},Mt=(e,t,n=null,r=null)=>{e instanceof HTMLTemplateElement&&t instanceof HTMLTemplateElement&&(e=e.content,t=t.content),n??=e.firstChild;for(let s of t.childNodes){if(n&&n!==r){let i=Qt(s,n,r);if(i){if(i!==n){let a=n;for(;a&&a!==i;){let o=a;a=a.nextSibling,Je(o)}}Ue(i,s),n=i.nextSibling;continue}}if(s instanceof Element&&ae.has(s.id)){let i=document.getElementById(s.id),a=i;for(;a=a.parentNode;){let o=P.get(a);o&&(o.delete(s.id),o.size||P.delete(a))}xt(e,i,n),Ue(i,s),n=i.nextSibling;continue}if(P.has(s)){let i=document.createElement(s.tagName);e.insertBefore(i,n),Ue(i,s),n=i.nextSibling}else{let i=document.importNode(s,!0);e.insertBefore(i,n),n=i.nextSibling}}for(;n&&n!==r;){let s=n;n=n.nextSibling,Je(s)}},Qt=(e,t,n)=>{let r=null,s=e.nextSibling,i=0,a=0,o=P.get(e)?.size||0,c=t;for(;c&&c!==n;){if(Rt(c,e)){let l=!1,f=P.get(c),d=P.get(e);if(d&&f){for(let x of f)if(d.has(x)){l=!0;break}}if(l)return c;if(!r&&!P.has(c)){if(!o)return c;r=c}}if(a+=P.get(c)?.size||0,a>o)break;r===null&&s&&Rt(c,s)&&(i++,s=s.nextSibling,i>=2&&(r=void 0)),c=c.nextSibling}return r||null},Rt=(e,t)=>e.nodeType===t.nodeType&&e.tagName===t.tagName&&(!e.id||e.id===t.id),Je=e=>{P.has(e)?xt(ce,e,null):e.parentNode?.removeChild(e)},xt=Je.call.bind(ce.moveBefore??ce.insertBefore),Zt=Q("preserve-attr"),Ue=(e,t)=>{let n=t.nodeType;if(n===1){let r=e,s=t;if(r.hasAttribute(ve)&&s.hasAttribute(ve))return e;r instanceof HTMLInputElement&&s instanceof HTMLInputElement&&s.type!=="file"?s.getAttribute("value")!==r.getAttribute("value")&&(r.value=s.getAttribute("value")??""):r instanceof HTMLTextAreaElement&&s instanceof HTMLTextAreaElement&&(s.value!==r.value&&(r.value=s.value),r.firstChild&&r.firstChild.nodeValue!==s.value&&(r.firstChild.nodeValue=s.value));let i=(t.getAttribute(Zt)??"").split(" ");for(let{name:a,value:o}of s.attributes)r.getAttribute(a)!==o&&!i.includes(a)&&r.setAttribute(a,o);for(let a=r.attributes.length-1;a>=0;a--){let{name:o}=r.attributes[a];!s.hasAttribute(o)&&!i.includes(o)&&r.removeAttribute(o)}r.isEqualNode(s)||Mt(r,s)}return(n===8||n===3)&&e.nodeValue!==t.nodeValue&&(e.nodeValue=t.nodeValue),e},wt=(e,t)=>{for(let n of t)if(ae.has(n.id)){let r=n;for(;r&&r!==e;){let s=P.get(r);s||(s=new Set,P.set(r,s)),s.add(n.id),r=r.parentElement}}};O({name:"peek",apply(e,t){V();try{return t()}finally{I()}}});O({name:"setAll",apply(e,t,n){V();let r=D(n);Z(r,()=>t),C(r),I()}});O({name:"toggleAll",apply(e,t){V();let n=D(t);Z(n,r=>!r),C(n),I()}});var He=new WeakMap,be=(e,t)=>O({name:e,apply:async({el:n,evt:r,error:s},i,{selector:a,headers:o,contentType:c="json",filterSignals:{include:l=/.*/,exclude:f=/(^|\.)_/}={},openWhenHidden:d=!1,retryInterval:x=1e3,retryScaler:u=2,retryMaxWaitMs:m=3e4,retryMaxCount:h=10,requestCancellation:v="auto"}={})=>{let L=v instanceof AbortController?v:new AbortController,A=v==="disabled";if(!A){let T=He.get(n);T&&(T.abort(),await Promise.resolve())}!A&&!(v instanceof AbortController)&&He.set(n,L);try{let T=new MutationObserver(j=>{for(let H of j)for(let B of H.removedNodes)B===n&&(L.abort(),K())});n.parentNode&&T.observe(n.parentNode,{childList:!0});let K=()=>{T.disconnect()};try{if(!i?.length)throw s("FetchNoUrlProvided",{action:O});let j={Accept:"text/event-stream, text/html, application/json","Datastar-Request":!0};c==="json"&&(j["Content-Type"]="application/json");let H=Object.assign({},j,o),B={method:t,headers:H,openWhenHidden:d,retryInterval:x,retryScaler:u,retryMaxWaitMs:m,retryMaxCount:h,signal:L.signal,onopen:async g=>{g.status>=400&&ee(Yt,n,{status:g.status.toString()})},onmessage:g=>{if(!g.event.startsWith("datastar"))return;let $=g.event,b={};for(let N of g.data.split(`
`)){let y=N.indexOf(" "),k=N.slice(0,y),ue=N.slice(y+1);(b[k]||=[]).push(ue)}let F=Object.fromEntries(Object.entries(b).map(([N,y])=>[N,y.join(`
`)]));ee($,n,F)},onerror:g=>{if(Lt(g))throw g("FetchExpectedTextEventStream",{url:i});g&&(console.error(g.message),ee(Xt,n,{message:g.message}))}},fe=new URL(i,document.baseURI),ne=new URLSearchParams(fe.search);if(c==="json"){let g=JSON.stringify(D({include:l,exclude:f}));t==="GET"?ne.set("datastar",g):B.body=g}else if(c==="form"){let g=a?document.querySelector(a):n.closest("form");if(!g)throw s("FetchFormNotFound",{action:O,selector:a});if(!g.checkValidity()){g.reportValidity(),K();return}let $=new FormData(g),b=n;if(n===g&&r instanceof SubmitEvent)b=r.submitter;else{let y=k=>k.preventDefault();g.addEventListener("submit",y),K=()=>{g.removeEventListener("submit",y),T.disconnect()}}if(b instanceof HTMLButtonElement){let y=b.getAttribute("name");y&&$.append(y,b.value)}let F=g.getAttribute("enctype")==="multipart/form-data";F||(H["Content-Type"]="application/x-www-form-urlencoded");let N=new URLSearchParams($);if(t==="GET")for(let[y,k]of N)ne.append(y,k);else F?B.body=$:B.body=N}else throw s("FetchInvalidContentType",{action:O,contentType:c});ee(ze,n,{}),fe.search=ne.toString();try{await on(fe.toString(),n,B)}catch(g){if(!Lt(g))throw s("FetchFailed",{method:t,url:i,error:g.message})}}finally{ee(Qe,n,{}),K()}}finally{He.get(n)===L&&He.delete(n)}}});be("delete","DELETE");be("get","GET");be("patch","PATCH");be("post","POST");be("put","PUT");var ze="started",Qe="finished",Yt="error",Xt="retrying",en="retries-failed",ee=(e,t,n)=>document.dispatchEvent(new CustomEvent(q,{detail:{type:e,el:t,argsRaw:n}})),Lt=e=>`${e}`.includes("text/event-stream"),tn=async(e,t)=>{let n=e.getReader(),r=await n.read();for(;!r.done;)t(r.value),r=await n.read()},nn=e=>{let t,n,r,s=!1;return i=>{t?t=sn(t,i):(t=i,n=0,r=-1);let a=t.length,o=0;for(;n<a;){s&&(t[n]===10&&(o=++n),s=!1);let c=-1;for(;n<a&&c===-1;++n)switch(t[n]){case 58:r===-1&&(r=n-o);break;case 13:s=!0;case 10:c=n;break}if(c===-1)break;e(t.subarray(o,c),r),o=n,r=-1}o===a?t=void 0:o&&(t=t.subarray(o),n-=o)}},rn=(e,t,n)=>{let r=Ft(),s=new TextDecoder;return(i,a)=>{if(!i.length)n?.(r),r=Ft();else if(a>0){let o=s.decode(i.subarray(0,a)),c=a+(i[a+1]===32?2:1),l=s.decode(i.subarray(c));switch(o){case"data":r.data=r.data?`${r.data}
${l}`:l;break;case"event":r.event=l;break;case"id":e(r.id=l);break;case"retry":{let f=+l;Number.isNaN(f)||t(r.retry=f);break}}}}},sn=(e,t)=>{let n=new Uint8Array(e.length+t.length);return n.set(e),n.set(t,e.length),n},Ft=()=>({data:"",event:"",id:"",retry:void 0}),on=(e,t,{signal:n,headers:r,onopen:s,onmessage:i,onclose:a,onerror:o,openWhenHidden:c,fetch:l,retryInterval:f=1e3,retryScaler:d=2,retryMaxWaitMs:x=3e4,retryMaxCount:u=10,overrides:m,...h})=>new Promise((v,L)=>{let A={...r},T,K=()=>{T.abort(),document.hidden||$()};c||document.addEventListener("visibilitychange",K);let j=0,H=()=>{document.removeEventListener("visibilitychange",K),clearTimeout(j),T.abort()};n?.addEventListener("abort",()=>{H(),v()});let B=l||window.fetch,fe=s||(()=>{}),ne=0,g=f,$=async()=>{T=new AbortController;try{let b=await B(e,{...h,headers:A,signal:T.signal});ne=0,f=g,await fe(b);let F=async(y,k,ue,Ee,...Vt)=>{let tt={[ue]:await k.text()};for(let ke of Vt){let _e=k.headers.get(`datastar-${de(ke)}`);if(Ee){let Se=Ee[ke];Se&&(_e=typeof Se=="string"?Se:JSON.stringify(Se))}_e&&(tt[ke]=_e)}ee(y,t,tt),H(),v()},N=b.headers.get("Content-Type");if(N?.includes("text/html"))return await F("datastar-patch-elements",b,"elements",m,"selector","mode","useViewTransition");if(N?.includes("application/json"))return await F("datastar-patch-signals",b,"signals",m,"onlyIfMissing");if(N?.includes("text/javascript")){let y=document.createElement("script"),k=b.headers.get("datastar-script-attributes");if(k)for(let[ue,Ee]of Object.entries(JSON.parse(k)))y.setAttribute(ue,Ee);y.textContent=await b.text(),document.head.appendChild(y),H();return}await tn(b.body,nn(rn(y=>{y?A["last-event-id"]=y:delete A["last-event-id"]},y=>{g=f=y},i))),a?.(),H(),v()}catch(b){if(!T.signal.aborted)try{let F=o?.(b)||f;clearTimeout(j),j=setTimeout($,F),f=Math.min(f*d,x),++ne>=u?(ee(en,t,{}),H(),L("Max retries reached.")):console.error(`Datastar failed to reach ${e.toString()} retrying in ${F}ms.`)}catch(F){H(),L(F)}}};$()});p({name:"attr",requirement:{value:"must"},returnsValue:!0,apply({el:e,key:t,rx:n}){let r=(o,c)=>{c===""||c===!0?e.setAttribute(o,""):c===!1||c==null?e.removeAttribute(o):typeof c=="string"?e.setAttribute(o,c):e.setAttribute(o,JSON.stringify(c))},s=t?()=>{i.disconnect();let o=n();r(t,o),i.observe(e,{attributeFilter:[t]})}:()=>{i.disconnect();let o=n(),c=Object.keys(o);for(let l of c)r(l,o[l]);i.observe(e,{attributeFilter:c})},i=new MutationObserver(s),a=E(s);return()=>{i.disconnect(),a()}}});var an=/^data:(?<mime>[^;]+);base64,(?<contents>.*)$/,Nt=Symbol("empty"),Ct=Q("bind");p({name:"bind",requirement:"exclusive",apply({el:e,key:t,mods:n,value:r,error:s}){let i=t!=null?R(t,n):r,a=(u,m)=>m==="number"?+u.value:u.value,o=u=>{e.value=`${u}`};if(e instanceof HTMLInputElement)switch(e.type){case"range":case"number":a=(u,m)=>m==="string"?u.value:+u.value;break;case"checkbox":a=(u,m)=>u.value!=="on"?m==="boolean"?u.checked:u.checked?u.value:"":m==="string"?u.checked?u.value:"":u.checked,o=u=>{e.checked=typeof u=="string"?u===e.value:u};break;case"radio":e.getAttribute("name")?.length||e.setAttribute("name",i),a=(u,m)=>u.checked?m==="number"?+u.value:u.value:Nt,o=u=>{e.checked=u===(typeof u=="number"?+e.value:e.value)};break;case"file":{let u=()=>{let m=[...e.files||[]],h=[];Promise.all(m.map(v=>new Promise(L=>{let A=new FileReader;A.onload=()=>{if(typeof A.result!="string")throw s("InvalidFileResultType",{resultType:typeof A.result});let T=A.result.match(an);if(!T?.groups)throw s("InvalidDataUri",{result:A.result});h.push({name:v.name,contents:T.groups.contents,mime:T.groups.mime})},A.onloadend=()=>L(),A.readAsDataURL(v)}))).then(()=>{S([[i,h]])})};return e.addEventListener("change",u),e.addEventListener("input",u),()=>{e.removeEventListener("change",u),e.removeEventListener("input",u)}}}else if(e instanceof HTMLSelectElement){if(e.multiple){let u=new Map;a=m=>[...m.selectedOptions].map(h=>{let v=u.get(h.value);return v==="string"||v==null?h.value:+h.value}),o=m=>{for(let h of e.options)m.includes(h.value)?(u.set(h.value,"string"),h.selected=!0):m.includes(+h.value)?(u.set(h.value,"number"),h.selected=!0):h.selected=!1}}}else e instanceof HTMLTextAreaElement||(a=u=>"value"in u?u.value:u.getAttribute("value"),o=u=>{"value"in e?e.value=u:e.setAttribute("value",u)});let c=ie(i),l=typeof c,f=i;if(Array.isArray(c)&&!(e instanceof HTMLSelectElement&&e.multiple)){let u=t||r,m=document.querySelectorAll(`[${Ct}\\:${CSS.escape(u)}],[${Ct}="${CSS.escape(u)}"]`),h=[],v=0;for(let L of m){if(h.push([`${f}.${v}`,a(L,"none")]),e===L)break;v++}S(h,{ifMissing:!0}),f=`${f}.${v}`}else S([[f,a(e,l)]],{ifMissing:!0});let d=()=>{let u=ie(f);if(u!=null){let m=a(e,typeof u);m!==Nt&&S([[f,m]])}};e.addEventListener("input",d),e.addEventListener("change",d);let x=E(()=>{o(ie(f))});return()=>{x(),e.removeEventListener("input",d),e.removeEventListener("change",d)}}});p({name:"class",requirement:{value:"must"},returnsValue:!0,apply({key:e,el:t,mods:n,rx:r}){e&&(e=R(e,n,"kebab"));let s=()=>{i.disconnect();let o=e?{[e]:r()}:r();for(let c in o){let l=c.split(/\s+/).filter(f=>f.length>0);if(o[c])for(let f of l)t.classList.contains(f)||t.classList.add(f);else for(let f of l)t.classList.contains(f)&&t.classList.remove(f)}i.observe(t,{attributeFilter:["class"]})},i=new MutationObserver(s),a=E(s);return()=>{i.disconnect(),a();let o=e?{[e]:r()}:r();for(let c in o){let l=c.split(/\s+/).filter(f=>f.length>0);for(let f of l)t.classList.remove(f)}}}});p({name:"computed",requirement:{value:"must"},returnsValue:!0,apply({key:e,mods:t,rx:n,error:r}){if(e)S([[R(e,t),Ne(n)]]);else{let s=Object.assign({},n());Z(s,i=>{if(typeof i=="function")return Ne(i);throw r("ComputedExpectedFunction")}),C(s)}}});p({name:"effect",requirement:{key:"denied",value:"must"},apply:({rx:e})=>E(e)});p({name:"indicator",requirement:"exclusive",apply({el:e,key:t,mods:n,value:r}){let s=t!=null?R(t,n):r;S([[s,!1]]);let i=a=>{let{type:o,el:c}=a.detail;if(c===e)switch(o){case ze:S([[s,!0]]);break;case Qe:S([[s,!1]]);break}};return document.addEventListener(q,i),()=>{S([[s,!1]]),document.removeEventListener(q,i)}}});p({name:"json-signals",requirement:{key:"denied"},apply({el:e,value:t,mods:n}){let r=n.has("terse")?0:2,s={};t&&(s=re(t));let i=()=>{a.disconnect(),e.textContent=JSON.stringify(D(s),null,r),a.observe(e,{childList:!0,characterData:!0,subtree:!0})},a=new MutationObserver(i),o=E(i);return()=>{a.disconnect(),o()}}});var U=e=>{if(!e||e.size<=0)return 0;for(let t of e){if(t.endsWith("ms"))return+t.replace("ms","");if(t.endsWith("s"))return+t.replace("s","")*1e3;try{return Number.parseFloat(t)}catch{}}return 0},te=(e,t,n=!1)=>e?e.has(t.toLowerCase()):n;var Ze=(e,t)=>(...n)=>{setTimeout(()=>{e(...n)},t)},cn=(e,t,n=!1,r=!0)=>{let s=0;return(...i)=>{s&&clearTimeout(s),n&&!s&&e(...i),s=setTimeout(()=>{r&&e(...i),s&&clearTimeout(s),s=0},t)}},ln=(e,t,n=!0,r=!1)=>{let s=!1;return(...i)=>{s||(n&&e(...i),s=!0,setTimeout(()=>{r&&e(...i),s=!1},t))}},le=(e,t)=>{let n=t.get("delay");if(n){let i=U(n);e=Ze(e,i)}let r=t.get("debounce");if(r){let i=U(r),a=te(r,"leading",!1),o=!te(r,"notrailing",!1);e=cn(e,i,a,o)}let s=t.get("throttle");if(s){let i=U(s),a=!te(s,"noleading",!1),o=te(s,"trailing",!1);e=ln(e,i,a,o)}return e};var Ye=!!document.startViewTransition,J=(e,t)=>{if(t.has("viewtransition")&&Ye){let n=e;e=(...r)=>document.startViewTransition(()=>n(...r))}return e};p({name:"on",requirement:"must",argNames:["evt"],apply({el:e,key:t,mods:n,rx:r}){let s=e;n.has("window")&&(s=window);let i=c=>{c&&(n.has("prevent")&&c.preventDefault(),n.has("stop")&&c.stopPropagation()),w(),r(c),M()};i=J(i,n),i=le(i,n);let a={capture:n.has("capture"),passive:n.has("passive"),once:n.has("once")};if(n.has("outside")){s=document;let c=i;i=l=>{e.contains(l?.target)||c(l)}}let o=R(t,n,"kebab");if((o===q||o===z)&&(s=document),e instanceof HTMLFormElement&&o==="submit"){let c=i;i=l=>{l?.preventDefault(),c(l)}}return s.addEventListener(o,i,a),()=>{s.removeEventListener(o,i)}}});var Xe=new WeakSet;p({name:"on-intersect",requirement:{key:"denied",value:"must"},apply({el:e,mods:t,rx:n}){let r=()=>{w(),n(),M()};r=J(r,t),r=le(r,t);let s={threshold:0};t.has("full")?s.threshold=1:t.has("half")&&(s.threshold=.5);let i=new IntersectionObserver(a=>{for(let o of a)o.isIntersecting&&(r(),i&&Xe.has(e)&&i.disconnect())},s);return i.observe(e),t.has("once")&&Xe.add(e),()=>{t.has("once")||Xe.delete(e),i&&(i.disconnect(),i=null)}}});p({name:"on-interval",requirement:{key:"denied",value:"must"},apply({mods:e,rx:t}){let n=()=>{w(),t(),M()};n=J(n,e);let r=1e3,s=e.get("duration");s&&(r=U(s),te(s,"leading",!1)&&n());let i=setInterval(n,r);return()=>{clearInterval(i)}}});p({name:"init",requirement:{key:"denied",value:"must"},apply({rx:e,mods:t}){let n=()=>{w(),e(),M()};n=J(n,t);let r=0,s=t.get("delay");s&&(r=U(s),r>0&&(n=Ze(n,r))),n()}});p({name:"on-signal-patch",requirement:{value:"must"},argNames:["patch"],returnsValue:!0,apply({el:e,key:t,mods:n,rx:r,error:s}){if(t&&t!=="filter")throw s("KeyNotAllowed");let i=e.getAttribute("data-on-signal-patch-filter"),a={};i&&(a=re(i));let o=le(c=>{let l=D(a,c.detail);it(l)||(w(),r(l),M())},n);return document.addEventListener(z,o),()=>{document.removeEventListener(z,o)}}});p({name:"ref",requirement:"exclusive",apply({el:e,key:t,mods:n,value:r}){let s=t!=null?R(t,n):r;S([[s,e]])}});var Ot="none",Pt="display";p({name:"show",requirement:{key:"denied",value:"must"},returnsValue:!0,apply({el:e,rx:t}){let n=()=>{r.disconnect(),t()?e.style.display===Ot&&e.style.removeProperty(Pt):e.style.setProperty(Pt,Ot),r.observe(e,{attributeFilter:["style"]})},r=new MutationObserver(n),s=E(n);return()=>{r.disconnect(),s()}}});p({name:"signals",returnsValue:!0,apply({key:e,mods:t,rx:n}){let r=t.has("ifmissing");if(e)e=R(e,t),S([[e,n?.()]],{ifMissing:r});else{let s=Object.assign({},n?.());C(s,{ifMissing:r})}}});p({name:"style",requirement:{value:"must"},returnsValue:!0,apply({key:e,el:t,rx:n}){let{style:r}=t,s=new Map,i=(l,f)=>{let d=s.get(l);!f&&f!==0?d!==void 0&&(d?r.setProperty(l,d):r.removeProperty(l)):(d===void 0&&s.set(l,r.getPropertyValue(l)),r.setProperty(l,String(f)))},a=()=>{if(o.disconnect(),e)i(e,n());else{let l=n();for(let[f,d]of s)f in l||(d?r.setProperty(f,d):r.removeProperty(f));for(let f in l)i(de(f),l[f])}o.observe(t,{attributeFilter:["style"]})},o=new MutationObserver(a),c=E(a);return()=>{o.disconnect(),c();for(let[l,f]of s)f?r.setProperty(l,f):r.removeProperty(l)}}});p({name:"text",requirement:{key:"denied",value:"must"},returnsValue:!0,apply({el:e,rx:t}){let n=()=>{r.disconnect(),e.textContent=`${t()}`,r.observe(e,{childList:!0,characterData:!0,subtree:!0})},r=new MutationObserver(n),s=E(n);return()=>{r.disconnect(),s()}}});he({name:"datastar-patch-elements",apply(e,{elements:t="",selector:n="",mode:r="outer",useViewTransition:s}){switch(r){case"remove":case"outer":case"inner":case"replace":case"prepend":case"append":case"before":case"after":break;default:throw e.error("PatchElementsInvalidMode",{mode:r})}if(!n&&r!=="outer"&&r!=="replace")throw e.error("PatchElementsExpectedSelector");let i={mode:r,selector:n,elements:t,useViewTransition:s?.trim()==="true"};Ye&&s?document.startViewTransition(()=>Ht(e,i)):Ht(e,i)}});var Ht=({error:e},{elements:t,selector:n,mode:r})=>{let s=t.replace(/<svg(\s[^>]*>|>)([\s\S]*?)<\/svg>/gim,""),i=/<\/html>/.test(s),a=/<\/head>/.test(s),o=/<\/body>/.test(s),c=new DOMParser().parseFromString(i||a||o?t:`<body><template>${t}</template></body>`,"text/html"),l=document.createDocumentFragment();if(i?l.appendChild(c.documentElement):a&&o?(l.appendChild(c.head),l.appendChild(c.body)):a?l.appendChild(c.head):o?l.appendChild(c.body):l=c.querySelector("template").content,!n&&(r==="outer"||r==="replace"))for(let f of l.children){let d;if(f instanceof HTMLHtmlElement)d=document.documentElement;else if(f instanceof HTMLBodyElement)d=document.body;else if(f instanceof HTMLHeadElement)d=document.head;else if(d=document.getElementById(f.id),!d){console.warn(e("PatchElementsNoTargetsFound"),{element:{id:f.id}});continue}_t(r,f,[d])}else{let f=document.querySelectorAll(n);if(!f.length){console.warn(e("PatchElementsNoTargetsFound"),{selector:n});return}_t(r,l,f)}},et=new WeakSet;for(let e of document.querySelectorAll("script"))et.add(e);var Dt=e=>{let t=e instanceof HTMLScriptElement?[e]:e.querySelectorAll("script");for(let n of t)if(!et.has(n)){let r=document.createElement("script");for(let{name:s,value:i}of n.attributes)r.setAttribute(s,i);r.text=n.text,n.replaceWith(r),et.add(r)}},kt=(e,t,n)=>{for(let r of e){let s=t.cloneNode(!0);Dt(s),r[n](s)}},_t=(e,t,n)=>{switch(e){case"remove":for(let r of n)r.remove();break;case"outer":case"inner":for(let r of n)Ke(r,t.cloneNode(!0),e),Dt(r);break;case"replace":kt(n,t,"replaceWith");break;case"prepend":case"append":case"before":case"after":kt(n,t,e)}};he({name:"datastar-patch-signals",apply({error:e},{signals:t,onlyIfMissing:n}){if(t){let r=n?.trim()==="true";C(re(t),{ifMissing:r})}else throw e("PatchSignalsExpectedSignals")}});export{O as action,Et as actions,p as attribute,w as beginBatch,Ne as computed,E as effect,M as endBatch,D as filtered,ie as getPath,C as mergePatch,S as mergePaths,Ke as morph,X as root,me as signal,V as startPeeking,I as stopPeeking,he as watcher};
//# sourceMappingURL=datastar.js.map


=== assets/js/scripts.js ===
import "./datastar_1-0-0-rc6.min.js"


=== clients/email/mailhog.go ===
package mailclients

import (
	"context"
	"fmt"
	"net/smtp"
	"strings"

	"myorg/webapp/email"
)

var _ email.Sender = (*MailHog)(nil)

type MailHog struct {
	host string
	port string
}

func NewMailHog(host, port string) *MailHog {
	return &MailHog{
		host,
		port,
	}
}

func (m *MailHog) SendTransactional(ctx context.Context, payload email.TransactionalPayload) error {
	addr := fmt.Sprintf("%s:%s", m.host, m.port)

	boundary := "boundary-mailhog-client"
	headers := make(map[string]string)
	headers["From"] = payload.From
	headers["To"] = payload.To

	if len(payload.Cc) > 0 {
		headers["Cc"] = strings.Join(payload.Cc, ", ")
	}

	if len(payload.Bcc) > 0 {
		headers["Bcc"] = strings.Join(payload.Bcc, ", ")
	}

	if payload.ReplyTo != "" {
		headers["Reply-To"] = payload.ReplyTo
	}

	headers["Subject"] = payload.Subject
	headers["MIME-Version"] = "1.0"
	headers["Content-Type"] = fmt.Sprintf("multipart/alternative; boundary=\"%s\"", boundary)

	var message strings.Builder
	for k, v := range headers {
		message.WriteString(fmt.Sprintf("%s: %s\r\n", k, v))
	}
	message.WriteString("\r\n")

	if payload.TextBody != "" {
		message.WriteString(fmt.Sprintf("--%s\r\n", boundary))
		message.WriteString("Content-Type: text/plain; charset=\"UTF-8\"\r\n")
		message.WriteString("\r\n")
		message.WriteString(payload.TextBody)
		message.WriteString("\r\n")
	}

	if payload.HTMLBody != "" {
		message.WriteString(fmt.Sprintf("--%s\r\n", boundary))
		message.WriteString("Content-Type: text/html; charset=\"UTF-8\"\r\n")
		message.WriteString("\r\n")
		message.WriteString(payload.HTMLBody)
		message.WriteString("\r\n")
	}

	message.WriteString(fmt.Sprintf("--%s--\r\n", boundary))

	recipients := []string{payload.To}
	recipients = append(recipients, payload.Cc...)
	recipients = append(recipients, payload.Bcc...)

	return smtp.SendMail(
		addr,
		nil,
		payload.From,
		recipients,
		[]byte(message.String()),
	)
}

func (m *MailHog) SendMarketing(ctx context.Context, payload email.MarketingPayload) error {
	return fmt.Errorf("MailHog does not support marketing emails")
}


=== cmd/app/main.go ===
package main

import (
	"context"
	"fmt"
	"log/slog"
	"net"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"time"

	"myorg/webapp/clients/email"
	"myorg/webapp/config"
	"myorg/webapp/controllers"
	"myorg/webapp/database"
	"myorg/webapp/email"
	"myorg/webapp/pkg/telemetry"
	"myorg/webapp/queue"
	"myorg/webapp/queue/workers"
	"myorg/webapp/router"
	"riverqueue.com/riverui"

	"github.com/labstack/echo/v4"
	"golang.org/x/sync/errgroup"
)

var appVersion string

func startServer(ctx context.Context, srv *http.Server, processor queue.Processor, env string) error {
	if env == config.ProdEnvironment {
		eg, egCtx := errgroup.WithContext(ctx)

		eg.Go(func() error {
			if err := srv.ListenAndServe(); err != nil &&
				err != http.ErrServerClosed {
				return fmt.Errorf("server error: %w", err)
			}
			return nil
		})

		eg.Go(func() error {
			<-egCtx.Done()
			slog.InfoContext(ctx, "initiating graceful shutdown")
			shutdownCtx, cancel := context.WithTimeout(
				ctx,
				10*time.Second,
			)
			defer cancel()
			slog.InfoContext(ctx, "shutting down processor")
			if err := processor.Stop(shutdownCtx); err != nil {
				return fmt.Errorf("processor shutdown error: %w", err)
			}
			if err := srv.Shutdown(shutdownCtx); err != nil {
				return fmt.Errorf("shutdown error: %w", err)
			}
			return nil
		})

		if err := eg.Wait(); err != nil {
			slog.InfoContext(ctx, "wait error", "e", err)
			return err
		}

		return nil
	}

	return srv.ListenAndServe()
}

func setupControllers(
	db database.Postgres,
	emailClient email.Client,
	insertOnly queue.InsertOnly,
) (controllers.Controllers, error) {
	ctrl, err := controllers.New(
		db,
		emailClient,
		insertOnly,
	)
	if err != nil {
		return controllers.Controllers{}, err
	}

	return ctrl, nil
}

func setupRouter(
	ctx context.Context,
	ctrl controllers.Controllers,
	cfg config.Config,
	tel *telemetry.Telemetry,
	riverHandler *riverui.Handler,
) (*echo.Echo, error) {
	router, err := router.New(
		ctx,
		ctrl,
		cfg,
		tel,
		riverHandler,
	)
	if err != nil {
		return nil, err
	}

	return router.SetupRoutes(), nil
}

func parseHeaders(headersStr string) map[string]string {
	headers := make(map[string]string)
	if headersStr == "" {
		return headers
	}

	pairs := strings.Split(headersStr, ",")
	for _, pair := range pairs {
		kv := strings.SplitN(pair, "=", 2)
		if len(kv) == 2 {
			headers[strings.TrimSpace(kv[0])] = strings.TrimSpace(kv[1])
		}
	}
	return headers
}

func buildTelemetry(ctx context.Context, cfg config.Config) (*telemetry.Telemetry, error) {
	opts := []telemetry.Option{
		telemetry.WithService(cfg.Telemetry.ServiceName, cfg.Telemetry.ServiceVersion),
		telemetry.WithBatchConfig(cfg.Telemetry.BatchSize, cfg.Telemetry.BatchTimeoutMs, 2048),
		telemetry.WithTraceSampleRate(cfg.Telemetry.TraceSampleRate),
	}

	opts = append(opts, telemetry.WithLogExporters(telemetry.NewStdoutExporter()))

	if cfg.Telemetry.OtlpMetricsEndpoint != "" {
		opts = append(opts, telemetry.WithMetricExporters(
			telemetry.NewOtlpMetricExporter(cfg.Telemetry.OtlpMetricsEndpoint, parseHeaders(cfg.Telemetry.OtlpHeaders))))
	}

	if cfg.Telemetry.OtlpTracesEndpoint != "" {
		opts = append(opts, telemetry.WithTraceExporters(
			telemetry.NewOtlpTraceExporter(cfg.Telemetry.OtlpTracesEndpoint, parseHeaders(cfg.Telemetry.OtlpHeaders))))
	} else {
		opts = append(opts, telemetry.WithTraceExporters(telemetry.NewNoopTraceExporter()))
	}

	return telemetry.New(ctx, opts...)
}

func run(ctx context.Context) error {
	ctx, cancel := signal.NotifyContext(ctx, os.Interrupt)
	defer cancel()

	cfg := config.NewConfig()

	tel, err := buildTelemetry(ctx, cfg)
	if err != nil {
		return fmt.Errorf("failed to initialize telemetry: %w", err)
	}
	defer func() {
		shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()
		if err := tel.Shutdown(shutdownCtx); err != nil {
			slog.Error("telemetry shutdown error", "error", err)
		}
	}()

	if err := tel.HealthCheck(ctx); err != nil {
		slog.Warn("telemetry health check failed", "error", err)
	}
	db, err := database.NewPostgres(ctx, cfg.DB.GetDatabaseURL())
	if err != nil {
		return err
	}
	emailClient := email.New(mailclients.NewMailHog(cfg.Email.MailHogHost, cfg.Email.MailHogPort))
	wrks, err := workers.Register(emailClient)
	if err != nil {
		return err
	}

	insertOnly, err := queue.NewInsertOnly(
		db.Conn(),
		wrks,
	)
	if err != nil {
		return err
	}

	processor, err := queue.NewProcessor(
		ctx,
		db.Conn(),
		wrks,
	)
	if err != nil {
		return err
	}

	controllers, err := setupControllers(
		db,
		emailClient,
		insertOnly,
	)
	if err != nil {
		return err
	}
	endpoints := riverui.NewEndpoints(processor.Client, nil)
	opts := &riverui.HandlerOpts{
		Endpoints: endpoints,
		Logger:    slog.Default(),
		Prefix:    "/riverui", // mount the UI and its APIs under /riverui or another path
	}
	riverHandler, err := riverui.NewHandler(opts)
	if err != nil {
		return err
	}

	riverHandler.Start(ctx)

	handler, err := setupRouter(ctx, controllers, cfg, tel, riverHandler)
	if err != nil {
		return err
	}
	go func() error {
		slog.InfoContext(ctx, "starting queue processor")
		if err := processor.Start(ctx); err != nil {
			slog.ErrorContext(ctx, "error stopping queue processor", "error", err)
			return err
		}

		return nil
	}()

	srv := &http.Server{
		Addr:         fmt.Sprintf("%v:%v", cfg.App.Host, cfg.App.Port),
		Handler:      handler,
		ReadTimeout:  1 * time.Second,
		WriteTimeout: 5 * time.Second,
		BaseContext:  func(_ net.Listener) context.Context { return ctx },
	}

	slog.InfoContext(ctx, "starting server", "host", cfg.App.Host, "port", cfg.App.Port)
	return startServer(ctx, srv, processor, config.Env)
}

func main() {
	ctx := context.Background()
	if err := run(ctx); err != nil {
		fmt.Fprintf(os.Stderr, "%s\n", err)
		os.Exit(1)
	}
}


=== cmd/console/main.go ===
package main

import (
	"context"
	"fmt"
	"os"
	"os/exec"

	"myorg/webapp/config"

	"github.com/joho/godotenv"
)

func main() {
	ctx, cancel := context.WithCancel(context.Background())
	defer func() {
		cancel()
	}()

	if err := godotenv.Load(); err != nil {
		fmt.Fprintf(os.Stderr, "Warning: could not load .env file: %v\n", err)
	}

	cfg := config.NewConfig()
	cmd := exec.CommandContext(ctx, "go", "tool", "usql", cfg.DB.GetDatabaseURL())
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		fmt.Fprintf(os.Stderr, "error running usql: %v\n", err)
		os.Exit(1)
	}
}


=== cmd/migration/main.go ===
package main

import (
	"errors"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"myorg/webapp/config"

	"github.com/joho/godotenv"
	"gopkg.in/yaml.v3"
)

const (
	sqlcConfigPath    = "database/sqlc.yaml"
	migrationsDir     = "database/migrations"
	cmdCreate         = "create"
	cmdFix            = "fix"
	cmdNew            = "new"
	cmdUp             = "up"
	cmdDown           = "down"
	cmdReset          = "reset"
	cmdDownTo         = "down-to"
	cmdUpTo           = "up-to"
	gooseDriverPg     = "postgres"
	gooseDriverSQLite = "sqlite3"
)

type sqlcConfig struct {
	SQL []struct {
		Engine string `yaml:"engine"`
	} `yaml:"sql"`
}

func main() {
	if err := execute(); err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
}

func execute() error {
	if err := godotenv.Load(); err != nil {
		fmt.Fprintf(os.Stderr, "warning: could not load .env file: %v\n", err)
	}

	if len(os.Args) < 2 {
		printUsage()
		return errors.New("missing migration command")
	}

	engine, err := detectEngine(sqlcConfigPath)
	if err != nil {
		return err
	}

	driver, err := gooseDriver(engine)
	if err != nil {
		return err
	}

	cfg := config.NewConfig()
	dsn := cfg.DB.GetDatabaseURL()

	command := os.Args[1]
	args := os.Args[2:]

	switch command {
	case cmdCreate:
		if len(args) == 0 {
			return errors.New("create requires a migration name")
		}
		name := sanitizeMigrationName(args)
		if name == "" {
			return errors.New("provided migration name results in an empty identifier")
		}
		return runGoose(driver, dsn, cmdCreate, name, "sql")
	case cmdFix:
		return runGoose(driver, dsn, cmdFix)
	case cmdNew:
		if len(args) == 0 {
			return errors.New("new requires a migration name")
		}
		name := sanitizeMigrationName(args)
		if name == "" {
			return errors.New("provided migration name results in an empty identifier")
		}
		if err := runGoose(driver, dsn, cmdCreate, name, "sql"); err != nil {
			return err
		}
		return runGoose(driver, dsn, cmdFix)
	case cmdUp:
		return runGoose(driver, dsn, cmdUp)
	case cmdDown:
		return runGoose(driver, dsn, cmdDown)
	case cmdReset:
		if err := runGoose(driver, dsn, cmdDownTo, "0"); err != nil {
			return err
		}
		return runGoose(driver, dsn, cmdUp)
	case cmdDownTo:
		if len(args) == 0 {
			return errors.New("down-to requires a target version")
		}
		return runGoose(driver, dsn, cmdDownTo, args[0])
	case cmdUpTo:
		if len(args) == 0 {
			return errors.New("up-to requires a target version")
		}
		return runGoose(driver, dsn, cmdUpTo, args[0])
	default:
		printUsage()
		return fmt.Errorf("unknown migration command: %s", command)
	}
}

func printUsage() {
	fmt.Fprintln(os.Stderr, "usage: migration <command> [args]")
	fmt.Fprintln(os.Stderr, "\nAvailable commands:")
	fmt.Fprintln(os.Stderr, "  new <name>   create a new SQL migration (auto-fixes numbering)")
	fmt.Fprintln(os.Stderr, "  up           apply all pending migrations")
	fmt.Fprintln(os.Stderr, "  down         roll back the most recent migration")
	fmt.Fprintln(os.Stderr, "  reset        roll back everything and re-apply all migrations")
	fmt.Fprintln(os.Stderr, "  up-to <ver>  apply migrations up to the specified version")
	fmt.Fprintln(os.Stderr, "  down-to <ver> roll back to the specified version")
	fmt.Fprintln(os.Stderr, "  fix          renumber migrations to fix gaps")
}

func sanitizeMigrationName(parts []string) string {
	joined := strings.Join(parts, "_")
	replaced := strings.Map(func(r rune) rune {
		switch {
		case r >= 'a' && r <= 'z':
			return r
		case r >= '0' && r <= '9':
			return r
		case r >= 'A' && r <= 'Z':
			return r + ('a' - 'A')
		case r == '-' || r == ' ':
			return '_'
		case r == '_':
			return r
		default:
			return -1
		}
	}, joined)

	return strings.Trim(replaced, "_")
}

func gooseDriver(engine string) (string, error) {
	switch engine {
	case "postgresql":
		return gooseDriverPg, nil
	case "sqlite", "sqlite3":
		return gooseDriverSQLite, nil
	default:
		return "", fmt.Errorf("unsupported database engine: %s", engine)
	}
}

func detectEngine(path string) (string, error) {
	contents, err := os.ReadFile(path)
	if err != nil {
		return "", fmt.Errorf("unable to read sqlc config: %w", err)
	}

	var cfg sqlcConfig
	if err := yaml.Unmarshal(contents, &cfg); err != nil {
		return "", fmt.Errorf("unable to parse sqlc config: %w", err)
	}

	if len(cfg.SQL) == 0 || cfg.SQL[0].Engine == "" {
		return "", errors.New("no engine defined in sqlc config")
	}

	return cfg.SQL[0].Engine, nil
}

func runGoose(driver, dsn string, action string, extra ...string) error {
	wd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("could not determine working directory: %w", err)
	}

	args := []string{"tool", "goose", "-dir", filepath.Join(wd, migrationsDir), driver, dsn, action}
	if len(extra) > 0 {
		args = append(args, extra...)
	}

	cmd := exec.Command("go", args...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Stdin = os.Stdin
	cmd.Dir = wd

	return cmd.Run()
}


=== cmd/run/main.go ===
package main

import (
	"context"
	"fmt"
	"log/slog"
	"os"
	"os/exec"
	"os/signal"
	"sync"
	"syscall"
	"time"

	"github.com/joho/godotenv"
)

var (
	runningProcesses []*exec.Cmd
	processMutex     sync.Mutex
)

func main() {
	ctx, cancel := context.WithCancel(context.Background())
	defer func() {
		cancel()
		cleanup()
	}()

	if err := godotenv.Load(); err != nil {
		fmt.Fprintf(os.Stderr, "Warning: could not load .env file: %v\n", err)
	}

	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

	var wg sync.WaitGroup
	errChan := make(chan error, 3)
	wg.Add(3)

	go func() {
		defer wg.Done()
		if err := runLiveServer(ctx); err != nil {
			errChan <- fmt.Errorf("live-server: %w", err)
		}
	}()

	go func() {
		defer wg.Done()
		if err := runLiveTempl(ctx); err != nil {
			errChan <- fmt.Errorf("live-templ: %w", err)
		}
	}()
	go func() {
		defer wg.Done()
		if err := runLiveTailwind(ctx); err != nil {
			errChan <- fmt.Errorf("live-tailwind: %w", err)
		}
	}()

	go func() {
		select {
		case sig := <-sigChan:
			fmt.Printf("\nReceived signal: %v\n", sig)
			cancel()
		case err := <-errChan:
			if err != nil {
				fmt.Fprintf(os.Stderr, "Error: %v\n", err)
				fmt.Fprintf(os.Stderr, "Shutting down all processes...\n")
				cancel()
			}
		}
	}()

	wg.Wait()
	close(errChan)

	hasErrors := false
	for err := range errChan {
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error: %v\n", err)
			hasErrors = true
		}
	}

	if hasErrors {
		os.Exit(1)
	}
}

func addProcess(cmd *exec.Cmd) {
	processMutex.Lock()
	defer processMutex.Unlock()
	runningProcesses = append(runningProcesses, cmd)
}

func cleanup() {
	fmt.Printf("\nCleaning up processes...\n")

	processMutex.Lock()
	processes := make([]*exec.Cmd, len(runningProcesses))
	copy(processes, runningProcesses)
	processMutex.Unlock()

	for _, cmd := range processes {
		if cmd != nil && cmd.Process != nil {
			cmd.Process.Kill()
		}
	}

	wd, err := os.Getwd()
	if err == nil {
		exec.Command("pkill", "-f", wd+"/tmp/bin/main").Run()
	}

	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}
	exec.Command("fuser", "-k", port+"/tcp").Run()

	time.Sleep(500 * time.Millisecond)
	fmt.Printf("Cleanup complete.\n")
}

func runLiveServer(ctx context.Context) error {
	cmd := exec.CommandContext(ctx, "go", "tool", "air",
		"-build.cmd", "go build -o tmp/bin/main cmd/app/main.go",
		"-build.bin", "tmp/bin/main",
		"-build.exclude_dir", "node_modules",
		"-build.include_ext", "go,css,js",
		"-build.stop_on_error", "false",
		"-misc.clean_on_exit", "true",
	)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Start(); err != nil {
		return err
	}

	addProcess(cmd)

	<-ctx.Done()
	if cmd.Process != nil {
		return cmd.Process.Kill()
	}
	return nil
}

func runLiveTempl(ctx context.Context) error {
	cmd := exec.CommandContext(ctx, "go", "tool", "templ", "generate", "--watch")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Start(); err != nil {
		return err
	}

	addProcess(cmd)

	<-ctx.Done()
	if cmd.Process != nil {
		return cmd.Process.Kill()
	}
	return nil
}
func runLiveTailwind(ctx context.Context) error {
	wd, err := os.Getwd()
	if err != nil {
		return err
	}

	cmd := exec.CommandContext(ctx, wd+"/bin/tailwindcli",
		"-i", "./css/base.css",
		"-o", "./assets/css/style.css",
		"--watch=always",
	)

	cmd.Dir = wd
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Start(); err != nil {
		slog.Info(
			"Tailwind CLI not found. Please install it using the 'andurel app tailwind' command.",
		)
		return err
	}

	addProcess(cmd)

	<-ctx.Done()
	if cmd.Process != nil {
		return cmd.Process.Kill()
	}
	return nil
}


=== config/app.go ===
package config

import "github.com/caarlos0/env/v10"

type app struct {
	Host                 string `env:"HOST" envDefault:"localhost"`
	Port                 string `env:"PORT" envDefault:"8080"`
	SessionKey           string `env:"SESSION_KEY"`
	SessionEncryptionKey string `env:"SESSION_ENCRYPTION_KEY"`
	TokenSigningKey      string `env:"TOKEN_SIGNING_KEY"`
}

func newAppConfig() app {
	appCfg := app{}

	if err := env.ParseWithOptions(&appCfg, env.Options{
		RequiredIfNoDef: true,
	}); err != nil {
		panic(err)
	}

	return appCfg
}


=== config/config.go ===
// Package config provides application-wide configuration settings.
package config

import (
	"fmt"
	"os"
	"strings"

	"github.com/gosimple/slug"
)

const (
	DevEnvironment  = "development"
	ProdEnvironment = "production"
	TestEnvironment = "testing"
)

// Global application settings that can be used throughout the codebase with defaults.
var (
	Env = func() string {
		if os.Getenv("ENVIRONMENT") != "" {
			return os.Getenv("ENVIRONMENT")
		}

		return DevEnvironment
	}()
	ProjectName = func() string {
		if os.Getenv("PROJECT_NAME") != "" {
			return os.Getenv("PROJECT_NAME")
		}

		return "andurel"
	}()
	ServiceName = func() string {
		if os.Getenv("TELEMETRY_SERVICE_NAME") != "" {
			return os.Getenv("TELEMETRY_SERVICE_NAME")
		}

		return slug.Make(ProjectName)
	}()
	Domain = func() string {
		if os.Getenv("DOMAIN") != "" {
			return os.Getenv("DOMAIN")
		}

		return "localhost:8080"
	}()
	BaseURL = func() string {
		var protocol string

		if os.Getenv("PROTOCOL") != "" {
			protocol = os.Getenv("PROTOCOL")
		} else {
			protocol = "http"
		}

		return fmt.Sprintf("%s://%s", protocol, Domain)
	}()
	AuthenticatedSessionName = func() string {
		return "ua-" + strings.ToLower(ProjectName) + "-" + Env
	}()
)

type Config struct {
	App       app
	DB        database
	Telemetry telemetry
	Email     email
}

func NewConfig() Config {
	return Config{
		App:       newAppConfig(),
		DB:        newDatabaseConfig(),
		Telemetry: newTelemetryConfig(),
		Email:     newEmailConfig(),
	}
}


=== config/database.go ===
package config

import (
	"fmt"

	"github.com/caarlos0/env/v10"
)

type database struct {
	Port         string `env:"DB_PORT"`
	Host         string `env:"DB_HOST"`
	Name         string `env:"DB_NAME"`
	User         string `env:"DB_USER"`
	Password     string `env:"DB_PASSWORD"`
	DatabaseKind string `env:"DB_KIND"`
	SslMode      string `env:"DB_SSL_MODE"`
}

func (d database) GetDatabaseURL() string {
	return fmt.Sprintf("%s://%s:%s@%s:%s/%s?sslmode=%s",
		d.DatabaseKind, d.User, d.Password, d.Host, d.Port,
		d.Name, d.SslMode,
	)
}

func newDatabaseConfig() database {
	dataCfg := database{}

	if err := env.ParseWithOptions(&dataCfg, env.Options{
		RequiredIfNoDef: true,
	}); err != nil {
		panic(err)
	}

	return dataCfg
}


=== config/email.go ===
package config

import (
	"github.com/caarlos0/env/v10"
)

type email struct {
	MailHogHost string `env:"MAIL_HOG_HOST" envDefault:"0.0.0.0"`
	MailHogPort string `env:"MAIL_HOG_PORT" envDefault:"1025"`
}

func newEmailConfig() email {
	cfg := email{}

	if err := env.ParseWithOptions(&cfg, env.Options{
		RequiredIfNoDef: true,
	}); err != nil {
		panic(err)
	}

	return cfg
}


=== config/telemetry.go ===
package config

import "github.com/caarlos0/env/v10"

type telemetry struct {
	ServiceName         string  `env:"TELEMETRY_SERVICE_NAME" envDefault:"webapp"`
	ServiceVersion      string  `env:"TELEMETRY_SERVICE_VERSION" envDefault:"1.0.0"`
	OtlpLogsEndpoint    string  `env:"OTLP_LOGS_ENDPOINT" envDefault:""`
	OtlpMetricsEndpoint string  `env:"OTLP_METRICS_ENDPOINT" envDefault:""`
	OtlpTracesEndpoint  string  `env:"OTLP_TRACES_ENDPOINT" envDefault:""`
	OtlpHeaders         string  `env:"OTLP_HEADERS" envDefault:""`
	TraceSampleRate     float64 `env:"TRACE_SAMPLE_RATE" envDefault:"1.0"`
	BatchSize           int     `env:"TELEMETRY_BATCH_SIZE" envDefault:"512"`
	BatchTimeoutMs      int     `env:"TELEMETRY_BATCH_TIMEOUT_MS" envDefault:"5000"`
}

func newTelemetryConfig() telemetry {
	telemetryCfg := telemetry{}

	if err := env.ParseWithOptions(&telemetryCfg, env.Options{
		RequiredIfNoDef: true,
	}); err != nil {
		panic(err)
	}

	return telemetryCfg
}


=== controllers/api.go ===
package controllers

import (
	"myorg/webapp/database"
	"net/http"

	"github.com/labstack/echo/v4"
)

type API struct {
	db database.Postgres
}

func newAPI(db database.Postgres) API {
	return API{db}
}

func (a API) Health(ctx echo.Context) error {
	return ctx.JSON(http.StatusOK, "app is healthy and running")
}


=== controllers/assets.go ===
package controllers

import (
	"crypto/md5"
	"encoding/xml"
	"fmt"
	"log/slog"
	"net/http"

	"myorg/webapp/assets"
	"myorg/webapp/config"
	"myorg/webapp/router/routes"

	"github.com/labstack/echo/v4"
	"gopkg.in/yaml.v2"
)

const threeMonthsCache = "7776000"

type Assets struct {
	cache *Cache[string]
}

func newAssets(cache *Cache[string]) Assets {
	return Assets{cache}
}

func (a Assets) enableCaching(c echo.Context, content []byte) echo.Context {
	if config.Env == config.ProdEnvironment {
		//nolint:gosec //only needed for browser caching
		hash := md5.Sum(content)
		etag := fmt.Sprintf(`"%x-%x"`, hash, len(content))

		if match := c.Request().Header.Get("If-None-Match"); match == etag {
			c.Response().
				Header().
				Set("Cache-Control", fmt.Sprintf("public, max-age=%s, immutable", threeMonthsCache))
			c.Response().
				Header().
				Set("ETag", etag)
			c.NoContent(http.StatusNotModified)
			return c
		}

		c.Response().
			Header().
			Set("Cache-Control", fmt.Sprintf("public, max-age=%s, immutable", threeMonthsCache))
		c.Response().
			Header().
			Set("Vary", "Accept-Encoding")
		c.Response().
			Header().
			Set("ETag", etag)
	}

	return c
}

func createRobotsTxt() (string, error) {
	type robotsTxt struct {
		UserAgent string `yaml:"User-agent"`
		Allow     string `yaml:"Allow"`
		Sitemap   string `yaml:"Sitemap"`
	}

	robots, err := yaml.Marshal(robotsTxt{
		UserAgent: "*",
		Allow:     "/",
		Sitemap: fmt.Sprintf(
			"%s%s",
			config.BaseURL,
			routes.Sitemap.URL(),
		),
	})
	if err != nil {
		return "", err
	}

	return string(robots), nil
}

func (a Assets) Robots(c echo.Context) error {
	cacheKey := "assets:robots"

	robotsTxt, err := a.cache.Get(cacheKey, func() (string, error) {
		return createRobotsTxt()
	})
	if err != nil {
		slog.ErrorContext(
			c.Request().Context(),
			"failed to get robots.txt from cache",
			"error", err,
		)
		result, _ := createRobotsTxt()
		return c.String(http.StatusOK, result)
	}

	return c.String(http.StatusOK, robotsTxt)
}

func (a Assets) Sitemap(c echo.Context) error {
	cacheKey := "assets:sitemap"

	sitemap, err := a.cache.Get(cacheKey, func() (string, error) {
		return createSitemap()
	})
	if err != nil {
		slog.ErrorContext(
			c.Request().Context(),
			"failed to get sitemap from cache",
			"error", err,
		)

		result, err := createSitemap()
		if err != nil {
			return err
		}

		return c.Blob(http.StatusOK, "application/xml", []byte(result))
	}

	return c.Blob(http.StatusOK, "application/xml", []byte(sitemap))
}

type URL struct {
	XMLName    xml.Name `xml:"url"`
	Loc        string   `xml:"loc"`
	ChangeFreq string   `xml:"changefreq"`
	LastMod    string   `xml:"lastmod,omitempty"`
	Priority   string   `xml:"priority,omitempty"`
}

type Sitemap struct {
	XMLName xml.Name `xml:"urlset"`
	XMLNS   string   `xml:"xmlns,attr"`
	URL     []URL    `xml:"url"`
}

func createSitemap() (string, error) {
	baseURL := config.BaseURL

	var urls []URL

	urls = append(urls, URL{
		Loc:        baseURL,
		ChangeFreq: "monthly",
		LastMod:    "2024-10-22T09:43:09+00:00",
		Priority:   "1",
	})

	for _, r := range routes.Registry {
		if r.Method == http.MethodGet && r.IncludeInSitemap {
			urls = append(urls, URL{
				Loc: fmt.Sprintf(
					"%s%s",
					baseURL,
					r.Path,
				),
				ChangeFreq: "monthly",
			})
		}
	}

	sitemap := Sitemap{
		XMLNS: "http://www.sitemaps.org/schemas/sitemap/0.9",
		URL:   urls,
	}

	xmlBytes, err := xml.MarshalIndent(sitemap, "", "  ")
	if err != nil {
		return "", err
	}

	return xml.Header + string(xmlBytes), nil
}

func (a Assets) Stylesheet(c echo.Context) error {
	stylesheet, err := assets.Files.ReadFile(
		"css/style.css",
	)
	if err != nil {
		return err
	}

	c = a.enableCaching(c, stylesheet)
	return c.Blob(http.StatusOK, "text/css", stylesheet)
}

func (a Assets) Scripts(c echo.Context) error {
	stylesheet, err := assets.Files.ReadFile(
		"js/scripts.js",
	)
	if err != nil {
		return err
	}

	c = a.enableCaching(c, stylesheet)
	return c.Blob(http.StatusOK, "application/javascript", stylesheet)
}

func (a Assets) Script(c echo.Context) error {
	param := c.Param("file")
	stylesheet, err := assets.Files.ReadFile(
		fmt.Sprintf("js/%s", param),
	)
	if err != nil {
		return err
	}

	c = a.enableCaching(c, stylesheet)
	return c.Blob(http.StatusOK, "application/javascript", stylesheet)
}


=== controllers/cache.go ===
package controllers

import (
	"context"
	"time"

	"github.com/maypok86/otter/v2"
)

const (
	defaultCacheSize = 50
	defaultTTL       = 15 * time.Minute
)

type Cache[T any] struct {
	cache      *otter.Cache[string, T]
	defaultTTL time.Duration
}

type CacheBuilder[T any] struct {
	size       int
	defaultTTL time.Duration
}

func NewCacheBuilder[T any]() *CacheBuilder[T] {
	return &CacheBuilder[T]{
		size:       defaultCacheSize,
		defaultTTL: defaultTTL,
	}
}

func (b *CacheBuilder[T]) WithSize(size int) *CacheBuilder[T] {
	b.size = size
	return b
}

func (b *CacheBuilder[T]) WithDefaultTTL(ttl time.Duration) *CacheBuilder[T] {
	b.defaultTTL = ttl
	return b
}

func (b *CacheBuilder[T]) Build() (*Cache[T], error) {
	cache := otter.Must(&otter.Options[string, T]{
		MaximumSize: b.size,
	})

	return &Cache[T]{
		cache:      cache,
		defaultTTL: b.defaultTTL,
	}, nil
}

func (c *Cache[T]) Get(key string, loader func() (T, error)) (T, error) {
	if value, ok := c.cache.GetIfPresent(key); ok {
		return value, nil
	}

	result, err := loader()
	if err != nil {
		var zero T
		return zero, err
	}

	c.cache.Set(key, result)
	c.cache.SetExpiresAfter(key, c.defaultTTL)
	return result, nil
}

func (c *Cache[T]) GetIfPresent(ctx context.Context, key string) (T, bool) {
	return c.cache.GetIfPresent(key)
}

func (c *Cache[T]) Set(key string, value T, ttl time.Duration) {
	c.cache.Set(key, value)
	c.cache.SetExpiresAfter(key, ttl)
}

func (c *Cache[T]) SetDefault(key string, value T) {
	c.cache.Set(key, value)
	c.cache.SetExpiresAfter(key, c.defaultTTL)
}

func (c *Cache[T]) Invalidate(key string) {
	c.cache.Invalidate(key)
}


=== controllers/controller.go ===
// Package controllers provides HTTP handlers for the web application.
package controllers

import (
	"context"
	"net/http"

	"myorg/webapp/database"
	"myorg/webapp/router/cookies"

	"github.com/a-h/templ"
	"github.com/labstack/echo/v4"
	"myorg/webapp/email"
	"myorg/webapp/queue"
)

type Controllers struct {
	Assets Assets
	API    API
	Pages  Pages
}

func New(
	db database.Postgres,
	emailClient email.Client,
	insertOnly queue.InsertOnly,
) (Controllers, error) {
	pagesCache, err := NewCacheBuilder[templ.Component]().Build()
	if err != nil {
		return Controllers{}, err
	}

	assetsCache, err := NewCacheBuilder[string]().WithSize(2).Build()
	if err != nil {
		return Controllers{}, err
	}
	assets := newAssets(assetsCache)
	api := newAPI(db)
	pages := newPages(db, insertOnly, pagesCache)

	return Controllers{
		assets,
		api,
		pages,
	}, nil
}

func render(ctx echo.Context, t templ.Component) error {
	buf := templ.GetBuffer()
	defer templ.ReleaseBuffer(buf)

	appCtx := ctx.Get(string(cookies.AppKey))
	withAppCtx := context.WithValue(
		ctx.Request().Context(),
		cookies.AppKey,
		appCtx,
	)

	flashCtx := ctx.Get(string(cookies.FlashKey))
	withFlashCtx := context.WithValue(
		withAppCtx,
		cookies.FlashKey,
		flashCtx,
	)

	if err := t.Render(withFlashCtx, buf); err != nil {
		return err
	}

	return ctx.HTML(http.StatusOK, buf.String())
}


=== controllers/pages.go ===
package controllers

import (
	"myorg/webapp/database"
	"myorg/webapp/queue"
	"myorg/webapp/views"

	"github.com/a-h/templ"
	"github.com/labstack/echo/v4"
)

type Pages struct {
	db         database.Postgres
	insertOnly queue.InsertOnly
	cache      *Cache[templ.Component]
}

func newPages(
	db database.Postgres,
	insertOnly queue.InsertOnly,
	cache *Cache[templ.Component],
) Pages {
	return Pages{db, insertOnly, cache}
}

func (p Pages) Home(c echo.Context) error {
	cacheKey := "home"

	component, err := p.cache.Get(cacheKey, func() (templ.Component, error) {
		return views.Home(), nil
	})
	if err != nil {
		return err
	}

	return render(c, component)
}

func (p Pages) NotFound(c echo.Context) error {
	cacheKey := "not_found"

	component, err := p.cache.Get(cacheKey, func() (templ.Component, error) {
		return views.NotFound(), nil
	})
	if err != nil {
		return err
	}

	return render(c, component)
}


=== css/base.css ===
@import "tailwindcss";
@plugin "@tailwindcss/typography";
@plugin "@tailwindcss/forms";

body {
	font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
	-webkit-font-smoothing: antialiased;
	-moz-osx-font-smoothing: grayscale;
	font-style: normal;
	font-weight: 400;
	letter-spacing: -0.0125em;
	line-height: 1.5;
	-webkit-tap-highlight-color: rgba(0, 0, 0, 0);
	text-rendering: optimizeLegibility;
}

@import "./theme.css";

@source "./views";


=== css/theme.css ===
@theme {
	--color-base-100: oklch(28.822% 0.022 277.508);
	--color-base-200: oklch(26.805% 0.02 277.508);
	--color-base-300: oklch(24.787% 0.019 277.508);
	--color-base-content: oklch(97.747% 0.007 106.545);
	--color-primary: oklch(75.461% 0.183 346.812);
	--color-primary-content: oklch(15.092% 0.036 346.812);
	--color-secondary: oklch(74.202% 0.148 301.883);
	--color-secondary-content: oklch(14.84% 0.029 301.883);
	--color-accent: oklch(83.392% 0.124 66.558);
	--color-accent-content: oklch(16.678% 0.024 66.558);
	--color-neutral: oklch(39.445% 0.032 275.524);
	--color-neutral-content: oklch(87.889% 0.006 275.524);
	--color-info: oklch(88.263% 0.093 212.846);
	--color-info-content: oklch(17.652% 0.018 212.846);
	--color-success: oklch(87.099% 0.219 148.024);
	--color-success-content: oklch(17.419% 0.043 148.024);
	--color-warning: oklch(95.533% 0.134 112.757);
	--color-warning-content: oklch(19.106% 0.026 112.757);
	--color-error: oklch(68.22% 0.206 24.43);
	--color-error-content: oklch(13.644% 0.041 24.43);
	--radius-selector: 1rem;
	--radius-field: 0.5rem;
	--radius-box: 1rem;
	--size-selector: 0.25rem;
	--size-field: 0.25rem;
	--border: 1px;
	--depth: 0;
	--noise: 0;
}


=== database/database.go ===
// Package database provides database connection and transaction management.
package database

import (
	"context"
	"embed"
	"errors"
	"log/slog"

	"github.com/exaring/otelpgx"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
)

var (
	ErrBeginTx    = errors.New("could not begin transaction")
	ErrRollbackTx = errors.New("could not rollback transaction")
	ErrCommitTx   = errors.New("could not commit transaction")
)

//go:embed migrations/*
var Migrations embed.FS

type Postgres struct {
	pool *pgxpool.Pool
}

func NewPostgres(ctx context.Context, databaseURL string) (Postgres, error) {
	pgxCfg, err := pgxpool.ParseConfig(databaseURL)
	if err != nil {
		slog.ErrorContext(ctx, "could not parse database connection string", "error", err)
		return Postgres{}, err
	}

	pgxCfg.ConnConfig.Tracer = otelpgx.NewTracer()

	pool, err := pgxpool.NewWithConfig(ctx, pgxCfg)
	if err != nil {
		slog.ErrorContext(ctx, "could not establish connection to database", "error", err)
		return Postgres{}, err
	}

	if err := pool.Ping(ctx); err != nil {
		slog.ErrorContext(ctx, "could not ping database", "error", err)
		return Postgres{}, err
	}

	return Postgres{pool}, nil
}

func (p *Postgres) Conn() *pgxpool.Pool {
	return p.pool
}

func (p *Postgres) BeginTx(ctx context.Context) (pgx.Tx, error) {
	tx, err := p.pool.Begin(ctx)
	if err != nil {
		slog.ErrorContext(ctx, "could not begin transaction", "reason", err)
		return nil, errors.Join(ErrBeginTx, err)
	}

	return tx, nil
}

func (p *Postgres) RollBackTx(ctx context.Context, tx pgx.Tx) error {
	if err := tx.Rollback(ctx); err != nil {
		slog.ErrorContext(ctx, "could not rollback transaction", "reason", err)
		return errors.Join(ErrRollbackTx, err)
	}

	return nil
}

func (p *Postgres) CommitTx(ctx context.Context, tx pgx.Tx) error {
	if err := tx.Commit(ctx); err != nil {
		slog.ErrorContext(ctx, "could not commit transaction", "reason", err)
		return errors.Join(ErrCommitTx, err)
	}

	return nil
}


=== database/migrations/.gitkeep ===


=== database/migrations/00001_create_river_migration_table.sql ===
-- +goose Up
-- +goose StatementBegin
CREATE TABLE river_migration(
  id bigserial PRIMARY KEY,
  created_at timestamptz NOT NULL DEFAULT NOW(),
  version bigint NOT NULL,
  CONSTRAINT version CHECK (version >= 1)
);

CREATE UNIQUE INDEX ON river_migration USING btree(version);
-- +goose StatementEnd

-- +goose Down
-- +goose StatementBegin
DROP TABLE river_migration;
-- +goose StatementEnd


=== database/migrations/00002_create_river_job_and_leader_tables.sql ===
-- +goose Up
-- +goose StatementBegin
CREATE TYPE river_job_state AS ENUM(
  'available',
  'cancelled',
  'completed',
  'discarded',
  'retryable',
  'running',
  'scheduled'
);

CREATE TABLE river_job(
  -- 8 bytes
  id bigserial PRIMARY KEY,

  -- 8 bytes (4 bytes + 2 bytes + 2 bytes)
  --
  -- `state` is kept near the top of the table for operator convenience -- when
  -- looking at jobs with `SELECT *` it'll appear first after ID. The other two
  -- fields aren't as important but are kept adjacent to `state` for alignment
  -- to get an 8-byte block.
  state river_job_state NOT NULL DEFAULT 'available',
  attempt smallint NOT NULL DEFAULT 0,
  max_attempts smallint NOT NULL,

  -- 8 bytes each (no alignment needed)
  attempted_at timestamptz,
  created_at timestamptz NOT NULL DEFAULT NOW(),
  finalized_at timestamptz,
  scheduled_at timestamptz NOT NULL DEFAULT NOW(),

  -- 2 bytes (some wasted padding probably)
  priority smallint NOT NULL DEFAULT 1,

  -- types stored out-of-band
  args jsonb,
  attempted_by text[],
  errors jsonb[],
  kind text NOT NULL,
  metadata jsonb NOT NULL DEFAULT '{}',
  queue text NOT NULL DEFAULT 'default',
  tags varchar(255)[],

  CONSTRAINT finalized_or_finalized_at_null CHECK ((state IN ('cancelled', 'completed', 'discarded') AND finalized_at IS NOT NULL) OR finalized_at IS NULL),
  CONSTRAINT max_attempts_is_positive CHECK (max_attempts > 0),
  CONSTRAINT priority_in_range CHECK (priority >= 1 AND priority <= 4),
  CONSTRAINT queue_length CHECK (char_length(queue) > 0 AND char_length(queue) < 128),
  CONSTRAINT kind_length CHECK (char_length(kind) > 0 AND char_length(kind) < 128)
);

-- We may want to consider adding another property here after `kind` if it seems
-- like it'd be useful for something.
CREATE INDEX river_job_kind ON river_job USING btree(kind);

CREATE INDEX river_job_state_and_finalized_at_index ON river_job USING btree(state, finalized_at) WHERE finalized_at IS NOT NULL;

CREATE INDEX river_job_prioritized_fetching_index ON river_job USING btree(state, queue, priority, scheduled_at, id);

CREATE INDEX river_job_args_index ON river_job USING GIN(args);

CREATE INDEX river_job_metadata_index ON river_job USING GIN(metadata);

CREATE OR REPLACE FUNCTION river_job_notify()
  RETURNS TRIGGER
  AS $$
DECLARE
  payload json;
BEGIN
  IF NEW.state = 'available' THEN
    -- Notify will coalesce duplicate notifications within a transaction, so
    -- keep these payloads generalized:
    payload = json_build_object('queue', NEW.queue);
    PERFORM
      pg_notify('river_insert', payload::text);
  END IF;
  RETURN NULL;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER river_notify
  AFTER INSERT ON river_job
  FOR EACH ROW
  EXECUTE PROCEDURE river_job_notify();

CREATE UNLOGGED TABLE river_leader(
    -- 8 bytes each (no alignment needed)
    elected_at timestamptz NOT NULL,
    expires_at timestamptz NOT NULL,

    -- types stored out-of-band
    leader_id text NOT NULL,
    name text PRIMARY KEY,

    CONSTRAINT name_length CHECK (char_length(name) > 0 AND char_length(name) < 128),
    CONSTRAINT leader_id_length CHECK (char_length(leader_id) > 0 AND char_length(leader_id) < 128)
);
-- +goose StatementEnd

-- +goose Down
-- +goose StatementBegin
DROP TABLE river_job;
DROP FUNCTION river_job_notify;
DROP TYPE river_job_state;

DROP TABLE river_leader;
-- +goose StatementEnd


=== database/migrations/00003_alter_river_job_tags.sql ===
-- +goose Up
-- +goose StatementBegin
ALTER TABLE river_job ALTER COLUMN tags SET DEFAULT '{}';
UPDATE river_job SET tags = '{}' WHERE tags IS NULL;
ALTER TABLE river_job ALTER COLUMN tags SET NOT NULL;
-- +goose StatementEnd

-- +goose Down
-- +goose StatementBegin
ALTER TABLE river_job
    ALTER COLUMN tags DROP NOT NULL,
    ALTER COLUMN tags DROP DEFAULT;
-- +goose StatementEnd


=== database/migrations/00004_alter_river_job_args_metadata_add_queue.sql ===
-- +goose Up
-- +goose StatementBegin
-- The args column never had a NOT NULL constraint or default value at the
-- database level, though we tried to ensure one at the application level.
ALTER TABLE river_job ALTER COLUMN args SET DEFAULT '{}';
UPDATE river_job SET args = '{}' WHERE args IS NULL;
ALTER TABLE river_job ALTER COLUMN args SET NOT NULL;
ALTER TABLE river_job ALTER COLUMN args DROP DEFAULT;

-- The metadata column never had a NOT NULL constraint or default value at the
-- database level, though we tried to ensure one at the application level.
ALTER TABLE river_job ALTER COLUMN metadata SET DEFAULT '{}';
UPDATE river_job SET metadata = '{}' WHERE metadata IS NULL;
ALTER TABLE river_job ALTER COLUMN metadata SET NOT NULL;

-- The 'pending' job state will be used for upcoming functionality:
ALTER TYPE river_job_state ADD VALUE IF NOT EXISTS 'pending' AFTER 'discarded';

ALTER TABLE river_job DROP CONSTRAINT finalized_or_finalized_at_null;
ALTER TABLE river_job ADD CONSTRAINT finalized_or_finalized_at_null CHECK (
    (finalized_at IS NULL AND state NOT IN ('cancelled', 'completed', 'discarded')) OR
    (finalized_at IS NOT NULL AND state IN ('cancelled', 'completed', 'discarded'))
);

DROP TRIGGER river_notify ON river_job;
DROP FUNCTION river_job_notify;

--
-- Create table `river_queue`.
--

CREATE TABLE river_queue (
    name text PRIMARY KEY NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    metadata jsonb NOT NULL DEFAULT '{}' ::jsonb,
    paused_at timestamptz,
    updated_at timestamptz NOT NULL
);

--
-- Alter `river_leader` to add a default value of 'default` to `name`.
--

ALTER TABLE river_leader
    ALTER COLUMN name SET DEFAULT 'default',
    DROP CONSTRAINT name_length,
    ADD CONSTRAINT name_length CHECK (name = 'default');
-- +goose StatementEnd

-- +goose Down
-- +goose StatementBegin
ALTER TABLE river_job ALTER COLUMN args DROP NOT NULL;

ALTER TABLE river_job ALTER COLUMN metadata DROP NOT NULL;
ALTER TABLE river_job ALTER COLUMN metadata DROP DEFAULT;

-- It is not possible to safely remove 'pending' from the river_job_state enum,
-- so leave it in place.

ALTER TABLE river_job DROP CONSTRAINT finalized_or_finalized_at_null;
ALTER TABLE river_job ADD CONSTRAINT finalized_or_finalized_at_null CHECK (
  (state IN ('cancelled', 'completed', 'discarded') AND finalized_at IS NOT NULL) OR finalized_at IS NULL
);

CREATE OR REPLACE FUNCTION river_job_notify()
  RETURNS TRIGGER
  AS $$
DECLARE
  payload json;
BEGIN
  IF NEW.state = 'available' THEN
    -- Notify will coalesce duplicate notifications within a transaction, so
    -- keep these payloads generalized:
    payload = json_build_object('queue', NEW.queue);
    PERFORM
      pg_notify('river_insert', payload::text);
  END IF;
  RETURN NULL;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER river_notify
  AFTER INSERT ON river_job
  FOR EACH ROW
  EXECUTE PROCEDURE river_job_notify();

DROP TABLE river_queue;

ALTER TABLE river_leader
    ALTER COLUMN name DROP DEFAULT,
    DROP CONSTRAINT name_length,
    ADD CONSTRAINT name_length CHECK (char_length(name) > 0 AND char_length(name) < 128);
-- +goose StatementEnd


=== database/migrations/00005_add_river_job_unique_key_and_clients.sql ===
-- +goose Up
-- +goose StatementBegin
--
-- Rebuild the migration table so it's based on `(line, version)`.
--

DO
$body$
BEGIN
    -- Tolerate users who may be using their own migration system rather than
    -- River's. If they are, they will have skipped version 001 containing
    -- `CREATE TABLE river_migration`, so this table won't exist.
    IF (SELECT to_regclass('river_migration') IS NOT NULL) THEN
        ALTER TABLE river_migration
            RENAME TO river_migration_old;

        CREATE TABLE river_migration(
            line TEXT NOT NULL,
            version bigint NOT NULL,
            created_at timestamptz NOT NULL DEFAULT NOW(),
            CONSTRAINT line_length CHECK (char_length(line) > 0 AND char_length(line) < 128),
            CONSTRAINT version_gte_1 CHECK (version >= 1),
            PRIMARY KEY (line, version)
        );

        INSERT INTO river_migration
            (created_at, line, version)
        SELECT created_at, 'main', version
        FROM river_migration_old;

        DROP TABLE river_migration_old;
    END IF;
END;
$body$
LANGUAGE 'plpgsql';

--
-- Add `river_job.unique_key` and bring up an index on it.
--

-- These statements use `IF NOT EXISTS` to allow users with a `river_job` table
-- of non-trivial size to build the index `CONCURRENTLY` out of band of this
-- migration, then follow by completing the migration.
ALTER TABLE river_job
    ADD COLUMN IF NOT EXISTS unique_key bytea;

CREATE UNIQUE INDEX IF NOT EXISTS river_job_kind_unique_key_idx ON river_job (kind, unique_key) WHERE unique_key IS NOT NULL;

--
-- Create `river_client` and derivative.
--
-- This feature hasn't quite yet been implemented, but we're taking advantage of
-- the migration to add the schema early so that we can add it later without an
-- additional migration.
--

CREATE UNLOGGED TABLE river_client (
    id text PRIMARY KEY NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    metadata jsonb NOT NULL DEFAULT '{}',
    paused_at timestamptz,
    updated_at timestamptz NOT NULL,
    CONSTRAINT name_length CHECK (char_length(id) > 0 AND char_length(id) < 128)
);

-- Differs from `river_queue` in that it tracks the queue state for a particular
-- active client.
CREATE UNLOGGED TABLE river_client_queue (
    river_client_id text NOT NULL REFERENCES river_client (id) ON DELETE CASCADE,
    name text NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    max_workers bigint NOT NULL DEFAULT 0,
    metadata jsonb NOT NULL DEFAULT '{}',
    num_jobs_completed bigint NOT NULL DEFAULT 0,
    num_jobs_running bigint NOT NULL DEFAULT 0,
    updated_at timestamptz NOT NULL,
    PRIMARY KEY (river_client_id, name),
    CONSTRAINT name_length CHECK (char_length(name) > 0 AND char_length(name) < 128),
    CONSTRAINT num_jobs_completed_zero_or_positive CHECK (num_jobs_completed >= 0),
    CONSTRAINT num_jobs_running_zero_or_positive CHECK (num_jobs_running >= 0)
);
-- +goose StatementEnd

-- +goose Down
-- +goose StatementBegin
--
-- Revert to migration table based only on `(version)`.
--
-- If any non-main migrations are present, 005 is considered irreversible.
--

DO
$body$
BEGIN
    -- Tolerate users who may be using their own migration system rather than
    -- River's. If they are, they will have skipped version 001 containing
    -- `CREATE TABLE river_migration`, so this table won't exist.
    IF (SELECT to_regclass('river_migration') IS NOT NULL) THEN
        IF EXISTS (
            SELECT *
            FROM river_migration
            WHERE line <> 'main'
        ) THEN
            RAISE EXCEPTION 'Found non-main migration lines in the database; version 005 migration is irreversible because it would result in loss of migration information.';
        END IF;

        ALTER TABLE river_migration
            RENAME TO river_migration_old;

        CREATE TABLE river_migration(
            id bigserial PRIMARY KEY,
            created_at timestamptz NOT NULL DEFAULT NOW(),
            version bigint NOT NULL,
            CONSTRAINT version CHECK (version >= 1)
        );

        CREATE UNIQUE INDEX ON river_migration USING btree(version);

        INSERT INTO river_migration
            (created_at, version)
        SELECT created_at, version
        FROM river_migration_old;

        DROP TABLE river_migration_old;
    END IF;
END;
$body$
LANGUAGE 'plpgsql';

--
-- Drop `river_job.unique_key`.
--

ALTER TABLE river_job
    DROP COLUMN unique_key;

--
-- Drop `river_client` and derivative.
--

DROP TABLE river_client_queue;
DROP TABLE river_client;
-- +goose StatementEnd


=== database/migrations/00006_add_river_job_unique_states.sql ===
-- +goose Up
-- +goose StatementBegin
CREATE OR REPLACE FUNCTION river_job_state_in_bitmask(bitmask BIT(8), state river_job_state)
RETURNS boolean
LANGUAGE SQL
IMMUTABLE
AS $$
    SELECT CASE state
        WHEN 'available' THEN get_bit(bitmask, 7)
        WHEN 'cancelled' THEN get_bit(bitmask, 6)
        WHEN 'completed' THEN get_bit(bitmask, 5)
        WHEN 'discarded' THEN get_bit(bitmask, 4)
        WHEN 'pending'   THEN get_bit(bitmask, 3)
        WHEN 'retryable' THEN get_bit(bitmask, 2)
        WHEN 'running'   THEN get_bit(bitmask, 1)
        WHEN 'scheduled' THEN get_bit(bitmask, 0)
        ELSE 0
    END = 1;
$$;

--
-- Add `river_job.unique_states` and bring up an index on it.
--
-- This column may exist already if users manually created the column and index
-- as instructed in the changelog so the index could be created `CONCURRENTLY`.
--
ALTER TABLE river_job ADD COLUMN IF NOT EXISTS unique_states BIT(8);

-- This statement uses `IF NOT EXISTS` to allow users with a `river_job` table
-- of non-trivial size to build the index `CONCURRENTLY` out of band of this
-- migration, then follow by completing the migration.
CREATE UNIQUE INDEX IF NOT EXISTS river_job_unique_idx ON river_job (unique_key)
    WHERE unique_key IS NOT NULL
      AND unique_states IS NOT NULL
      AND river_job_state_in_bitmask(unique_states, state);

-- Remove the old unique index. Users who are actively using the unique jobs
-- feature and who wish to avoid deploy downtime may want od drop this in a
-- subsequent migration once all jobs using the old unique system have been
-- completed (i.e. no more rows with non-null unique_key and null
-- unique_states).
DROP INDEX river_job_kind_unique_key_idx;
-- +goose StatementEnd

-- +goose Down
-- +goose StatementBegin
--
-- Drop `river_job.unique_states` and its index.
--

DROP INDEX river_job_unique_idx;

ALTER TABLE river_job
    DROP COLUMN unique_states;

CREATE UNIQUE INDEX IF NOT EXISTS river_job_kind_unique_key_idx ON river_job (kind, unique_key) WHERE unique_key IS NOT NULL;

--
-- Drop `river_job_state_in_bitmask` function.
--
DROP FUNCTION river_job_state_in_bitmask;
-- +goose StatementEnd


=== database/queries/.gitkeep ===


=== database/sqlc.yaml ===
version: "2"
sql:
  - schema: migrations
    queries: queries
    engine: postgresql
    gen:
      go:
        package: db
        out: ../models/internal/db
        output_db_file_name: db.go
        output_models_file_name: entities.go
        emit_sql_as_comment: true
        emit_methods_with_db_argument: true
        sql_package: pgx/v5
        overrides:
          - db_type: uuid
            go_type: github.com/google/uuid.UUID


=== email/base_layout.templ ===
package email

templ baseLayout(title, preHeader, unsubscribeLink string) {
	<!DOCTYPE html>
	<html lang="en">
		<head>
			<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
			<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
			<title>{title}</title>
			<style media="all" type="text/css">
		/* -------------------------------------
    GLOBAL RESETS
------------------------------------- */

		body {
			font-family: Helvetica, sans-serif;
			-webkit-font-smoothing: antialiased;
			font-size: 16px;
			line-height: 1.3;
			-ms-text-size-adjust: 100%;
			-webkit-text-size-adjust: 100%;
		}

		table {
			border-collapse: separate;
			mso-table-lspace: 0pt;
			mso-table-rspace: 0pt;
			width: 100%;
		}

		table td {
			font-family: Helvetica, sans-serif;
			font-size: 16px;
			vertical-align: top;
		}

		/* -------------------------------------
    BODY & CONTAINER
------------------------------------- */

		body {
			background-color: #f4f5f6;
			margin: 0;
			padding: 0;
		}

		.body {
			background-color: #f4f5f6;
			width: 100%;
		}

		.container {
			margin: 0 auto !important;
			max-width: 600px;
			padding: 0;
			padding-top: 24px;
			width: 600px;
		}

		.content {
			box-sizing: border-box;
			display: block;
			margin: 0 auto;
			max-width: 600px;
			padding: 0;
		}

		/* -------------------------------------
    HEADER, FOOTER, MAIN
------------------------------------- */

		.main {
			background: #ffffff;
			border: 1px solid #eaebed;
			border-radius: 16px;
			width: 100%;
		}

		.wrapper {
			box-sizing: border-box;
			padding: 24px;
		}

		.footer {
			clear: both;
			padding-top: 24px;
			text-align: center;
			width: 100%;
		}

		.footer td,
		.footer p,
		.footer span,
		.footer a {
			color: #9a9ea6;
			font-size: 16px;
			text-align: center;
		}

		/* -------------------------------------
    TYPOGRAPHY
------------------------------------- */

		p {
			font-family: Helvetica, sans-serif;
			font-size: 16px;
			font-weight: normal;
			margin: 0;
			margin-bottom: 16px;
		}

		a {
			color: #0867ec;
			text-decoration: underline;
		}

		/* -------------------------------------
    BUTTONS
------------------------------------- */

		.btn {
			box-sizing: border-box;
			min-width: 100% !important;
			width: 100%;
		}

		.btn>tbody>tr>td {
			padding-bottom: 16px;
		}

		.btn table {
			width: auto;
		}

		.btn table td {
			background-color: #ffffff;
			border-radius: 4px;
			text-align: center;
		}

		.btn a {
			background-color: #ffffff;
			border: solid 2px #0867ec;
			border-radius: 4px;
			box-sizing: border-box;
			color: #0867ec;
			cursor: pointer;
			display: inline-block;
			font-size: 16px;
			font-weight: bold;
			margin: 0;
			padding: 12px 24px;
			text-decoration: none;
			text-transform: capitalize;
		}

		/* -------------------------------------
    OTHER STYLES THAT MIGHT BE USEFUL
------------------------------------- */

		.last {
			margin-bottom: 0;
		}

		.first {
			margin-top: 0;
		}

		.align-center {
			text-align: center;
		}

		.align-right {
			text-align: right;
		}

		.align-left {
			text-align: left;
		}

		.text-link {
			color: #0867ec !important;
			text-decoration: underline !important;
		}

		.clear {
			clear: both;
		}

		.mt0 {
			margin-top: 0;
		}

		.mb0 {
			margin-bottom: 0;
		}

		.preheader {
			color: transparent;
			display: none;
			height: 0;
			max-height: 0;
			max-width: 0;
			opacity: 0;
			overflow: hidden;
			mso-hide: all;
			visibility: hidden;
			width: 0;
		}

		.powered-by a {
			text-decoration: none;
		}

		/* -------------------------------------
    RESPONSIVE AND MOBILE FRIENDLY STYLES
------------------------------------- */

		@media only screen and (max-width: 640px) {

			.main p,
			.main td,
			.main span {
				font-size: 16px !important;
			}

			.wrapper {
				padding: 8px !important;
			}

			.content {
				padding: 0 !important;
			}

			.container {
				padding: 0 !important;
				padding-top: 8px !important;
				width: 100% !important;
			}

			.main {
				border-left-width: 0 !important;
				border-radius: 0 !important;
				border-right-width: 0 !important;
			}

			.btn table {
				max-width: 100% !important;
				width: 100% !important;
			}

			.btn a {
				font-size: 16px !important;
				max-width: 100% !important;
				width: 100% !important;
			}
		}

		/* -------------------------------------
    PRESERVE THESE STYLES IN THE HEAD
------------------------------------- */

		@media all {
			.ExternalClass {
				width: 100%;
			}

			.ExternalClass,
			.ExternalClass p,
			.ExternalClass span,
			.ExternalClass font,
			.ExternalClass td,
			.ExternalClass div {
				line-height: 100%;
			}

			.apple-link a {
				color: inherit !important;
				font-family: inherit !important;
				font-size: inherit !important;
				font-weight: inherit !important;
				line-height: inherit !important;
				text-decoration: none !important;
			}

			#MessageViewBody a {
				color: inherit;
				text-decoration: none;
				font-size: inherit;
				font-family: inherit;
				font-weight: inherit;
				line-height: inherit;
			}
		}
	</style>
		</head>
		<body>
			<table role="presentation" border="0" cellpadding="0" cellspacing="0" class="body">
				<tr>
					<td>&nbsp;</td>
					<td class="container">
						<div class="content">
							<!-- START CENTERED WHITE CONTAINER -->
							<span class="preheader">
								{preHeader}
							</span>
							<table role="presentation" border="0" cellpadding="0" cellspacing="0" class="main">
								<!-- START MAIN CONTENT AREA -->
								<tr>
									<td class="wrapper">
										{children...}
									</td>
								</tr>
								<!-- END MAIN CONTENT AREA -->
							</table>
							<!-- START FOOTER -->
							@footer(unsubscribeLink)
							<!-- END FOOTER -->
							<!-- END CENTERED WHITE CONTAINER -->
						</div>
					</td>
					<td>&nbsp;</td>
				</tr>
			</table>
		</body>
	</html>
}


=== email/base_layout_templ.go ===
// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.960
package email

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func baseLayout(title, preHeader, unsubscribeLink string) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<!doctype html><html lang=\"en\"><head><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><title>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var2 string
		templ_7745c5c3_Var2, templ_7745c5c3_Err = templ.JoinStringErrs(title)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `email/base_layout.templ`, Line: 9, Col: 16}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var2))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 2, "</title><style media=\"all\" type=\"text/css\">\n\t\t/* -------------------------------------\n    GLOBAL RESETS\n------------------------------------- */\n\n\t\tbody {\n\t\t\tfont-family: Helvetica, sans-serif;\n\t\t\t-webkit-font-smoothing: antialiased;\n\t\t\tfont-size: 16px;\n\t\t\tline-height: 1.3;\n\t\t\t-ms-text-size-adjust: 100%;\n\t\t\t-webkit-text-size-adjust: 100%;\n\t\t}\n\n\t\ttable {\n\t\t\tborder-collapse: separate;\n\t\t\tmso-table-lspace: 0pt;\n\t\t\tmso-table-rspace: 0pt;\n\t\t\twidth: 100%;\n\t\t}\n\n\t\ttable td {\n\t\t\tfont-family: Helvetica, sans-serif;\n\t\t\tfont-size: 16px;\n\t\t\tvertical-align: top;\n\t\t}\n\n\t\t/* -------------------------------------\n    BODY & CONTAINER\n------------------------------------- */\n\n\t\tbody {\n\t\t\tbackground-color: #f4f5f6;\n\t\t\tmargin: 0;\n\t\t\tpadding: 0;\n\t\t}\n\n\t\t.body {\n\t\t\tbackground-color: #f4f5f6;\n\t\t\twidth: 100%;\n\t\t}\n\n\t\t.container {\n\t\t\tmargin: 0 auto !important;\n\t\t\tmax-width: 600px;\n\t\t\tpadding: 0;\n\t\t\tpadding-top: 24px;\n\t\t\twidth: 600px;\n\t\t}\n\n\t\t.content {\n\t\t\tbox-sizing: border-box;\n\t\t\tdisplay: block;\n\t\t\tmargin: 0 auto;\n\t\t\tmax-width: 600px;\n\t\t\tpadding: 0;\n\t\t}\n\n\t\t/* -------------------------------------\n    HEADER, FOOTER, MAIN\n------------------------------------- */\n\n\t\t.main {\n\t\t\tbackground: #ffffff;\n\t\t\tborder: 1px solid #eaebed;\n\t\t\tborder-radius: 16px;\n\t\t\twidth: 100%;\n\t\t}\n\n\t\t.wrapper {\n\t\t\tbox-sizing: border-box;\n\t\t\tpadding: 24px;\n\t\t}\n\n\t\t.footer {\n\t\t\tclear: both;\n\t\t\tpadding-top: 24px;\n\t\t\ttext-align: center;\n\t\t\twidth: 100%;\n\t\t}\n\n\t\t.footer td,\n\t\t.footer p,\n\t\t.footer span,\n\t\t.footer a {\n\t\t\tcolor: #9a9ea6;\n\t\t\tfont-size: 16px;\n\t\t\ttext-align: center;\n\t\t}\n\n\t\t/* -------------------------------------\n    TYPOGRAPHY\n------------------------------------- */\n\n\t\tp {\n\t\t\tfont-family: Helvetica, sans-serif;\n\t\t\tfont-size: 16px;\n\t\t\tfont-weight: normal;\n\t\t\tmargin: 0;\n\t\t\tmargin-bottom: 16px;\n\t\t}\n\n\t\ta {\n\t\t\tcolor: #0867ec;\n\t\t\ttext-decoration: underline;\n\t\t}\n\n\t\t/* -------------------------------------\n    BUTTONS\n------------------------------------- */\n\n\t\t.btn {\n\t\t\tbox-sizing: border-box;\n\t\t\tmin-width: 100% !important;\n\t\t\twidth: 100%;\n\t\t}\n\n\t\t.btn>tbody>tr>td {\n\t\t\tpadding-bottom: 16px;\n\t\t}\n\n\t\t.btn table {\n\t\t\twidth: auto;\n\t\t}\n\n\t\t.btn table td {\n\t\t\tbackground-color: #ffffff;\n\t\t\tborder-radius: 4px;\n\t\t\ttext-align: center;\n\t\t}\n\n\t\t.btn a {\n\t\t\tbackground-color: #ffffff;\n\t\t\tborder: solid 2px #0867ec;\n\t\t\tborder-radius: 4px;\n\t\t\tbox-sizing: border-box;\n\t\t\tcolor: #0867ec;\n\t\t\tcursor: pointer;\n\t\t\tdisplay: inline-block;\n\t\t\tfont-size: 16px;\n\t\t\tfont-weight: bold;\n\t\t\tmargin: 0;\n\t\t\tpadding: 12px 24px;\n\t\t\ttext-decoration: none;\n\t\t\ttext-transform: capitalize;\n\t\t}\n\n\t\t/* -------------------------------------\n    OTHER STYLES THAT MIGHT BE USEFUL\n------------------------------------- */\n\n\t\t.last {\n\t\t\tmargin-bottom: 0;\n\t\t}\n\n\t\t.first {\n\t\t\tmargin-top: 0;\n\t\t}\n\n\t\t.align-center {\n\t\t\ttext-align: center;\n\t\t}\n\n\t\t.align-right {\n\t\t\ttext-align: right;\n\t\t}\n\n\t\t.align-left {\n\t\t\ttext-align: left;\n\t\t}\n\n\t\t.text-link {\n\t\t\tcolor: #0867ec !important;\n\t\t\ttext-decoration: underline !important;\n\t\t}\n\n\t\t.clear {\n\t\t\tclear: both;\n\t\t}\n\n\t\t.mt0 {\n\t\t\tmargin-top: 0;\n\t\t}\n\n\t\t.mb0 {\n\t\t\tmargin-bottom: 0;\n\t\t}\n\n\t\t.preheader {\n\t\t\tcolor: transparent;\n\t\t\tdisplay: none;\n\t\t\theight: 0;\n\t\t\tmax-height: 0;\n\t\t\tmax-width: 0;\n\t\t\topacity: 0;\n\t\t\toverflow: hidden;\n\t\t\tmso-hide: all;\n\t\t\tvisibility: hidden;\n\t\t\twidth: 0;\n\t\t}\n\n\t\t.powered-by a {\n\t\t\ttext-decoration: none;\n\t\t}\n\n\t\t/* -------------------------------------\n    RESPONSIVE AND MOBILE FRIENDLY STYLES\n------------------------------------- */\n\n\t\t@media only screen and (max-width: 640px) {\n\n\t\t\t.main p,\n\t\t\t.main td,\n\t\t\t.main span {\n\t\t\t\tfont-size: 16px !important;\n\t\t\t}\n\n\t\t\t.wrapper {\n\t\t\t\tpadding: 8px !important;\n\t\t\t}\n\n\t\t\t.content {\n\t\t\t\tpadding: 0 !important;\n\t\t\t}\n\n\t\t\t.container {\n\t\t\t\tpadding: 0 !important;\n\t\t\t\tpadding-top: 8px !important;\n\t\t\t\twidth: 100% !important;\n\t\t\t}\n\n\t\t\t.main {\n\t\t\t\tborder-left-width: 0 !important;\n\t\t\t\tborder-radius: 0 !important;\n\t\t\t\tborder-right-width: 0 !important;\n\t\t\t}\n\n\t\t\t.btn table {\n\t\t\t\tmax-width: 100% !important;\n\t\t\t\twidth: 100% !important;\n\t\t\t}\n\n\t\t\t.btn a {\n\t\t\t\tfont-size: 16px !important;\n\t\t\t\tmax-width: 100% !important;\n\t\t\t\twidth: 100% !important;\n\t\t\t}\n\t\t}\n\n\t\t/* -------------------------------------\n    PRESERVE THESE STYLES IN THE HEAD\n------------------------------------- */\n\n\t\t@media all {\n\t\t\t.ExternalClass {\n\t\t\t\twidth: 100%;\n\t\t\t}\n\n\t\t\t.ExternalClass,\n\t\t\t.ExternalClass p,\n\t\t\t.ExternalClass span,\n\t\t\t.ExternalClass font,\n\t\t\t.ExternalClass td,\n\t\t\t.ExternalClass div {\n\t\t\t\tline-height: 100%;\n\t\t\t}\n\n\t\t\t.apple-link a {\n\t\t\t\tcolor: inherit !important;\n\t\t\t\tfont-family: inherit !important;\n\t\t\t\tfont-size: inherit !important;\n\t\t\t\tfont-weight: inherit !important;\n\t\t\t\tline-height: inherit !important;\n\t\t\t\ttext-decoration: none !important;\n\t\t\t}\n\n\t\t\t#MessageViewBody a {\n\t\t\t\tcolor: inherit;\n\t\t\t\ttext-decoration: none;\n\t\t\t\tfont-size: inherit;\n\t\t\t\tfont-family: inherit;\n\t\t\t\tfont-weight: inherit;\n\t\t\t\tline-height: inherit;\n\t\t\t}\n\t\t}\n\t</style></head><body><table role=\"presentation\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"body\"><tr><td>&nbsp;</td><td class=\"container\"><div class=\"content\"><!-- START CENTERED WHITE CONTAINER --><span class=\"preheader\">")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var3 string
		templ_7745c5c3_Var3, templ_7745c5c3_Err = templ.JoinStringErrs(preHeader)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `email/base_layout.templ`, Line: 305, Col: 18}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var3))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 3, "</span><table role=\"presentation\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"main\"><!-- START MAIN CONTENT AREA --><tr><td class=\"wrapper\">")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templ_7745c5c3_Var1.Render(ctx, templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 4, "</td></tr><!-- END MAIN CONTENT AREA --></table><!-- START FOOTER -->")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = footer(unsubscribeLink).Render(ctx, templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 5, "<!-- END FOOTER --><!-- END CENTERED WHITE CONTAINER --></div></td><td>&nbsp;</td></tr></table></body></html>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate


=== email/components.templ ===
package email

templ button(link, callToAction string) {
	<style>
		.btn-primary table td {
			background-color: #0867ec;
		}

		.btn-primary a {
			background-color: #0867ec;
			border-color: #0867ec;
			color: #ffffff;
		}

		@media all {
			.btn-primary table td:hover {
				background-color: #ec0867 !important;
			}

			.btn-primary a:hover {
				background-color: #ec0867 !important;
				border-color: #ec0867 !important;
			}
		}
	</style>
	<table
		role="presentation"
		border="0"
		cellpadding="0"
		cellspacing="0"
		class="btn btn-primary"
	>
		<tbody>
			<tr>
				<td align="left">
					<table role="presentation" border="0" cellpadding="0" cellspacing="0">
						<tbody>
							<tr>
								<td>
									<a href={templ.SafeURL(link)} target="_blank">
										{callToAction}
									</a>
								</td>
							</tr>
						</tbody>
					</table>
				</td>
			</tr>
		</tbody>
	</table>
}

templ footer(unsubscribeLink string) {
	<div class="footer">
		<table role="presentation" border="0" cellpadding="0" cellspacing="0">
			<tr>
				<td class="content-block">
					<span class="apple-link">andurel @ mbvlabs</span>
					<br/>
					Don't like these emails? <a href={templ.SafeURL(unsubscribeLink)}>Unsubscribe</a>.
				</td>
			</tr>
			<tr>
				<td class="content-block powered-by">
					Powered by <a href="https://andurel.com">Andurel</a>
				</td>
			</tr>
		</table>
	</div>
}


=== email/components_templ.go ===
// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.960
package email

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func button(link, callToAction string) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<style>\n\t\t.btn-primary table td {\n\t\t\tbackground-color: #0867ec;\n\t\t}\n\n\t\t.btn-primary a {\n\t\t\tbackground-color: #0867ec;\n\t\t\tborder-color: #0867ec;\n\t\t\tcolor: #ffffff;\n\t\t}\n\n\t\t@media all {\n\t\t\t.btn-primary table td:hover {\n\t\t\t\tbackground-color: #ec0867 !important;\n\t\t\t}\n\n\t\t\t.btn-primary a:hover {\n\t\t\t\tbackground-color: #ec0867 !important;\n\t\t\t\tborder-color: #ec0867 !important;\n\t\t\t}\n\t\t}\n\t</style><table role=\"presentation\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"btn btn-primary\"><tbody><tr><td align=\"left\"><table role=\"presentation\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><a href=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var2 templ.SafeURL
		templ_7745c5c3_Var2, templ_7745c5c3_Err = templ.JoinURLErrs(templ.SafeURL(link))
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `email/components.templ`, Line: 40, Col: 37}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var2))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 2, "\" target=\"_blank\">")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var3 string
		templ_7745c5c3_Var3, templ_7745c5c3_Err = templ.JoinStringErrs(callToAction)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `email/components.templ`, Line: 41, Col: 23}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var3))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 3, "</a></td></tr></tbody></table></td></tr></tbody></table>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

func footer(unsubscribeLink string) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var4 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var4 == nil {
			templ_7745c5c3_Var4 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 4, "<div class=\"footer\"><table role=\"presentation\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr><td class=\"content-block\"><span class=\"apple-link\">andurel @ mbvlabs</span><br>Don't like these emails? <a href=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var5 templ.SafeURL
		templ_7745c5c3_Var5, templ_7745c5c3_Err = templ.JoinURLErrs(templ.SafeURL(unsubscribeLink))
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `email/components.templ`, Line: 60, Col: 69}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var5))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 5, "\">Unsubscribe</a>.</td></tr><tr><td class=\"content-block powered-by\">Powered by <a href=\"https://andurel.com\">Andurel</a></td></tr></table></div>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate


=== email/email.go ===
package email

import (
	"bytes"
	"context"
	"errors"

	"strings"

	"github.com/a-h/templ"
	"golang.org/x/net/html"
)

var (
	ErrUnsubscribeURLRequired = errors.New("marketing emails require unsubscribe URL")
	ErrMissingRecipient       = errors.New("missing recipient email address")
	ErrMissingSender          = errors.New("missing sender email address")
	ErrMissingSubject         = errors.New("missing email subject")
	ErrMissingComponent       = errors.New("missing email component")
)

type ValidationError struct {
	Err error
}

func (e ValidationError) Error() string {
	return e.Err.Error()
}

func (e ValidationError) Unwrap() error {
	return e.Err
}

type TemporaryError struct {
	Err error
}

func (e TemporaryError) Error() string {
	return e.Err.Error()
}

func (e TemporaryError) Unwrap() error {
	return e.Err
}

type PermanentError struct {
	Err error
}

func (e PermanentError) Error() string {
	return e.Err.Error()
}

func (e PermanentError) Unwrap() error {
	return e.Err
}

func IsValidationError(err error) bool {
	var validationErr ValidationError
	if errors.As(err, &validationErr) {
		return true
	}

	return errors.Is(err, ErrUnsubscribeURLRequired) ||
		errors.Is(err, ErrMissingRecipient) ||
		errors.Is(err, ErrMissingSender) ||
		errors.Is(err, ErrMissingSubject) ||
		errors.Is(err, ErrMissingComponent)
}

func IsRetryable(err error) bool {
	var tempErr TemporaryError
	if errors.As(err, &tempErr) {
		return true
	}

	var permErr PermanentError
	if errors.As(err, &permErr) {
		return false
	}

	if IsValidationError(err) {
		return false
	}

	return true
}

type TransactionalData struct {
	To          string
	Cc          []string
	Bcc         []string
	From        string
	ReplyTo     string
	Subject     string
	Component   templ.Component
	Attachments []Attachment
	Metadata    map[string]string
}

type MarketingData struct {
	To               []string
	From             string
	ReplyTo          string
	Subject          string
	Component        templ.Component
	UnsubscribeURL   string
	UnsubscribeGroup string
	Tags             []string
	Metadata         map[string]string
	TrackOpens       bool
	TrackClicks      bool
}

type Attachment struct {
	Name        string
	Content     []byte
	ContentType string
	Inline      bool
}

type TransactionalPayload struct {
	To          string
	Cc          []string
	Bcc         []string
	From        string
	ReplyTo     string
	Subject     string
	HTMLBody    string
	TextBody    string
	Attachments []Attachment
	Metadata    map[string]string
}

type MarketingPayload struct {
	To               []string
	From             string
	ReplyTo          string
	Subject          string
	HTMLBody         string
	TextBody         string
	UnsubscribeURL   string
	UnsubscribeGroup string
	Tags             []string
	Metadata         map[string]string
	TrackOpens       bool
	TrackClicks      bool
}

type Sender interface {
	SendTransactional(ctx context.Context, payload TransactionalPayload) error
	SendMarketing(ctx context.Context, payload MarketingPayload) error
}

type Client struct {
	sender Sender
}

func New(sender Sender) Client {
	return Client{
		sender: sender,
	}
}

func (c Client) SendTransactional(ctx context.Context, data TransactionalData) error {
	if data.To == "" && len(data.Cc) == 0 && len(data.Bcc) == 0 {
		return ValidationError{Err: ErrMissingRecipient}
	}

	if data.From == "" {
		return ValidationError{Err: ErrMissingSender}
	}

	if data.Subject == "" {
		return ValidationError{Err: ErrMissingSubject}
	}

	if data.Component == nil {
		return ValidationError{Err: ErrMissingComponent}
	}

	html, err := renderComponent(data.Component)
	if err != nil {
		return err
	}

	text, err := HTMLToText(html)
	if err != nil {
		return err
	}

	payload := TransactionalPayload{
		To:          data.To,
		Cc:          data.Cc,
		Bcc:         data.Bcc,
		From:        data.From,
		ReplyTo:     data.ReplyTo,
		Subject:     data.Subject,
		HTMLBody:    html,
		TextBody:    text,
		Attachments: data.Attachments,
		Metadata:    data.Metadata,
	}

	return c.sender.SendTransactional(ctx, payload)
}

func (c Client) SendMarketing(ctx context.Context, data MarketingData) error {
	if data.UnsubscribeURL == "" {
		return ErrUnsubscribeURLRequired
	}

	html, err := renderComponent(data.Component)
	if err != nil {
		return err
	}

	text, err := HTMLToText(html)
	if err != nil {
		return err
	}

	payload := MarketingPayload{
		To:               data.To,
		From:             data.From,
		ReplyTo:          data.ReplyTo,
		Subject:          data.Subject,
		HTMLBody:         html,
		TextBody:         text,
		UnsubscribeURL:   data.UnsubscribeURL,
		UnsubscribeGroup: data.UnsubscribeGroup,
		Tags:             data.Tags,
		Metadata:         data.Metadata,
		TrackOpens:       data.TrackOpens,
		TrackClicks:      data.TrackClicks,
	}

	return c.sender.SendMarketing(ctx, payload)
}

func renderComponent(component templ.Component) (string, error) {
	var buf bytes.Buffer
	if err := component.Render(context.Background(), &buf); err != nil {
		return "", err
	}
	return buf.String(), nil
}

func HTMLToText(htmlContent string) (string, error) {
	doc, err := html.Parse(strings.NewReader(htmlContent))
	if err != nil {
		return "", err
	}

	var result strings.Builder
	var extract func(*html.Node)

	extract = func(n *html.Node) {
		if n.Type == html.ElementNode {
			switch n.Data {
			case "style", "script", "head":
				return
			case "a":
				var linkText strings.Builder
				var extractLinkText func(*html.Node)
				extractLinkText = func(node *html.Node) {
					if node.Type == html.TextNode {
						linkText.WriteString(node.Data)
					}
					for child := node.FirstChild; child != nil; child = child.NextSibling {
						extractLinkText(child)
					}
				}
				extractLinkText(n)

				var href string
				for _, attr := range n.Attr {
					if attr.Key == "href" {
						href = attr.Val
						break
					}
				}

				text := strings.TrimSpace(linkText.String())
				if text != "" {
					result.WriteString(text)
				}

				if href != "" && href != text {
					result.WriteString(" (")
					result.WriteString(href)
					result.WriteString(")")
				}
				result.WriteString(" ")
				return
			}
		}

		if n.Type == html.TextNode {
			text := strings.TrimSpace(n.Data)
			if text != "" {
				result.WriteString(text)
				result.WriteString(" ")
			}
		}

		if n.Type == html.ElementNode {
			switch n.Data {
			case "p", "div", "br", "h1", "h2", "h3", "h4", "h5", "h6":
				result.WriteString("\n")
			case "tr", "li":
				result.WriteString("\n")
			}
		}

		for c := n.FirstChild; c != nil; c = c.NextSibling {
			extract(c)
		}

		if n.Type == html.ElementNode {
			switch n.Data {
			case "p", "div", "h1", "h2", "h3", "h4", "h5", "h6":
				result.WriteString("\n")
			}
		}
	}

	extract(doc)

	text := result.String()
	text = strings.TrimSpace(text)

	for strings.Contains(text, "\n\n\n") {
		text = strings.ReplaceAll(text, "\n\n\n", "\n\n")
	}

	return text, nil
}


=== models/errors.go ===
package models

import "errors"

var ErrDomainValidation = errors.New("the provided payload failed validations")


=== models/internal/db/db.go ===
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New() *Queries {
	return &Queries{}
}

type Queries struct {
}


=== models/model.go ===
// Package models contains data models and validation logic.
package models

import (
	"myorg/webapp/models/internal/db"

	"github.com/go-playground/validator/v10"
)

var (
	validate = setupValidator()
	queries  = db.New()
)

func setupValidator() *validator.Validate {
	v := validator.New(validator.WithRequiredStructEnabled())
	return v
}


=== pkg/telemetry/helpers.go ===
package telemetry

import (
	"context"

	"myorg/webapp/config"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
)

// StartSpan starts a new span with the given name using the global tracer.
func StartSpan(ctx context.Context, spanName string) (context.Context, trace.Span) {
	tracer := GetTracer(config.ServiceName)
	return tracer.Start(ctx, spanName)
}

// StartSpanAttrs starts a new span with the given name and attributes using the global tracer.
func StartSpanAttrs(ctx context.Context, spanName string, attrs ...attribute.KeyValue) (context.Context, trace.Span) {
	tracer := GetTracer(config.ServiceName)
	ctx, span := tracer.Start(ctx, spanName)
	span.SetAttributes(attrs...)
	return ctx, span
}

// RecErr records an error in the given span and sets its status to error.
func RecErr(span trace.Span, err error) {
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
	}
}

// AddEvent adds an event with the given name and attributes to the span.
func AddEvent(span trace.Span, name string, attrs ...attribute.KeyValue) {
	span.AddEvent(name, trace.WithAttributes(attrs...))
}


=== pkg/telemetry/log_exporters.go ===
package telemetry

import (
	"context"
	"log/slog"
	"os"

	"github.com/lmittmann/tint"
)

type StdoutExporter struct {
	LogLevel slog.Level
}

func NewStdoutExporter() *StdoutExporter {
	return &StdoutExporter{
		LogLevel: slog.LevelInfo,
	}
}

func NewStdoutExporterWithLevel(level slog.Level) *StdoutExporter {
	return &StdoutExporter{
		LogLevel: level,
	}
}

func (s *StdoutExporter) GetSlogHandler(ctx context.Context) (slog.Handler, error) {
	handler := tint.NewHandler(os.Stdout, &tint.Options{
		Level:      s.LogLevel,
		TimeFormat: "15:04:05",
		AddSource:  true,
	})

	return handler, nil
}

func (s *StdoutExporter) Name() string {
	return "stdout"
}

func (s *StdoutExporter) Shutdown(ctx context.Context) error {
	return nil
}

var _ LogExporter = (*StdoutExporter)(nil)


=== pkg/telemetry/logger.go ===
package telemetry

import (
	"context"
	"log/slog"

	"go.opentelemetry.io/otel/trace"
)

type LogExporter interface {
	Name() string
	GetSlogHandler(ctx context.Context) (slog.Handler, error)
	Shutdown(ctx context.Context) error
}

type traceLogHandler struct {
	handler slog.Handler
}

func (h *traceLogHandler) Enabled(ctx context.Context, level slog.Level) bool {
	return h.handler.Enabled(ctx, level)
}

func (h *traceLogHandler) Handle(ctx context.Context, record slog.Record) error {
	traceAttrs := traceAttrsFromContext(ctx)
	for _, attr := range traceAttrs {
		record.AddAttrs(attr)
	}

	return h.handler.Handle(ctx, record)
}

func (h *traceLogHandler) WithAttrs(attrs []slog.Attr) slog.Handler {
	return &traceLogHandler{
		handler: h.handler.WithAttrs(attrs),
	}
}

func (h *traceLogHandler) WithGroup(name string) slog.Handler {
	return &traceLogHandler{
		handler: h.handler.WithGroup(name),
	}
}

func traceAttrsFromContext(ctx context.Context) []slog.Attr {
	var attrs []slog.Attr

	spanCtx := trace.SpanContextFromContext(ctx)
	if spanCtx.IsValid() {
		attrs = append(attrs,
			slog.String("trace_id", spanCtx.TraceID().String()),
			slog.String("span_id", spanCtx.SpanID().String()),
		)
	}

	return attrs
}


=== pkg/telemetry/metric_exporters.go ===
package telemetry

import (
	"context"
	"crypto/tls"
	"fmt"
	"strings"

	"go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetrichttp"
	sdkmetric "go.opentelemetry.io/otel/sdk/metric"
	"go.opentelemetry.io/otel/sdk/metric/metricdata"
	"go.opentelemetry.io/otel/sdk/resource"
)

type OtlpHttpMetricExporter struct {
	endpoint string
	insecure bool
	headers  map[string]string
	exporter sdkmetric.Exporter
}

func NewOtlpMetricExporter(endpoint string, headers map[string]string) *OtlpHttpMetricExporter {
	if endpoint == "" {
		return nil
	}
	return &OtlpHttpMetricExporter{
		endpoint: endpoint,
		insecure: false,
		headers:  headers,
		exporter: nil,
	}
}

func NewOtlpMetricExporterInsecure(endpoint string, headers map[string]string) *OtlpHttpMetricExporter {
	if endpoint == "" {
		return nil
	}
	return &OtlpHttpMetricExporter{
		endpoint: endpoint,
		insecure: true,
		headers:  headers,
		exporter: nil,
	}
}

func (o *OtlpHttpMetricExporter) Name() string {
	return "otlp-http-metrics"
}

func (o *OtlpHttpMetricExporter) GetSdkMetricExporter(ctx context.Context, res *resource.Resource) (sdkmetric.Exporter, error) {
	endpoint := strings.TrimPrefix(o.endpoint, "http://")
	endpoint = strings.TrimPrefix(endpoint, "https://")

	opts := []otlpmetrichttp.Option{
		otlpmetrichttp.WithEndpoint(endpoint),
	}

	if o.insecure {
		opts = append(opts, otlpmetrichttp.WithInsecure())
	} else {
		opts = append(opts, otlpmetrichttp.WithTLSClientConfig(&tls.Config{
			MinVersion: tls.VersionTLS12,
		}))
	}

	if len(o.headers) > 0 {
		opts = append(opts, otlpmetrichttp.WithHeaders(o.headers))
	}

	exporter, err := otlpmetrichttp.New(ctx, opts...)
	if err != nil {
		return nil, fmt.Errorf("failed to create OTLP HTTP metric exporter: %w", err)
	}

	o.exporter = exporter
	return exporter, nil
}

func (o *OtlpHttpMetricExporter) Shutdown(ctx context.Context) error {
	if o.exporter != nil {
		if err := o.exporter.Shutdown(ctx); err != nil {
			return fmt.Errorf("failed to shutdown OTLP HTTP metric exporter: %w", err)
		}
	}
	return nil
}

var _ MetricExporter = (*OtlpHttpMetricExporter)(nil)

type noopSdkMetricExporter struct{}

func (n *noopSdkMetricExporter) Aggregation(sdkmetric.InstrumentKind) sdkmetric.Aggregation {
	return nil
}

func (n *noopSdkMetricExporter) Export(context.Context, *metricdata.ResourceMetrics) error {
	return nil
}

func (n *noopSdkMetricExporter) ForceFlush(context.Context) error {
	return nil
}

func (n *noopSdkMetricExporter) Shutdown(context.Context) error {
	return nil
}

func (n *noopSdkMetricExporter) Temporality(sdkmetric.InstrumentKind) metricdata.Temporality {
	return 0
}

var _ sdkmetric.Exporter = (*noopSdkMetricExporter)(nil)

type NoopMetricExporter struct{}

func NewNoopMetricExporter() *NoopMetricExporter {
	return &NoopMetricExporter{}
}

func (n *NoopMetricExporter) Name() string {
	return "noop-metrics"
}

func (n *NoopMetricExporter) GetSdkMetricExporter(ctx context.Context, res *resource.Resource) (sdkmetric.Exporter, error) {
	return &noopSdkMetricExporter{}, nil
}

func (n *NoopMetricExporter) Shutdown(ctx context.Context) error {
	return nil
}

var _ MetricExporter = (*NoopMetricExporter)(nil)


=== pkg/telemetry/metrics.go ===
package telemetry

import (
	"context"
	"fmt"
	"net/http"
	"runtime"
	"time"

	"myorg/webapp/config"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/metric"
	sdkmetric "go.opentelemetry.io/otel/sdk/metric"
	"go.opentelemetry.io/otel/sdk/resource"
)

type MetricExporter interface {
	Name() string
	GetSdkMetricExporter(ctx context.Context, res *resource.Resource) (sdkmetric.Exporter, error)
	Shutdown(ctx context.Context) error
}

func GetMeter(serviceName string) metric.Meter {
	return otel.Meter(serviceName)
}

func HTTPRequestsTotal() (metric.Int64Counter, error) {
	counter, err := GetMeter(config.ServiceName).Int64Counter(
		"http_requests_total",
		metric.WithDescription("Total number of HTTP requests"),
		metric.WithUnit("1"),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create http_requests_total counter: %w", err)
	}
	return counter, nil
}

func HTTPRequestsInFlight() (metric.Int64UpDownCounter, error) {
	counter, err := GetMeter(config.ServiceName).Int64UpDownCounter(
		"http_requests_in_flight",
		metric.WithDescription("Current number of HTTP requests being served"),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create http_requests_in_flight counter: %w", err)
	}
	return counter, nil
}

func HTTPRequestDuration() (metric.Float64Histogram, error) {
	histogram, err := GetMeter(config.ServiceName).Float64Histogram(
		"http_request_duration_seconds",
		metric.WithDescription("HTTP request duration in seconds"),
		metric.WithUnit("s"),
		metric.WithExplicitBucketBoundaries(0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create http_request_duration_seconds histogram: %w", err)
	}
	return histogram, nil
}

func HTTPRequestSize() (metric.Float64Histogram, error) {
	histogram, err := GetMeter(config.ServiceName).Float64Histogram(
		"http_request_size_bytes",
		metric.WithDescription("HTTP request size in bytes"),
		metric.WithUnit("By"),
		metric.WithExplicitBucketBoundaries(1024, 2048, 5120, 10240, 102400, 512000, 1048576, 2621440, 5242880, 10485760),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create http_request_size_bytes histogram: %w", err)
	}
	return histogram, nil
}

func HTTPResponseSize() (metric.Float64Histogram, error) {
	histogram, err := GetMeter(config.ServiceName).Float64Histogram(
		"http_response_size_bytes",
		metric.WithDescription("HTTP response size in bytes"),
		metric.WithUnit("By"),
		metric.WithExplicitBucketBoundaries(1024, 2048, 5120, 10240, 102400, 512000, 1048576, 2621440, 5242880, 10485760),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create http_response_size_bytes histogram: %w", err)
	}
	return histogram, nil
}

func SetupRuntimeMetricsInCallback(meter metric.Meter) error {
	_, err := meter.Int64ObservableGauge(
		"go_goroutines",
		metric.WithDescription("Number of goroutines that currently exist"),
		metric.WithInt64Callback(
			func(ctx context.Context, o metric.Int64Observer) error {
				o.Observe(int64(runtime.NumGoroutine()))
				return nil
			},
		),
	)
	if err != nil {
		return fmt.Errorf("failed to create go_goroutines gauge: %w", err)
	}

	_, err = meter.Int64ObservableGauge(
		"go_memstats_alloc_bytes",
		metric.WithDescription("Number of bytes allocated and still in use"),
		metric.WithUnit("bytes"),
		metric.WithInt64Callback(
			func(ctx context.Context, o metric.Int64Observer) error {
				var m runtime.MemStats
				runtime.ReadMemStats(&m)
				o.Observe(int64(m.Alloc))
				return nil
			},
		),
	)
	if err != nil {
		return fmt.Errorf("failed to create go_memstats_alloc_bytes gauge: %w", err)
	}

	_, err = meter.Int64ObservableGauge(
		"go_memstats_heap_alloc_bytes",
		metric.WithDescription("Number of heap bytes allocated and still in use"),
		metric.WithUnit("bytes"),
		metric.WithInt64Callback(
			func(ctx context.Context, o metric.Int64Observer) error {
				var m runtime.MemStats
				runtime.ReadMemStats(&m)
				o.Observe(int64(m.HeapAlloc))
				return nil
			},
		),
	)
	if err != nil {
		return fmt.Errorf("failed to create go_memstats_heap_alloc_bytes gauge: %w", err)
	}

	_, err = meter.Int64ObservableGauge(
		"go_memstats_heap_sys_bytes",
		metric.WithDescription("Number of heap bytes obtained from system"),
		metric.WithUnit("bytes"),
		metric.WithInt64Callback(
			func(ctx context.Context, o metric.Int64Observer) error {
				var m runtime.MemStats
				runtime.ReadMemStats(&m)
				o.Observe(int64(m.HeapSys))
				return nil
			},
		),
	)
	if err != nil {
		return fmt.Errorf("failed to create go_memstats_heap_sys_bytes gauge: %w", err)
	}

	_, err = meter.Int64ObservableGauge(
		"go_memstats_heap_idle_bytes",
		metric.WithDescription("Number of heap bytes waiting to be used"),
		metric.WithUnit("bytes"),
		metric.WithInt64Callback(
			func(ctx context.Context, o metric.Int64Observer) error {
				var m runtime.MemStats
				runtime.ReadMemStats(&m)
				o.Observe(int64(m.HeapIdle))
				return nil
			},
		),
	)
	if err != nil {
		return fmt.Errorf("failed to create go_memstats_heap_idle_bytes gauge: %w", err)
	}

	_, err = meter.Int64ObservableGauge(
		"go_memstats_heap_inuse_bytes",
		metric.WithDescription("Number of heap bytes that are in use"),
		metric.WithUnit("bytes"),
		metric.WithInt64Callback(
			func(ctx context.Context, o metric.Int64Observer) error {
				var m runtime.MemStats
				runtime.ReadMemStats(&m)
				o.Observe(int64(m.HeapInuse))
				return nil
			},
		),
	)
	if err != nil {
		return fmt.Errorf("failed to create go_memstats_heap_inuse_bytes gauge: %w", err)
	}

	_, err = meter.Int64ObservableGauge(
		"go_memstats_heap_released_bytes",
		metric.WithDescription("Number of heap bytes released to OS"),
		metric.WithUnit("bytes"),
		metric.WithInt64Callback(
			func(ctx context.Context, o metric.Int64Observer) error {
				var m runtime.MemStats
				runtime.ReadMemStats(&m)
				o.Observe(int64(m.HeapReleased))
				return nil
			},
		),
	)
	if err != nil {
		return fmt.Errorf("failed to create go_memstats_heap_released_bytes gauge: %w", err)
	}

	_, err = meter.Int64ObservableGauge(
		"go_memstats_sys_bytes",
		metric.WithDescription("Number of bytes obtained from system"),
		metric.WithUnit("bytes"),
		metric.WithInt64Callback(
			func(ctx context.Context, o metric.Int64Observer) error {
				var m runtime.MemStats
				runtime.ReadMemStats(&m)
				o.Observe(int64(m.Sys))
				return nil
			},
		),
	)
	if err != nil {
		return fmt.Errorf("failed to create go_memstats_sys_bytes gauge: %w", err)
	}

	_, err = meter.Int64ObservableCounter(
		"go_memstats_mallocs_total",
		metric.WithDescription("Total number of mallocs"),
		metric.WithInt64Callback(
			func(ctx context.Context, o metric.Int64Observer) error {
				var m runtime.MemStats
				runtime.ReadMemStats(&m)
				o.Observe(int64(m.Mallocs))
				return nil
			},
		),
	)
	if err != nil {
		return fmt.Errorf("failed to create go_memstats_mallocs_total counter: %w", err)
	}

	_, err = meter.Int64ObservableCounter(
		"go_memstats_frees_total",
		metric.WithDescription("Total number of frees"),
		metric.WithInt64Callback(
			func(ctx context.Context, o metric.Int64Observer) error {
				var m runtime.MemStats
				runtime.ReadMemStats(&m)
				o.Observe(int64(m.Frees))
				return nil
			},
		),
	)
	if err != nil {
		return fmt.Errorf("failed to create go_memstats_frees_total counter: %w", err)
	}

	_, err = meter.Int64ObservableGauge(
		"go_memstats_heap_objects",
		metric.WithDescription("Number of allocated objects"),
		metric.WithInt64Callback(
			func(ctx context.Context, o metric.Int64Observer) error {
				var m runtime.MemStats
				runtime.ReadMemStats(&m)
				o.Observe(int64(m.HeapObjects))
				return nil
			},
		),
	)
	if err != nil {
		return fmt.Errorf("failed to create go_memstats_heap_objects gauge: %w", err)
	}

	_, err = meter.Int64ObservableGauge(
		"go_memstats_next_gc_bytes",
		metric.WithDescription("Number of heap bytes when next garbage collection will take place"),
		metric.WithUnit("bytes"),
		metric.WithInt64Callback(
			func(ctx context.Context, o metric.Int64Observer) error {
				var m runtime.MemStats
				runtime.ReadMemStats(&m)
				o.Observe(int64(m.NextGC))
				return nil
			},
		),
	)
	if err != nil {
		return fmt.Errorf("failed to create go_memstats_next_gc_bytes gauge: %w", err)
	}

	_, err = meter.Float64ObservableGauge(
		"go_memstats_last_gc_time_seconds",
		metric.WithDescription("Number of seconds since 1970 of last garbage collection"),
		metric.WithUnit("s"),
		metric.WithFloat64Callback(
			func(ctx context.Context, o metric.Float64Observer) error {
				var m runtime.MemStats
				runtime.ReadMemStats(&m)
				o.Observe(float64(m.LastGC) / 1e9)
				return nil
			},
		),
	)
	if err != nil {
		return fmt.Errorf("failed to create go_memstats_last_gc_time_seconds gauge: %w", err)
	}

	_, err = meter.Int64ObservableGauge(
		"go_memstats_gc_sys_bytes",
		metric.WithDescription("Number of bytes used for garbage collection system metadata"),
		metric.WithUnit("bytes"),
		metric.WithInt64Callback(
			func(ctx context.Context, o metric.Int64Observer) error {
				var m runtime.MemStats
				runtime.ReadMemStats(&m)
				o.Observe(int64(m.GCSys))
				return nil
			},
		),
	)
	if err != nil {
		return fmt.Errorf("failed to create go_memstats_gc_sys_bytes gauge: %w", err)
	}

	_, err = meter.Int64ObservableGauge(
		"go_threads",
		metric.WithDescription("Number of OS threads created"),
		metric.WithInt64Callback(
			func(ctx context.Context, o metric.Int64Observer) error {
				o.Observe(int64(runtime.GOMAXPROCS(0)))
				return nil
			},
		),
	)
	if err != nil {
		return fmt.Errorf("failed to create go_threads gauge: %w", err)
	}

	var previousNumGC uint32
	var totalPauseNs uint64

	_, err = meter.Float64ObservableGauge(
		"go_gc_duration_seconds_sum",
		metric.WithDescription("Total pause duration of garbage collection cycles"),
		metric.WithUnit("s"),
		metric.WithFloat64Callback(
			func(ctx context.Context, o metric.Float64Observer) error {
				var m runtime.MemStats
				runtime.ReadMemStats(&m)

				if m.NumGC > previousNumGC {
					for i := previousNumGC; i < m.NumGC; i++ {
						idx := i % uint32(len(m.PauseNs))
						totalPauseNs += m.PauseNs[idx]
					}
					previousNumGC = m.NumGC
				}

				o.Observe(float64(totalPauseNs) / 1e9)
				return nil
			},
		),
	)
	if err != nil {
		return fmt.Errorf("failed to create go_gc_duration_seconds_sum gauge: %w", err)
	}

	_, err = meter.Int64ObservableGauge(
		"go_gc_duration_seconds_count",
		metric.WithDescription("Number of garbage collection cycles"),
		metric.WithInt64Callback(
			func(ctx context.Context, o metric.Int64Observer) error {
				var m runtime.MemStats
				runtime.ReadMemStats(&m)
				o.Observe(int64(m.NumGC))
				return nil
			},
		),
	)
	if err != nil {
		return fmt.Errorf("failed to create go_gc_duration_seconds_count gauge: %w", err)
	}

	startTime := time.Now()
	_, err = meter.Float64ObservableGauge(
		"process_start_time_seconds",
		metric.WithDescription("Start time of the process since unix epoch in seconds"),
		metric.WithUnit("s"),
		metric.WithFloat64Callback(
			func(ctx context.Context, o metric.Float64Observer) error {
				o.Observe(float64(startTime.Unix()))
				return nil
			},
		),
	)
	if err != nil {
		return fmt.Errorf("failed to create process_start_time_seconds gauge: %w", err)
	}

	return nil
}

func ComputeApproximateRequestSize(r *http.Request) int {
	s := 0
	if r.URL != nil {
		s = len(r.URL.Path)
	}

	s += len(r.Method)
	s += len(r.Proto)
	for name, values := range r.Header {
		s += len(name)
		for _, value := range values {
			s += len(value)
		}
	}
	s += len(r.Host)

	if r.ContentLength != -1 {
		s += int(r.ContentLength)
	}
	return s
}


=== pkg/telemetry/options.go ===
package telemetry

import (
	"fmt"
	"time"
)

type Option func(*telemetryOptions) error

type telemetryOptions struct {
	serviceName     string
	serviceVersion  string
	logExporters    []LogExporter
	metricExporters []MetricExporter
	traceExporters  []TraceExporter
	batchSize       int
	batchTimeout    time.Duration
	queueSize       int
	traceSampleRate float64
}

func defaultConfig() *telemetryOptions {
	return &telemetryOptions{
		serviceName:     "unknown-service",
		serviceVersion:  "0.0.0",
		batchSize:       512,
		batchTimeout:    5 * time.Second,
		queueSize:       2048,
		traceSampleRate: 1.0,
	}
}

func WithService(name, version string) Option {
	return func(c *telemetryOptions) error {
		if name == "" {
			return fmt.Errorf("service name cannot be empty")
		}
		if version == "" {
			return fmt.Errorf("service version cannot be empty")
		}
		c.serviceName = name
		c.serviceVersion = version
		return nil
	}
}

func WithLogExporters(exporters ...LogExporter) Option {
	return func(c *telemetryOptions) error {
		for i, exp := range exporters {
			if exp == nil {
				return fmt.Errorf("log exporter at index %d is nil", i)
			}
		}
		c.logExporters = exporters
		return nil
	}
}

func WithMetricExporters(exporters ...MetricExporter) Option {
	return func(c *telemetryOptions) error {
		for i, exp := range exporters {
			if exp == nil {
				return fmt.Errorf("metric exporter at index %d is nil", i)
			}
		}
		c.metricExporters = exporters
		return nil
	}
}

func WithTraceExporters(exporters ...TraceExporter) Option {
	return func(c *telemetryOptions) error {
		for i, exp := range exporters {
			if exp == nil {
				return fmt.Errorf("trace exporter at index %d is nil", i)
			}
		}
		c.traceExporters = exporters
		return nil
	}
}

func WithBatchConfig(size int, timeoutMs int, queueSize int) Option {
	return func(c *telemetryOptions) error {
		if size <= 0 {
			return fmt.Errorf("batch size must be positive, got %d", size)
		}
		if timeoutMs <= 0 {
			return fmt.Errorf("batch timeout must be positive, got %d", timeoutMs)
		}
		if queueSize <= 0 {
			return fmt.Errorf("queue size must be positive, got %d", queueSize)
		}
		c.batchSize = size
		c.batchTimeout = time.Duration(timeoutMs) * time.Millisecond
		c.queueSize = queueSize
		return nil
	}
}

func WithTraceSampleRate(rate float64) Option {
	return func(c *telemetryOptions) error {
		if rate < 0.0 || rate > 1.0 {
			return fmt.Errorf("trace sample rate must be between 0.0 and 1.0, got %f", rate)
		}
		c.traceSampleRate = rate
		return nil
	}
}


=== pkg/telemetry/telemetry.go ===
package telemetry

import (
	"context"
	"fmt"
	"log/slog"
	"os"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
	"golang.org/x/sync/errgroup"

	sdklog "go.opentelemetry.io/otel/sdk/log"
	sdkmetric "go.opentelemetry.io/otel/sdk/metric"
	sdktrace "go.opentelemetry.io/otel/sdk/trace"
)

type Telemetry struct {
	resource       *resource.Resource
	loggerProvider *sdklog.LoggerProvider
	meterProvider  *sdkmetric.MeterProvider
	tracerProvider *sdktrace.TracerProvider
	shutdownFuncs  []func(context.Context) error
	config         *telemetryOptions
}

func New(ctx context.Context, opts ...Option) (*Telemetry, error) {
	cfg := defaultConfig()
	for _, opt := range opts {
		if err := opt(cfg); err != nil {
			return nil, fmt.Errorf("failed to apply option: %w", err)
		}
	}

	res, err := resource.New(ctx,
		resource.WithAttributes(
			semconv.ServiceNameKey.String(cfg.serviceName),
			semconv.ServiceVersionKey.String(cfg.serviceVersion),
		),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create resource: %w", err)
	}

	t := &Telemetry{
		resource:      res,
		shutdownFuncs: make([]func(context.Context) error, 0),
		config:        cfg,
	}

	if err := t.initLogging(ctx); err != nil {
		return nil, fmt.Errorf("failed to initialize logging: %w", err)
	}

	if err := t.initMetrics(ctx); err != nil {
		_ = t.Shutdown(ctx)
		return nil, fmt.Errorf("failed to initialize metrics: %w", err)
	}

	if err := t.initTracing(ctx); err != nil {
		_ = t.Shutdown(ctx)
		return nil, fmt.Errorf("failed to initialize tracing: %w", err)
	}

	return t, nil
}

func (t *Telemetry) initLogging(ctx context.Context) error {
	if len(t.config.logExporters) == 0 {
		return nil
	}

	handlers := make([]slog.Handler, 0, len(t.config.logExporters))
	for _, exporter := range t.config.logExporters {
		handler, err := exporter.GetSlogHandler(ctx)
		if err != nil {
			return fmt.Errorf("failed to get slog handler from %s: %w", exporter.Name(), err)
		}
		handlers = append(handlers, handler)
		t.shutdownFuncs = append(t.shutdownFuncs, exporter.Shutdown)
	}

	var finalHandler slog.Handler
	if len(handlers) == 1 {
		finalHandler = handlers[0]
	} else {
		finalHandler = &multiHandler{handlers: handlers}
	}

	wrappedHandler := &traceLogHandler{handler: finalHandler}
	logger := slog.New(wrappedHandler)
	slog.SetDefault(logger)

	return nil
}

func (t *Telemetry) initMetrics(ctx context.Context) error {
	if len(t.config.metricExporters) == 0 {
		return nil
	}

	exporters := make([]sdkmetric.Exporter, 0, len(t.config.metricExporters))
	for _, exporter := range t.config.metricExporters {
		exp, err := exporter.GetSdkMetricExporter(ctx, t.resource)
		if err != nil {
			return fmt.Errorf("failed to get metric exporter from %s: %w", exporter.Name(), err)
		}
		exporters = append(exporters, exp)
		t.shutdownFuncs = append(t.shutdownFuncs, exporter.Shutdown)
	}

	opts := []sdkmetric.Option{
		sdkmetric.WithResource(t.resource),
	}

	for _, exp := range exporters {
		reader := sdkmetric.NewPeriodicReader(exp,
			sdkmetric.WithInterval(t.config.batchTimeout),
		)
		opts = append(opts, sdkmetric.WithReader(reader))
	}

	meterProvider := sdkmetric.NewMeterProvider(opts...)

	t.meterProvider = meterProvider
	t.shutdownFuncs = append(t.shutdownFuncs, meterProvider.Shutdown)
	otel.SetMeterProvider(meterProvider)

	return nil
}

func (t *Telemetry) initTracing(ctx context.Context) error {
	if len(t.config.traceExporters) == 0 {
		return nil
	}

	exporters := make([]sdktrace.SpanExporter, 0, len(t.config.traceExporters))
	for _, exporter := range t.config.traceExporters {
		exp, err := exporter.GetSpanExporter(ctx, t.resource)
		if err != nil {
			return fmt.Errorf("failed to get span exporter from %s: %w", exporter.Name(), err)
		}
		exporters = append(exporters, exp)
		t.shutdownFuncs = append(t.shutdownFuncs, exporter.Shutdown)
	}

	opts := []sdktrace.TracerProviderOption{
		sdktrace.WithResource(t.resource),
		sdktrace.WithSampler(sdktrace.TraceIDRatioBased(t.config.traceSampleRate)),
	}

	for _, exp := range exporters {
		processor := sdktrace.NewBatchSpanProcessor(exp,
			sdktrace.WithMaxQueueSize(t.config.queueSize),
			sdktrace.WithMaxExportBatchSize(t.config.batchSize),
			sdktrace.WithBatchTimeout(t.config.batchTimeout),
		)
		opts = append(opts, sdktrace.WithSpanProcessor(processor))
	}

	tracerProvider := sdktrace.NewTracerProvider(opts...)

	t.tracerProvider = tracerProvider
	t.shutdownFuncs = append(t.shutdownFuncs, tracerProvider.Shutdown)
	otel.SetTracerProvider(tracerProvider)

	return nil
}

func (t *Telemetry) Shutdown(ctx context.Context) error {
	eg := errgroup.Group{}
	for _, fn := range t.shutdownFuncs {
		fn := fn
		eg.Go(func() error {
			if err := fn(ctx); err != nil {
				fmt.Fprintf(os.Stderr, "[telemetry] shutdown error: %v\n", err)
				return err
			}
			return nil
		})
	}
	return eg.Wait()
}

func (t *Telemetry) HealthCheck(ctx context.Context) error {
	if len(t.config.logExporters) == 0 && len(t.config.metricExporters) == 0 && len(t.config.traceExporters) == 0 {
		return fmt.Errorf("no exporters configured")
	}
	return nil
}

func (t *Telemetry) HasMetrics() bool {
	return t.meterProvider != nil
}

func (t *Telemetry) HasTracing() bool {
	return t.tracerProvider != nil
}

func (t *Telemetry) HasLogging() bool {
	return len(t.config.logExporters) > 0
}

type multiHandler struct {
	handlers []slog.Handler
}

func (m *multiHandler) Enabled(ctx context.Context, level slog.Level) bool {
	for _, h := range m.handlers {
		if h.Enabled(ctx, level) {
			return true
		}
	}
	return false
}

func (m *multiHandler) Handle(ctx context.Context, r slog.Record) error {
	for _, h := range m.handlers {
		if err := h.Handle(ctx, r); err != nil {
			fmt.Fprintf(os.Stderr, "[telemetry] handler error: %v\n", err)
		}
	}
	return nil
}

func (m *multiHandler) WithAttrs(attrs []slog.Attr) slog.Handler {
	newHandlers := make([]slog.Handler, len(m.handlers))
	for i, h := range m.handlers {
		newHandlers[i] = h.WithAttrs(attrs)
	}
	return &multiHandler{handlers: newHandlers}
}

func (m *multiHandler) WithGroup(name string) slog.Handler {
	newHandlers := make([]slog.Handler, len(m.handlers))
	for i, h := range m.handlers {
		newHandlers[i] = h.WithGroup(name)
	}
	return &multiHandler{handlers: newHandlers}
}


=== pkg/telemetry/trace_exporters.go ===
package telemetry

import (
	"context"
	"crypto/tls"
	"fmt"
	"strings"

	"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
	"go.opentelemetry.io/otel/sdk/resource"
	sdktrace "go.opentelemetry.io/otel/sdk/trace"
)

type OtlpHttpTraceExporter struct {
	endpoint string
	insecure bool
	headers  map[string]string
	exporter sdktrace.SpanExporter
}

func NewOtlpTraceExporter(endpoint string, headers map[string]string) *OtlpHttpTraceExporter {
	if endpoint == "" {
		return nil
	}
	return &OtlpHttpTraceExporter{
		endpoint: endpoint,
		insecure: false,
		headers:  headers,
		exporter: nil,
	}
}

func NewOtlpTraceExporterInsecure(endpoint string, headers map[string]string) *OtlpHttpTraceExporter {
	if endpoint == "" {
		return nil
	}
	return &OtlpHttpTraceExporter{
		endpoint: endpoint,
		insecure: true,
		headers:  headers,
		exporter: nil,
	}
}

func (o *OtlpHttpTraceExporter) Name() string {
	return "otlp-http-traces"
}

func (o *OtlpHttpTraceExporter) GetSpanExporter(ctx context.Context, res *resource.Resource) (sdktrace.SpanExporter, error) {
	endpoint := strings.TrimPrefix(o.endpoint, "http://")
	endpoint = strings.TrimPrefix(endpoint, "https://")

	opts := []otlptracehttp.Option{
		otlptracehttp.WithEndpoint(endpoint),
	}

	if o.insecure {
		opts = append(opts, otlptracehttp.WithInsecure())
	} else {
		opts = append(opts, otlptracehttp.WithTLSClientConfig(&tls.Config{
			MinVersion: tls.VersionTLS12,
		}))
	}

	if len(o.headers) > 0 {
		opts = append(opts, otlptracehttp.WithHeaders(o.headers))
	}

	exporter, err := otlptracehttp.New(ctx, opts...)
	if err != nil {
		return nil, fmt.Errorf("failed to create OTLP HTTP trace exporter: %w", err)
	}

	o.exporter = exporter
	return exporter, nil
}

func (o *OtlpHttpTraceExporter) Shutdown(ctx context.Context) error {
	if o.exporter != nil {
		if err := o.exporter.Shutdown(ctx); err != nil {
			return fmt.Errorf("failed to shutdown OTLP HTTP trace exporter: %w", err)
		}
	}
	return nil
}

var _ TraceExporter = (*OtlpHttpTraceExporter)(nil)

type noopSpanExporter struct{}

func (e *noopSpanExporter) ExportSpans(ctx context.Context, spans []sdktrace.ReadOnlySpan) error {
	return nil
}

func (e *noopSpanExporter) Shutdown(ctx context.Context) error {
	return nil
}

var _ sdktrace.SpanExporter = (*noopSpanExporter)(nil)

type NoopTraceExporter struct{}

func NewNoopTraceExporter() *NoopTraceExporter {
	return &NoopTraceExporter{}
}

func (n *NoopTraceExporter) Name() string {
	return "noop-traces"
}

func (n *NoopTraceExporter) GetSpanExporter(ctx context.Context, res *resource.Resource) (sdktrace.SpanExporter, error) {
	return &noopSpanExporter{}, nil
}

func (n *NoopTraceExporter) Shutdown(ctx context.Context) error {
	return nil
}

var _ TraceExporter = (*NoopTraceExporter)(nil)


=== pkg/telemetry/tracer.go ===
package telemetry

import (
	"context"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/sdk/resource"
	sdktrace "go.opentelemetry.io/otel/sdk/trace"
	"go.opentelemetry.io/otel/trace"
)

type TraceExporter interface {
	Name() string
	GetSpanExporter(ctx context.Context, res *resource.Resource) (sdktrace.SpanExporter, error)
	Shutdown(ctx context.Context) error
}

func GetTracer(serviceName string) trace.Tracer {
	return otel.Tracer(serviceName)
}


=== queue/jobs/send_transactional_email.go ===
package jobs

import "myorg/webapp/email"

type SendTransactionalEmailArgs struct {
	Data email.TransactionalData
}

func (SendTransactionalEmailArgs) Kind() string { return "send_transactional_email" }


=== queue/queue.go ===
// Package queue provides an InsertOnly queue implementation using River with pgx v5.
package queue

import (
	"context"
	"log/slog"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/riverqueue/river"
	"github.com/riverqueue/river/riverdriver/riverpgxv5"
)

type InsertOnly struct {
	Client *river.Client[pgx.Tx]
}

func NewInsertOnly(pool *pgxpool.Pool, workers *river.Workers) (InsertOnly, error) {
	riverClient, err := river.NewClient(riverpgxv5.New(pool), &river.Config{
		Workers: workers,
	})
	if err != nil {
		return InsertOnly{}, err
	}

	return InsertOnly{riverClient}, nil
}

type Processor struct {
	Client *river.Client[pgx.Tx]
}

func (p Processor) Start(ctx context.Context) error {
	return p.Client.Start(ctx)
}

func (p Processor) Stop(ctx context.Context) error {
	return p.Client.Stop(ctx)
}

func NewProcessor(
	ctx context.Context,
	pool *pgxpool.Pool,
	workers *river.Workers,
) (Processor, error) {
	riverClient, err := river.NewClient(riverpgxv5.New(pool), &river.Config{
		Queues: map[string]river.QueueConfig{
			river.QueueDefault: {MaxWorkers: 100},
			"workflow":         {MaxWorkers: 100},
		},
		Logger:  slog.Default(),
		Workers: workers,
	})
	if err != nil {
		return Processor{}, err
	}

	return Processor{riverClient}, nil
}


=== queue/workers/send_transactional_email.go ===
package workers

import (
	"context"

	"github.com/riverqueue/river"

	"myorg/webapp/email"
	"myorg/webapp/queue/jobs"
)

type SendTransactionalEmailWorker struct {
	river.WorkerDefaults[jobs.SendTransactionalEmailArgs]
	emailClient email.Client
}

func NewSendTransactionalEmailWorker(emailClient email.Client) *SendTransactionalEmailWorker {
	return &SendTransactionalEmailWorker{
		emailClient: emailClient,
	}
}

func (w *SendTransactionalEmailWorker) Work(ctx context.Context, job *river.Job[jobs.SendTransactionalEmailArgs]) error {
	err := w.emailClient.SendTransactional(ctx, job.Args.Data)
	if err != nil {
		if !email.IsRetryable(err) {
			return river.JobCancel(err)
		}
		return err
	}

	return nil
}


=== queue/workers/workers.go ===
// Package workers provides a centralized place to register all background workers for the application.
package workers

import (
	"github.com/riverqueue/river"

	"myorg/webapp/email"
)

func Register(emailClient email.Client) (*river.Workers, error) {
	wrks := river.NewWorkers()

	if err := river.AddWorkerSafely(wrks, NewSendTransactionalEmailWorker(emailClient)); err != nil {
		return nil, err
	}

	return wrks, nil
}


=== router/cookies/cookies.go ===
// Package cookies provides utilities for managing application context and session data in an Echo web application.
package cookies

import (
	"context"

	"myorg/webapp/config"

	"github.com/labstack/echo-contrib/session"
	"github.com/labstack/echo/v4"
)

var AppKey appKey = "app_context"

type appKey string

const (
	isAuthenticated = "is_authenticated"
)

type App struct {
	echo.Context
	IsAuthenticated bool
	FlashMessages   []FlashMessage
}

func GetAppCtx(ctx context.Context) App {
	appCtx, ok := ctx.Value(AppKey).(App)
	if !ok {
		return App{}
	}

	return appCtx
}

func GetApp(c echo.Context) App {
	sess, err := session.Get(config.AuthenticatedSessionName, c)
	if err != nil {
		return App{}
	}
	app := App{Context: c}

	if _, ok := sess.Values[isAuthenticated].(bool); ok {
		app.IsAuthenticated = true
	}

	return app
}


=== router/cookies/flash.go ===
package cookies

import (
	"context"
	"strings"
	"time"

	"myorg/webapp/config"

	"github.com/google/uuid"
	"github.com/labstack/echo-contrib/session"
	"github.com/labstack/echo/v4"
)

type FlashMessage struct {
	echo.Context
	ID        uuid.UUID
	Type      FlashType
	CreatedAt time.Time
	Message   string
}

type flashKey string

var (
	FlashKey = func() flashKey {
		if config.Env == config.ProdEnvironment {
			return flashKey(strings.ToLower(config.ProjectName) + "_" + "flash_key")
		}

		return flashKey(strings.ToLower(config.ProjectName) + "_" + "dev_flash_key")
	}()
	flashSession = "flash_session"
)

type FlashType string

const (
	FlashSuccess FlashType = "success"
	FlashError   FlashType = "error"
	FlashWarning FlashType = "warning"
	FlashInfo    FlashType = "info"
)

func AddFlash(
	c echo.Context, flashType FlashType, msg string,
) error {
	sess, err := session.Get(string(FlashKey), c)
	if err != nil {
		return err
	}

	sess.AddFlash(FlashMessage{
		ID:        uuid.New(),
		Type:      flashType,
		CreatedAt: time.Now(),
		Message:   msg,
	}, flashSession)

	return sess.Save(c.Request(), c.Response())
}

func GetFlashes(c echo.Context) ([]FlashMessage, error) {
	sess, err := session.Get(string(FlashKey), c)
	if err != nil {
		return nil, err
	}

	var flashMessages []FlashMessage
	for _, flash := range sess.Flashes(flashSession) {
		if msg, ok := flash.(FlashMessage); ok {
			flashMessages = append(flashMessages, msg)
		}
	}

	if err := sess.Save(c.Request(), c.Response()); err != nil {
		return nil, err
	}

	return flashMessages, nil
}

func GetFlashesCtx(ctx context.Context) []FlashMessage {
	value, ok := ctx.Value(FlashKey).([]FlashMessage)
	if !ok {
		return nil
	}

	return value
}


=== router/middleware/middleware.go ===
// Package middleware provides HTTP middleware for the Echo web framework,
package middleware

import (
	"context"
	"log/slog"
	"strings"
	"time"

	"myorg/webapp/router/routes"

	"github.com/labstack/echo/v4"
	"go.opentelemetry.io/contrib/instrumentation/github.com/labstack/echo/otelecho"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
)

func Logging(
	tp trace.TracerProvider,
	httpRequestsTotal metric.Int64Counter,
	httpDuration metric.Float64Histogram,
	httpInFlight metric.Int64UpDownCounter,
) echo.MiddlewareFunc {
	otelMiddleware := otelecho.Middleware(
		"grafto",
		otelecho.WithTracerProvider(tp),
	)

	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			if strings.Contains(c.Request().URL.Path, routes.AssetsRoutePrefix) {
				return next(c)
			}

			var ctx context.Context
			var requestDuration time.Duration

			httpInFlight.Add(ctx, 1)

			wrappedNext := func(c echo.Context) error {
				ctx = c.Request().Context()

				start := time.Now()
				err := next(c)
				requestDuration = time.Since(start)

				return err
			}

			err := otelMiddleware(wrappedNext)(c)

			httpInFlight.Add(ctx, -1)

			statusCode := c.Response().Status

			attrs := []attribute.KeyValue{
				attribute.String("method", c.Request().Method),
				attribute.String("route", c.Path()),
				attribute.Int("status_code", statusCode),
			}

			httpRequestsTotal.Add(
				ctx,
				1,
				metric.WithAttributes(attrs...),
			)

			httpDuration.Record(
				ctx,
				requestDuration.Seconds(),
				metric.WithAttributes(attrs...),
			)

			slog.InfoContext(ctx, "HTTP request completed",
				"method", c.Request().Method,
				"path", c.Request().URL.Path,
				"status", statusCode,
				"duration", requestDuration.Seconds(),
				"remote_addr", c.RealIP(),
				"user_agent", c.Request().UserAgent(),
			)

			return err
		}
	}
}


=== router/router.go ===
// Package router provides the application routes and middleware setup.
package router

import (
	"context"
	"encoding/gob"
	"encoding/hex"
	"fmt"
	"log/slog"
	"net/http"
	"os"
	"reflect"
	"slices"
	"strings"
	"time"

	"myorg/webapp/config"
	"myorg/webapp/controllers"
	"myorg/webapp/pkg/telemetry"
	"myorg/webapp/router/cookies"
	"myorg/webapp/router/routes"

	"github.com/google/uuid"
	"github.com/gorilla/sessions"
	"github.com/labstack/echo-contrib/session"
	"github.com/labstack/echo/v4"
	"go.opentelemetry.io/contrib/instrumentation/github.com/labstack/echo/otelecho"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
	"riverqueue.com/riverui"

	echomw "github.com/labstack/echo/v4/middleware"
)

type Router struct {
	Handler     *echo.Echo
	controllers controllers.Controllers
	telemetry   *telemetry.Telemetry
}

func New(
	ctx context.Context,
	controllers controllers.Controllers,
	cfg config.Config,
	tel *telemetry.Telemetry,
	riverHandler *riverui.Handler,
) (*Router, error) {
	gob.Register(uuid.UUID{})
	gob.Register(cookies.FlashMessage{})

	router := echo.New()

	if config.Env != config.ProdEnvironment {
		router.Debug = true
	}

	authKey, err := hex.DecodeString(cfg.App.SessionKey)
	if err != nil {
		return nil, err
	}
	encKey, err := hex.DecodeString(cfg.App.SessionEncryptionKey)
	if err != nil {
		return nil, err
	}

	//csrfName := strings.ToLower(config.ProjectName) + "_" + "dev_csrf"
	//if config.Env == config.ProdEnvironment {
	//	csrfName = strings.ToLower(config.ProjectName) + "_" + "csrf"
	//}
	// TODO: make changing name work with d-*
	csrfName := "_csrf"

	middleware := []echo.MiddlewareFunc{
		otelecho.Middleware(config.ServiceName),
		logger(tel),
		session.Middleware(
			sessions.NewCookieStore(
				authKey,
				encKey,
			),
		),
		registerAppContext,
		registerFlashMessagesContext,

		echomw.CSRFWithConfig(echomw.CSRFConfig{Skipper: func(c echo.Context) bool {
			return strings.HasPrefix(c.Request().URL.Path, routes.APIRoutePrefix) ||
				strings.HasPrefix(c.Request().URL.Path, routes.AssetsRoutePrefix)
		}, TokenLookup: "cookie:" + csrfName, CookiePath: "/", CookieDomain: func() string {
			if config.Env == config.ProdEnvironment {
				return config.Domain
			}

			return ""
		}(), CookieSecure: config.Env == config.ProdEnvironment, CookieHTTPOnly: true, CookieSameSite: http.SameSiteStrictMode}),

		echomw.Recover(),
	}

	router.Use(middleware...)
	router.Any("/riverui*", echo.WrapHandler(riverHandler))

	return &Router{
		router,
		controllers,
		tel,
	}, nil
}

func (r *Router) SetupRoutes() *echo.Echo {
	registeredRoutes := []string{}
	controllersValue := reflect.ValueOf(r.controllers)
	var errors []string

	for _, route := range routes.Registry {
		if registered := slices.Contains(registeredRoutes, route.Name); registered {
			errors = append(errors, fmt.Sprintf("  - Route '%s' (Path: %s) is registered more than once", route.Name, route.Path))
			continue
		}

		if route.Controller == "" || route.ControllerMethod == "" {
			errors = append(errors, fmt.Sprintf("  - Route '%s' (Path: %s) must specify Controller and ControllerMethod fields", route.Name, route.Path))
			continue
		}

		controllerField := controllersValue.FieldByName(route.Controller)
		if !controllerField.IsValid() {
			errors = append(errors, fmt.Sprintf("  - Route '%s' expects Controller '%s' to exist but it was not found", route.Name, route.Controller))
			continue
		}

		controller := controllerField.Interface()
		controllerFunc, err := getHandlerFunc(controller, route.ControllerMethod)
		if err != nil {
			errors = append(errors, fmt.Sprintf("  - Route '%s' expects Controller '%s' to have method '%s' but none was found", route.Name, route.Controller, route.ControllerMethod))
			continue
		}

		var middlewareFuncs []echo.MiddlewareFunc
		for _, mw := range route.Middleware {
			middlewareFuncs = append(middlewareFuncs, echo.MiddlewareFunc(mw.Handler()))
		}

		switch route.Method {
		case http.MethodGet:
			registeredRoutes = append(registeredRoutes, route.Name)
			r.Handler.GET(route.Path, controllerFunc, middlewareFuncs...).Name = route.Name
		case http.MethodPost:
			registeredRoutes = append(registeredRoutes, route.Name)
			r.Handler.POST(route.Path, controllerFunc, middlewareFuncs...).Name = route.Name
		case http.MethodPut:
			registeredRoutes = append(registeredRoutes, route.Name)
			r.Handler.PUT(route.Path, controllerFunc, middlewareFuncs...).Name = route.Name
		case http.MethodDelete:
			registeredRoutes = append(registeredRoutes, route.Name)
			r.Handler.DELETE(route.Path, controllerFunc, middlewareFuncs...).Name = route.Name
		}
	}

	if len(errors) > 0 {
		fmt.Fprintf(os.Stderr, "Found %d route configuration error(s):\n", len(errors))
		for _, err := range errors {
			fmt.Fprintln(os.Stderr, err)
		}
		os.Exit(1)
	}

	notFoundHandler, err := getHandlerFunc(r.controllers.Pages, "NotFound")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: Failed to setup NotFound handler: %v\n", err)
		os.Exit(1)
	}

	r.Handler.RouteNotFound("/*", notFoundHandler)

	return r.Handler
}

func getHandlerFunc(controller any, methodName string) (echo.HandlerFunc, error) {
	appType := reflect.TypeOf(controller)
	method, found := appType.MethodByName(methodName)
	if !found {
		return nil, fmt.Errorf("method '%s' not found on controller", methodName)
	}

	return func(c echo.Context) error {
		values := method.Func.Call([]reflect.Value{
			reflect.ValueOf(controller),
			reflect.ValueOf(c),
		})

		if len(values) != 1 {
			panic(
				fmt.Sprintf(
					"Controller method %s does not return exactly one value",
					methodName,
				),
			)
		}

		if values[0].IsNil() {
			return nil
		}

		return values[0].Interface().(error)
	}, nil
}

func registerAppContext(
	next echo.HandlerFunc,
) echo.HandlerFunc {
	return func(c echo.Context) error {
		if strings.HasPrefix(c.Request().URL.Path, routes.AssetsRoutePrefix) ||
			strings.HasPrefix(c.Request().URL.Path, routes.APIRoutePrefix) {
			return next(c)
		}

		c.Set(string(cookies.AppKey), cookies.GetApp(c))

		return next(c)
	}
}

func registerFlashMessagesContext(
	next echo.HandlerFunc,
) echo.HandlerFunc {
	return func(c echo.Context) error {
		if strings.HasPrefix(c.Request().URL.Path, routes.AssetsRoutePrefix) ||
			strings.HasPrefix(c.Request().URL.Path, routes.APIRoutePrefix) {
			return next(c)
		}

		flashes, err := cookies.GetFlashes(c)
		if err != nil {
			slog.Error("Error getting flash messages from session", "error", err)
			return next(c)
		}

		c.Set(string(cookies.FlashKey), flashes)

		return next(c)
	}
}

func logger(tel *telemetry.Telemetry) echo.MiddlewareFunc {
	var httpRequestsTotal metric.Int64Counter
	var httpDuration metric.Float64Histogram
	var httpInFlight metric.Int64UpDownCounter

	if tel.HasMetrics() {
		var err error
		httpRequestsTotal, err = telemetry.HTTPRequestsTotal()
		if err != nil {
			slog.Warn("failed to create http_requests_total metric", "error", err)
		}
		httpDuration, err = telemetry.HTTPRequestDuration()
		if err != nil {
			slog.Warn("failed to create http_request_duration metric", "error", err)
		}
		httpInFlight, err = telemetry.HTTPRequestsInFlight()
		if err != nil {
			slog.Warn("failed to create http_requests_in_flight metric", "error", err)
		}

		meter := telemetry.GetMeter(config.ServiceName)
		if err := telemetry.SetupRuntimeMetricsInCallback(meter); err != nil {
			slog.Warn("failed to setup runtime metrics", "error", err)
		}
	}

	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			if strings.Contains(c.Request().URL.Path, routes.APIRoutePrefix) ||
				strings.Contains(c.Request().URL.Path, routes.AssetsRoutePrefix) {
				return next(c)
			}

			ctx := c.Request().Context()
			start := time.Now()

			if tel.HasMetrics() && httpInFlight != nil {
				httpInFlight.Add(ctx, 1)
				defer httpInFlight.Add(ctx, -1)
			}

			err := next(c)
			duration := time.Since(start)
			statusCode := c.Response().Status

			if tel.HasMetrics() && httpRequestsTotal != nil && httpDuration != nil {
				attrs := []attribute.KeyValue{
					attribute.String("method", c.Request().Method),
					attribute.String("route", c.Path()),
					attribute.Int("status_code", statusCode),
				}
				httpRequestsTotal.Add(ctx, 1, metric.WithAttributes(attrs...))
				httpDuration.Record(ctx, duration.Seconds(), metric.WithAttributes(attrs...))
			}

			slog.InfoContext(ctx, "HTTP request completed",
				"method", c.Request().Method,
				"path", c.Request().URL.Path,
				"status", statusCode,
				"remote_addr", c.RealIP(),
				"user_agent", c.Request().UserAgent(),
				"duration", duration.String(),
			)

			return err
		}
	}
}


=== router/routes/api.go ===
package routes

import "net/http"

const (
	APIRoutePrefix = "/api"
	apiNamePrefix  = "api"
)

var Health = newRouteBuilder("health").
	SetNamePrefix(apiNamePrefix).
	SetPath(APIRoutePrefix+"/health").
	SetMethod(http.MethodGet).
	SetCtrl("API", "Health").
	Register()


=== router/routes/assets.go ===
package routes

import (
	"fmt"
	"net/http"
	"time"
)

const (
	AssetsRoutePrefix = "/assets"
	assetsNamePrefix  = "assets"
)

var startTime = time.Now().Unix()

var Robots = newRouteBuilder("robots").
	SetNamePrefix(assetsNamePrefix).
	SetPath(AssetsRoutePrefix+"/robots.txt").
	SetMethod(http.MethodGet).
	SetCtrl("Assets", "Robots").
	Register()

var Sitemap = newRouteBuilder("sitemap").
	SetNamePrefix(assetsNamePrefix).
	SetPath(AssetsRoutePrefix+"/sitemap.xml").
	SetMethod(http.MethodGet).
	SetCtrl("Assets", "Sitemap").
	Register()

var Stylesheet = newRouteBuilder("css.stylesheet").
	SetNamePrefix(assetsNamePrefix).
	SetPath(AssetsRoutePrefix+fmt.Sprintf("/css/%v/style.css", startTime)).
	SetMethod(http.MethodGet).
	SetCtrl("Assets", "Stylesheet").
	Register()

var Scripts = newRouteBuilder("js.scripts").
	SetNamePrefix(assetsNamePrefix).
	SetPath(AssetsRoutePrefix+fmt.Sprintf("/js/%v/scripts.js", startTime)).
	SetMethod(http.MethodGet).
	SetCtrl("Assets", "Scripts").
	Register()

var Script = newRouteBuilder("js.script").
	SetNamePrefix(assetsNamePrefix).
	SetPath(AssetsRoutePrefix+fmt.Sprintf("/js/%v/:file", startTime)).
	SetMethod(http.MethodGet).
	SetCtrl("Assets", "Script").
	Register()


=== router/routes/pages.go ===
package routes

import "net/http"

const pageNamePrefix = "pages"

var HomePage = newRouteBuilder("home").
	SetNamePrefix(pageNamePrefix).
	SetPath("/").
	SetMethod(http.MethodGet).
	SetCtrl("Pages", "Home").
	WithSitemap().
	Register()


=== router/routes/route_group.go ===
package routes

type routeGroup struct {
	namePrefix string
	pathPrefix string
	middleware []routeMiddleware
}

func newRouteGroup(namePrefix, pathPrefix string) routeGroup {
	return routeGroup{
		namePrefix: namePrefix,
		pathPrefix: pathPrefix,
		middleware: []routeMiddleware{},
	}
}

func (g routeGroup) withMiddleware(mw ...routeMiddleware) routeGroup {
	g.middleware = append(g.middleware, mw...)
	return g
}

func (g routeGroup) route(name string) routeBuilder {
	builder := newRouteBuilder(name)
	builder = builder.SetNamePrefix(g.namePrefix)
	builder = builder.SetPath(g.pathPrefix)

	if len(g.middleware) > 0 {
		builder = builder.WithMiddleware(g.middleware...)
	}

	return builder
}


=== router/routes/routes.go ===
// Package routes provides the application route definitions.
package routes

import (
	"net/http"
	"strings"

	"github.com/google/uuid"
	"github.com/labstack/echo/v4"
)

type routeMiddleware interface {
	Handler() func(next echo.HandlerFunc) echo.HandlerFunc
}

type Route string

func (r Route) URL() string {
	return string(r)
}

type RouteWithID Route

func (r RouteWithID) URL(id uuid.UUID) string {
	return strings.Replace(string(r), ":id", id.String(), 1)
}

type RouteWithSlug Route

func (r RouteWithSlug) URL(slug string) string {
	return strings.Replace(string(r), ":slug", slug, 1)
}

type RouteWithToken Route

func (r RouteWithToken) URL(token string) string {
	return strings.Replace(string(r), ":token", token, 1)
}

type RouteDefinition struct {
	Name             string
	Path             string
	Controller       string
	ControllerMethod string
	Method           string
	IncludeInSitemap bool
	Middleware       []routeMiddleware
}

var Registry = []RouteDefinition{}

type routeBuilder RouteDefinition

func newRouteBuilder(name string) routeBuilder {
	return routeBuilder{
		Name:   name,
		Method: http.MethodGet,
	}
}

func (r routeBuilder) SetNamePrefix(prefix string) routeBuilder {
	r.Name = prefix + "." + r.Name
	return r
}

func (r routeBuilder) SetPath(path string) routeBuilder {
	r.Path = r.Path + path

	return r
}

func (r routeBuilder) SetMethod(method string) routeBuilder {
	r.Method = method
	return r
}

func (r routeBuilder) SetCtrl(ctrlName, ctrlMethod string) routeBuilder {
	r.Controller = ctrlName
	r.ControllerMethod = ctrlMethod

	return r
}

func (r routeBuilder) WithMiddleware(mw ...routeMiddleware) routeBuilder {
	r.Middleware = append(r.Middleware, mw...)
	return r
}

func (r routeBuilder) WithSitemap() routeBuilder {
	r.IncludeInSitemap = true
	return r
}

func (r routeBuilder) Register() Route {
	Registry = append(Registry, RouteDefinition(r))

	return Route(r.Path)
}

func (r routeBuilder) RegisterWithID() RouteWithID {
	Registry = append(Registry, RouteDefinition(r))

	return RouteWithID(r.Path)
}

func (r routeBuilder) RegisterWithSlug() RouteWithSlug {
	Registry = append(Registry, RouteDefinition(r))

	return RouteWithSlug(r.Path)
}

func (r routeBuilder) RegisterWithToken() RouteWithToken {
	Registry = append(Registry, RouteDefinition(r))

	return RouteWithToken(r.Path)
}


=== views/bad_request.templ ===
package views

templ BadRequest() {
	@base() {
		<h1>The request made was invalid</h1>
	}
}


=== views/bad_request_templ.go ===
// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.960
package views

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func BadRequest() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Var2 := templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
			templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
			templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
			if !templ_7745c5c3_IsBuffer {
				defer func() {
					templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
					if templ_7745c5c3_Err == nil {
						templ_7745c5c3_Err = templ_7745c5c3_BufErr
					}
				}()
			}
			ctx = templ.InitializeContext(ctx)
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<h1>The request made was invalid</h1>")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			return nil
		})
		templ_7745c5c3_Err = base().Render(templ.WithChildren(ctx, templ_7745c5c3_Var2), templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate


=== views/components/form_elements.templ ===
package components

type FieldProp struct {
	Value string
	Error string
}

type FieldProps map[string]FieldProp

templ InputField(label, name, inputType, placeholder string, required bool, prop FieldProp) {
	<div>
		<label
			for={ name }
		>
			{ label }
		</label>
		<input
			type={ inputType }
			id={ name }
			value={ prop.Value }
			placeholder={ placeholder }
			data-bind={ name }
			if required {
				required
			}
		/>
		if prop.Error != "" {
			<span>{ prop.Error }</span>
		}
	</div>
}

templ Textarea(label, name, placeholder string, required bool, prop FieldProp) {
	<div>
		<label
			for={ name }
		>
			{ label }
		</label>
		<textarea
			id={ name }
			placeholder={ placeholder }
			data-bind={ name }
			if required {
				required
			}
		>
			{ prop.Value }
		</textarea>
		if prop.Error != "" {
			<span>{ prop.Error }</span>
		}
	</div>
}


=== views/components/form_elements_templ.go ===
// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.960
package components

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

type FieldProp struct {
	Value string
	Error string
}

type FieldProps map[string]FieldProp

func InputField(label, name, inputType, placeholder string, required bool, prop FieldProp) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<div><label for=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var2 string
		templ_7745c5c3_Var2, templ_7745c5c3_Err = templ.JoinStringErrs(name)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/form_elements.templ`, Line: 13, Col: 13}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var2))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 2, "\">")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var3 string
		templ_7745c5c3_Var3, templ_7745c5c3_Err = templ.JoinStringErrs(label)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/form_elements.templ`, Line: 15, Col: 10}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var3))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 3, "</label> <input type=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var4 string
		templ_7745c5c3_Var4, templ_7745c5c3_Err = templ.JoinStringErrs(inputType)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/form_elements.templ`, Line: 18, Col: 19}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var4))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 4, "\" id=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var5 string
		templ_7745c5c3_Var5, templ_7745c5c3_Err = templ.JoinStringErrs(name)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/form_elements.templ`, Line: 19, Col: 12}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var5))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 5, "\" value=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var6 string
		templ_7745c5c3_Var6, templ_7745c5c3_Err = templ.JoinStringErrs(prop.Value)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/form_elements.templ`, Line: 20, Col: 21}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var6))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 6, "\" placeholder=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var7 string
		templ_7745c5c3_Var7, templ_7745c5c3_Err = templ.JoinStringErrs(placeholder)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/form_elements.templ`, Line: 21, Col: 28}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var7))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 7, "\" data-bind=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var8 string
		templ_7745c5c3_Var8, templ_7745c5c3_Err = templ.JoinStringErrs(name)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/form_elements.templ`, Line: 22, Col: 19}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var8))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 8, "\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		if required {
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 9, " required")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 10, "> ")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		if prop.Error != "" {
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 11, "<span>")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var9 string
			templ_7745c5c3_Var9, templ_7745c5c3_Err = templ.JoinStringErrs(prop.Error)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/form_elements.templ`, Line: 28, Col: 21}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var9))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 12, "</span>")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 13, "</div>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

func Textarea(label, name, placeholder string, required bool, prop FieldProp) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var10 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var10 == nil {
			templ_7745c5c3_Var10 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 14, "<div><label for=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var11 string
		templ_7745c5c3_Var11, templ_7745c5c3_Err = templ.JoinStringErrs(name)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/form_elements.templ`, Line: 36, Col: 13}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var11))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 15, "\">")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var12 string
		templ_7745c5c3_Var12, templ_7745c5c3_Err = templ.JoinStringErrs(label)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/form_elements.templ`, Line: 38, Col: 10}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var12))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 16, "</label> <textarea id=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var13 string
		templ_7745c5c3_Var13, templ_7745c5c3_Err = templ.JoinStringErrs(name)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/form_elements.templ`, Line: 41, Col: 12}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var13))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 17, "\" placeholder=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var14 string
		templ_7745c5c3_Var14, templ_7745c5c3_Err = templ.JoinStringErrs(placeholder)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/form_elements.templ`, Line: 42, Col: 28}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var14))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 18, "\" data-bind=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var15 string
		templ_7745c5c3_Var15, templ_7745c5c3_Err = templ.JoinStringErrs(name)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/form_elements.templ`, Line: 43, Col: 19}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var15))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 19, "\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		if required {
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 20, " required")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 21, ">")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var16 string
		templ_7745c5c3_Var16, templ_7745c5c3_Err = templ.JoinStringErrs(prop.Value)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/form_elements.templ`, Line: 48, Col: 15}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var16))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 22, "</textarea> ")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		if prop.Error != "" {
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 23, "<span>")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var17 string
			templ_7745c5c3_Var17, templ_7745c5c3_Err = templ.JoinStringErrs(prop.Error)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/form_elements.templ`, Line: 51, Col: 21}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var17))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 24, "</span>")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 25, "</div>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate


=== views/components/head.templ ===
package components

import (
	"context"
	"myorg/webapp/config"
	"myorg/webapp/router/routes"
)

type HeadDataOption func(*HeadData)

type MetaContent struct {
	Content  string
	Name     string
	Property string
}

type HeadData struct {
	siteName           string
	Title              string
	Description        string
	TwitterTitle       string
	TwitterDescription string
	Image              string
	ImageAlt           string
	Slug               string
	canonical          string
	MetaType           string
	stylesheetHref     string
	scriptSrc          string
	ExtraMeta          []MetaContent
}

templ head(data HeadData) {
	<head>
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<meta name="twitter:card" content="summary_large_image"/>
		<meta name="twitter:creator" content="@mbvlabs"/>
		<title>
			{ data.Title }
		</title>
		<link href={ data.stylesheetHref } rel="stylesheet"/>
		<meta property="og:type" content={ data.MetaType }/>
		<meta property="og:title" content={ data.Title }/>
		<meta property="og:description" content={ data.Description }/>
		<meta property="og:url" content={ data.canonical + data.Slug }/>
		<meta property="og:site_name" content={ data.siteName }/>
		<meta property="og:locale" content="en_US"/>
		if data.TwitterTitle != "" && data.TwitterDescription != "" {
			<meta name="twitter:title" content={ data.TwitterTitle }/>
			<meta name="twitter:description" content={ data.TwitterDescription }/>
			if data.Image != "" {
				<meta name="twitter:image" content={ data.Image }/>
			}
		}
		if data.Image != "" {
			<meta property="og:image" content={ data.Image }/>
			<meta property="og:image:alt" content={ data.ImageAlt }/>
		}
		for _, extraMeta := range data.ExtraMeta {
			<meta
				if extraMeta.Name != "" {
					name={ extraMeta.Name }
				}
				if extraMeta.Property != "" {
					property={ extraMeta.Property }
				}
				if extraMeta.Content != "" {
					content={ extraMeta.Content }
				}
			/>
		}
		<meta name="description" content={ data.Description }/>
		<link
			rel="canonical"
			href={ data.canonical + data.Slug }
		/>
		<script src={ data.scriptSrc } type="module"></script>
	</head>
}

func SetupHead(ctx context.Context, opts ...HeadDataOption) templ.Component {

	data := &HeadData{
		siteName:       config.ProjectName,
		Title:          config.ProjectName,
		Description:    "Andurel is the web development framework for Go.",
		Slug:           "/",
		canonical:      config.BaseURL,
		MetaType:       "website",
		stylesheetHref: routes.Stylesheet.URL(),
		scriptSrc:      routes.Scripts.URL(),
	}

	for _, opt := range opts {
		opt(data)
	}

	return head(*data)
}


=== views/components/head_templ.go ===
// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.960
package components

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

import (
	"context"
	"myorg/webapp/config"
	"myorg/webapp/router/routes"
)

type HeadDataOption func(*HeadData)

type MetaContent struct {
	Content  string
	Name     string
	Property string
}

type HeadData struct {
	siteName           string
	Title              string
	Description        string
	TwitterTitle       string
	TwitterDescription string
	Image              string
	ImageAlt           string
	Slug               string
	canonical          string
	MetaType           string
	stylesheetHref     string
	scriptSrc          string
	ExtraMeta          []MetaContent
}

func head(data HeadData) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<head><meta charset=\"UTF-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><meta name=\"twitter:card\" content=\"summary_large_image\"><meta name=\"twitter:creator\" content=\"@mbvlabs\"><title>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var2 string
		templ_7745c5c3_Var2, templ_7745c5c3_Err = templ.JoinStringErrs(data.Title)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/head.templ`, Line: 40, Col: 15}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var2))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 2, "</title><link href=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var3 templ.SafeURL
		templ_7745c5c3_Var3, templ_7745c5c3_Err = templ.JoinURLErrs(data.stylesheetHref)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/head.templ`, Line: 42, Col: 34}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var3))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 3, "\" rel=\"stylesheet\"><meta property=\"og:type\" content=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var4 string
		templ_7745c5c3_Var4, templ_7745c5c3_Err = templ.JoinStringErrs(data.MetaType)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/head.templ`, Line: 43, Col: 50}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var4))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 4, "\"><meta property=\"og:title\" content=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var5 string
		templ_7745c5c3_Var5, templ_7745c5c3_Err = templ.JoinStringErrs(data.Title)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/head.templ`, Line: 44, Col: 48}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var5))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 5, "\"><meta property=\"og:description\" content=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var6 string
		templ_7745c5c3_Var6, templ_7745c5c3_Err = templ.JoinStringErrs(data.Description)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/head.templ`, Line: 45, Col: 60}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var6))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 6, "\"><meta property=\"og:url\" content=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var7 string
		templ_7745c5c3_Var7, templ_7745c5c3_Err = templ.JoinStringErrs(data.canonical + data.Slug)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/head.templ`, Line: 46, Col: 62}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var7))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 7, "\"><meta property=\"og:site_name\" content=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var8 string
		templ_7745c5c3_Var8, templ_7745c5c3_Err = templ.JoinStringErrs(data.siteName)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/head.templ`, Line: 47, Col: 55}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var8))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 8, "\"><meta property=\"og:locale\" content=\"en_US\">")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		if data.TwitterTitle != "" && data.TwitterDescription != "" {
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 9, "<meta name=\"twitter:title\" content=\"")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var9 string
			templ_7745c5c3_Var9, templ_7745c5c3_Err = templ.JoinStringErrs(data.TwitterTitle)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/head.templ`, Line: 50, Col: 57}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var9))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 10, "\"><meta name=\"twitter:description\" content=\"")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var10 string
			templ_7745c5c3_Var10, templ_7745c5c3_Err = templ.JoinStringErrs(data.TwitterDescription)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/head.templ`, Line: 51, Col: 69}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var10))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 11, "\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			if data.Image != "" {
				templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 12, "<meta name=\"twitter:image\" content=\"")
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
				var templ_7745c5c3_Var11 string
				templ_7745c5c3_Var11, templ_7745c5c3_Err = templ.JoinStringErrs(data.Image)
				if templ_7745c5c3_Err != nil {
					return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/head.templ`, Line: 53, Col: 51}
				}
				_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var11))
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
				templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 13, "\">")
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
			}
		}
		if data.Image != "" {
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 14, "<meta property=\"og:image\" content=\"")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var12 string
			templ_7745c5c3_Var12, templ_7745c5c3_Err = templ.JoinStringErrs(data.Image)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/head.templ`, Line: 57, Col: 49}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var12))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 15, "\"><meta property=\"og:image:alt\" content=\"")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var13 string
			templ_7745c5c3_Var13, templ_7745c5c3_Err = templ.JoinStringErrs(data.ImageAlt)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/head.templ`, Line: 58, Col: 56}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var13))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 16, "\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
		}
		for _, extraMeta := range data.ExtraMeta {
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 17, "<meta")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			if extraMeta.Name != "" {
				templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 18, " name=\"")
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
				var templ_7745c5c3_Var14 string
				templ_7745c5c3_Var14, templ_7745c5c3_Err = templ.JoinStringErrs(extraMeta.Name)
				if templ_7745c5c3_Err != nil {
					return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/head.templ`, Line: 63, Col: 26}
				}
				_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var14))
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
				templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 19, "\"")
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
			}
			if extraMeta.Property != "" {
				templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 20, " property=\"")
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
				var templ_7745c5c3_Var15 string
				templ_7745c5c3_Var15, templ_7745c5c3_Err = templ.JoinStringErrs(extraMeta.Property)
				if templ_7745c5c3_Err != nil {
					return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/head.templ`, Line: 66, Col: 34}
				}
				_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var15))
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
				templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 21, "\"")
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
			}
			if extraMeta.Content != "" {
				templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 22, " content=\"")
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
				var templ_7745c5c3_Var16 string
				templ_7745c5c3_Var16, templ_7745c5c3_Err = templ.JoinStringErrs(extraMeta.Content)
				if templ_7745c5c3_Err != nil {
					return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/head.templ`, Line: 69, Col: 32}
				}
				_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var16))
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
				templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 23, "\"")
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 24, ">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 25, "<meta name=\"description\" content=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var17 string
		templ_7745c5c3_Var17, templ_7745c5c3_Err = templ.JoinStringErrs(data.Description)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/head.templ`, Line: 73, Col: 53}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var17))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 26, "\"><link rel=\"canonical\" href=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var18 templ.SafeURL
		templ_7745c5c3_Var18, templ_7745c5c3_Err = templ.JoinURLErrs(data.canonical + data.Slug)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/head.templ`, Line: 76, Col: 36}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var18))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 27, "\"><script src=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var19 string
		templ_7745c5c3_Var19, templ_7745c5c3_Err = templ.JoinStringErrs(data.scriptSrc)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/head.templ`, Line: 78, Col: 30}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var19))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 28, "\" type=\"module\"></script></head>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

func SetupHead(ctx context.Context, opts ...HeadDataOption) templ.Component {

	data := &HeadData{
		siteName:       config.ProjectName,
		Title:          config.ProjectName,
		Description:    "Andurel is the web development framework for Go.",
		Slug:           "/",
		canonical:      config.BaseURL,
		MetaType:       "website",
		stylesheetHref: routes.Stylesheet.URL(),
		scriptSrc:      routes.Scripts.URL(),
	}

	for _, opt := range opts {
		opt(data)
	}

	return head(*data)
}

var _ = templruntime.GeneratedTemplate


=== views/components/toasts.templ ===
package components

import (
	"github.com/dromara/carbon/v2"
	"myorg/webapp/router/cookies"
)

templ toastBase(tType string, flash cookies.FlashMessage) {
	<div
		class="max-w-96 border border-gray-500 rounded bg-black flex flex-col"
		id={ "toast-" + flash.ID.String() }
		data-signals:visible="true"
		data-show="$visible"
		data-init__delay.5000ms="$visible = false"
	>
		<div class="px-4 py-2 flex justify-between items-center border-b-1 border-b-gray-300">
			<div class={ "w-4 h-4 rounded", tType }></div>
			<span class="flex">
				<p class="text-base-content">{ carbon.CreateFromStdTime(flash.CreatedAt).DiffForHumans() }</p>
				<button
					data-on:click="$visible = false"
				>
					<svg class="ml-2 w-4 h-4 fill-white cursor-pointer hover:fill-gray-400" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="100" height="100" viewBox="0 0 30 30">
						<path d="M 7 4 C 6.744125 4 6.4879687 4.0974687 6.2929688 4.2929688 L 4.2929688 6.2929688 C 3.9019687 6.6839688 3.9019687 7.3170313 4.2929688 7.7070312 L 11.585938 15 L 4.2929688 22.292969 C 3.9019687 22.683969 3.9019687 23.317031 4.2929688 23.707031 L 6.2929688 25.707031 C 6.6839688 26.098031 7.3170313 26.098031 7.7070312 25.707031 L 15 18.414062 L 22.292969 25.707031 C 22.682969 26.098031 23.317031 26.098031 23.707031 25.707031 L 25.707031 23.707031 C 26.098031 23.316031 26.098031 22.682969 25.707031 22.292969 L 18.414062 15 L 25.707031 7.7070312 C 26.098031 7.3170312 26.098031 6.6829688 25.707031 6.2929688 L 23.707031 4.2929688 C 23.316031 3.9019687 22.682969 3.9019687 22.292969 4.2929688 L 15 11.585938 L 7.7070312 4.2929688 C 7.5115312 4.0974687 7.255875 4 7 4 z"></path>
					</svg>
				</button>
			</span>
		</div>
		<span class="text-base-content px-4 py-2">
			{ flash.Message }
		</span>
	</div>
}

templ ToastMessage(flash cookies.FlashMessage) {
	switch flash.Type {
		case cookies.FlashSuccess:
			@toastBase("bg-success", flash)
		case cookies.FlashInfo:
			@toastBase("bg-info", flash)
		case cookies.FlashError:
			@toastBase("bg-error", flash)
		case cookies.FlashWarning:
			@toastBase("bg-warning", flash)
	}
}


=== views/components/toasts_templ.go ===
// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.960
package components

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

import (
	"github.com/dromara/carbon/v2"
	"myorg/webapp/router/cookies"
)

func toastBase(tType string, flash cookies.FlashMessage) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<div class=\"max-w-96 border border-gray-500 rounded bg-black flex flex-col\" id=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var2 string
		templ_7745c5c3_Var2, templ_7745c5c3_Err = templ.JoinStringErrs("toast-" + flash.ID.String())
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/toasts.templ`, Line: 11, Col: 35}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var2))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 2, "\" data-signals:visible=\"true\" data-show=\"$visible\" data-init__delay.5000ms=\"$visible = false\"><div class=\"px-4 py-2 flex justify-between items-center border-b-1 border-b-gray-300\">")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var3 = []any{"w-4 h-4 rounded", tType}
		templ_7745c5c3_Err = templ.RenderCSSItems(ctx, templ_7745c5c3_Buffer, templ_7745c5c3_Var3...)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 3, "<div class=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var4 string
		templ_7745c5c3_Var4, templ_7745c5c3_Err = templ.JoinStringErrs(templ.CSSClasses(templ_7745c5c3_Var3).String())
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/toasts.templ`, Line: 1, Col: 0}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var4))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 4, "\"></div><span class=\"flex\"><p class=\"text-base-content\">")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var5 string
		templ_7745c5c3_Var5, templ_7745c5c3_Err = templ.JoinStringErrs(carbon.CreateFromStdTime(flash.CreatedAt).DiffForHumans())
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/toasts.templ`, Line: 19, Col: 92}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var5))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 5, "</p><button data-on:click=\"$visible = false\"><svg class=\"ml-2 w-4 h-4 fill-white cursor-pointer hover:fill-gray-400\" xmlns=\"http://www.w3.org/2000/svg\" x=\"0px\" y=\"0px\" width=\"100\" height=\"100\" viewBox=\"0 0 30 30\"><path d=\"M 7 4 C 6.744125 4 6.4879687 4.0974687 6.2929688 4.2929688 L 4.2929688 6.2929688 C 3.9019687 6.6839688 3.9019687 7.3170313 4.2929688 7.7070312 L 11.585938 15 L 4.2929688 22.292969 C 3.9019687 22.683969 3.9019687 23.317031 4.2929688 23.707031 L 6.2929688 25.707031 C 6.6839688 26.098031 7.3170313 26.098031 7.7070312 25.707031 L 15 18.414062 L 22.292969 25.707031 C 22.682969 26.098031 23.317031 26.098031 23.707031 25.707031 L 25.707031 23.707031 C 26.098031 23.316031 26.098031 22.682969 25.707031 22.292969 L 18.414062 15 L 25.707031 7.7070312 C 26.098031 7.3170312 26.098031 6.6829688 25.707031 6.2929688 L 23.707031 4.2929688 C 23.316031 3.9019687 22.682969 3.9019687 22.292969 4.2929688 L 15 11.585938 L 7.7070312 4.2929688 C 7.5115312 4.0974687 7.255875 4 7 4 z\"></path></svg></button></span></div><span class=\"text-base-content px-4 py-2\">")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var6 string
		templ_7745c5c3_Var6, templ_7745c5c3_Err = templ.JoinStringErrs(flash.Message)
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/toasts.templ`, Line: 30, Col: 18}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var6))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 6, "</span></div>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

func ToastMessage(flash cookies.FlashMessage) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var7 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var7 == nil {
			templ_7745c5c3_Var7 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		switch flash.Type {
		case cookies.FlashSuccess:
			templ_7745c5c3_Err = toastBase("bg-success", flash).Render(ctx, templ_7745c5c3_Buffer)
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
		case cookies.FlashInfo:
			templ_7745c5c3_Err = toastBase("bg-info", flash).Render(ctx, templ_7745c5c3_Buffer)
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
		case cookies.FlashError:
			templ_7745c5c3_Err = toastBase("bg-error", flash).Render(ctx, templ_7745c5c3_Buffer)
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
		case cookies.FlashWarning:
			templ_7745c5c3_Err = toastBase("bg-warning", flash).Render(ctx, templ_7745c5c3_Buffer)
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate


=== views/datastar.go ===
package views

import (
	"fmt"
	"strings"
)

type DataActionOption string

var ActionTypeForm DataActionOption = "contentType: 'form'"

func ActionHeaders(headers map[string]string) DataActionOption {
	var headerPairs []string
	for key, value := range headers {
		headerPairs = append(headerPairs, fmt.Sprintf("'%s': '%s'", key, value))
	}
	return DataActionOption(fmt.Sprintf("headers: { %s }", strings.Join(headerPairs, ", ")))
}

func ActionSignalsFilter(signals map[string]string) DataActionOption {
	var headerPairs []string
	for key, value := range signals {
		headerPairs = append(headerPairs, fmt.Sprintf("%s: %s", key, value))
	}
	return DataActionOption(fmt.Sprintf("filterSignals: { %s }", strings.Join(headerPairs, ", ")))
}

func DataAction(method, route string, options ...DataActionOption) string {
	if len(options) > 0 {
		var opts []string
		for _, opt := range options {
			opts = append(opts, string(opt))
		}
		options := strings.Join(opts, ", ")

		return fmt.Sprintf(
			"@%s('%s', %s)",
			strings.ToLower(method),
			route,
			fmt.Sprintf("{ %s }", options),
		)
	}

	return fmt.Sprintf("@%s('%s')", strings.ToLower(method), route)
}


=== views/home.templ ===
package views

templ Home() {
	@base() {
		<main class="container mx-auto flex-1 flex flex-col items-center justify-center p-4">
			<h1 class="text-2xl font-bold">Welcome to the Andurel Framework!</h1>
			<p>This is a simple home page template to get you started.</p>
		</main>
	}
}


=== views/home_templ.go ===
// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.960
package views

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func Home() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Var2 := templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
			templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
			templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
			if !templ_7745c5c3_IsBuffer {
				defer func() {
					templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
					if templ_7745c5c3_Err == nil {
						templ_7745c5c3_Err = templ_7745c5c3_BufErr
					}
				}()
			}
			ctx = templ.InitializeContext(ctx)
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<main class=\"container mx-auto flex-1 flex flex-col items-center justify-center p-4\"><h1 class=\"text-2xl font-bold\">Welcome to the Andurel Framework!</h1><p>This is a simple home page template to get you started.</p></main>")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			return nil
		})
		templ_7745c5c3_Err = base().Render(templ.WithChildren(ctx, templ_7745c5c3_Var2), templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate


=== views/internal_error.templ ===
package views

templ InternalError() {
	@base() {
		<h1>something went wrong on our end.</h1>
	}
}


=== views/internal_error_templ.go ===
// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.960
package views

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func InternalError() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Var2 := templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
			templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
			templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
			if !templ_7745c5c3_IsBuffer {
				defer func() {
					templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
					if templ_7745c5c3_Err == nil {
						templ_7745c5c3_Err = templ_7745c5c3_BufErr
					}
				}()
			}
			ctx = templ.InitializeContext(ctx)
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<h1>something went wrong on our end.</h1>")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			return nil
		})
		templ_7745c5c3_Err = base().Render(templ.WithChildren(ctx, templ_7745c5c3_Var2), templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate


=== views/layout.templ ===
package views

import (
	"myorg/webapp/router/cookies"
	"myorg/webapp/views/components"
)

templ base(headOpts ...components.HeadDataOption) {
	<!DOCTYPE html>
	<html lang="en">
		@components.SetupHead(ctx, headOpts...)
		<body class="min-h-screen flex flex-col bg-base-200 text-base-content">
			{ children... }
		</body>
		<div id="flashContainer" class="fixed top-4 right-4 z-50 space-y-2">
			for _, flash := range cookies.GetFlashesCtx(ctx) {
				@components.ToastMessage(flash)
			}
		</div>
	</html>
}


=== views/layout_templ.go ===
// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.960
package views

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

import (
	"myorg/webapp/router/cookies"
	"myorg/webapp/views/components"
)

func base(headOpts ...components.HeadDataOption) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<!doctype html><html lang=\"en\">")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = components.SetupHead(ctx, headOpts...).Render(ctx, templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 2, "<body class=\"min-h-screen flex flex-col bg-base-200 text-base-content\">")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templ_7745c5c3_Var1.Render(ctx, templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 3, "</body><div id=\"flashContainer\" class=\"fixed top-4 right-4 z-50 space-y-2\">")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		for _, flash := range cookies.GetFlashesCtx(ctx) {
			templ_7745c5c3_Err = components.ToastMessage(flash).Render(ctx, templ_7745c5c3_Buffer)
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 4, "</div></html>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate


=== views/not_found.templ ===
package views

templ NotFound() {
	@base() {
		<h1>Not found</h1>
	}
}


=== views/not_found_templ.go ===
// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.960
package views

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func NotFound() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Var2 := templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
			templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
			templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
			if !templ_7745c5c3_IsBuffer {
				defer func() {
					templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
					if templ_7745c5c3_Err == nil {
						templ_7745c5c3_Err = templ_7745c5c3_BufErr
					}
				}()
			}
			ctx = templ.InitializeContext(ctx)
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<h1>Not found</h1>")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			return nil
		})
		templ_7745c5c3_Err = base().Render(templ.WithChildren(ctx, templ_7745c5c3_Var2), templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate


