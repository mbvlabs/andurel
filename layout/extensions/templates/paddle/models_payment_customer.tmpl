{{- if eq .Database "postgresql" }}
package models

import (
	"context"
	"time"

	"github.com/google/uuid"

	"{{.ModuleName}}/models/internal/db"
)

type PaymentCustomer struct {
	ID               uuid.UUID
	CreatedAt        time.Time
	UpdatedAt        time.Time
	UserID           uuid.UUID
	ProviderCustomerID string
	Email            string
}

func FindPaymentCustomerByUserID(
	ctx context.Context,
	dbtx db.DBTX,
	userID uuid.UUID,
) (PaddleCustomer, error) {
	row, err := queries.QueryPaymentCustomerByUserID(ctx, dbtx, userID)
	if err != nil {
		return PaddleCustomer{}, err
	}

	return rowToPaymentCustomer(row)
}

func FindPaymentCustomerByProviderID(
	ctx context.Context,
	dbtx db.DBTX,
	paddleCustomerID string,
) (PaddleCustomer, error) {
	row, err := queries.QueryPaymentCustomerByProviderID(ctx, dbtx, paddleCustomerID)
	if err != nil {
		return PaddleCustomer{}, err
	}

	return rowToPaymentCustomer(row)
}

type CreatePaymentCustomerData struct {
	UserID           uuid.UUID
	ProviderCustomerID string
	Email            string
}

func CreatePaymentCustomer(
	ctx context.Context,
	dbtx db.DBTX,
	data CreatePaymentCustomerData,
) (PaddleCustomer, error) {
	params := db.CreateInsertPaymentCustomerParams(
		uuid.New(),
		data.UserID,
		data.ProviderCustomerID,
		data.Email,
	)

	row, err := queries.InsertPaymentCustomer(ctx, dbtx, params)
	if err != nil {
		return PaddleCustomer{}, err
	}

	return rowToPaymentCustomer(row)
}

func rowToPaymentCustomer(row db.PaymentCustomer) (PaddleCustomer, error) {
	return PaddleCustomer{
		ID:               row.ID,
		CreatedAt:        row.CreatedAt.Time,
		UpdatedAt:        row.UpdatedAt.Time,
		UserID:           row.UserID,
		ProviderCustomerID: row.ProviderCustomerID,
		Email:            row.Email,
	}, nil
}
{{- else if eq .Database "sqlite" }}
package models

import (
	"context"
	"time"

	"github.com/google/uuid"

	"{{.ModuleName}}/models/internal/db"
)

type PaymentCustomer struct {
	ID               uuid.UUID
	CreatedAt        time.Time
	UpdatedAt        time.Time
	UserID           uuid.UUID
	ProviderCustomerID string
	Email            string
}

func FindPaymentCustomerByUserID(
	ctx context.Context,
	dbtx db.DBTX,
	userID uuid.UUID,
) (PaddleCustomer, error) {
	row, err := queries.QueryPaymentCustomerByUserID(ctx, dbtx, userID.String())
	if err != nil {
		return PaddleCustomer{}, err
	}

	return rowToPaymentCustomer(row)
}

func FindPaymentCustomerByProviderID(
	ctx context.Context,
	dbtx db.DBTX,
	paddleCustomerID string,
) (PaddleCustomer, error) {
	row, err := queries.QueryPaymentCustomerByProviderID(ctx, dbtx, paddleCustomerID)
	if err != nil {
		return PaddleCustomer{}, err
	}

	return rowToPaymentCustomer(row)
}

type CreatePaymentCustomerData struct {
	UserID           uuid.UUID
	ProviderCustomerID string
	Email            string
}

func CreatePaymentCustomer(
	ctx context.Context,
	dbtx db.DBTX,
	data CreatePaymentCustomerData,
) (PaddleCustomer, error) {
	params := db.CreateInsertPaymentCustomerParams(
		uuid.New().String(),
		data.UserID.String(),
		data.ProviderCustomerID,
		data.Email,
	)

	row, err := queries.InsertPaymentCustomer(ctx, dbtx, params)
	if err != nil {
		return PaddleCustomer{}, err
	}

	return rowToPaymentCustomer(row)
}

func rowToPaymentCustomer(row db.PaymentCustomer) (PaddleCustomer, error) {
	id, err := uuid.Parse(row.ID)
	if err != nil {
		return PaddleCustomer{}, err
	}

	userID, err := uuid.Parse(row.UserID)
	if err != nil {
		return PaddleCustomer{}, err
	}

	return PaddleCustomer{
		ID:               id,
		CreatedAt:        row.CreatedAt,
		UpdatedAt:        row.UpdatedAt,
		UserID:           userID,
		ProviderCustomerID: row.ProviderCustomerID,
		Email:            row.Email,
	}, nil
}
{{- end }}
