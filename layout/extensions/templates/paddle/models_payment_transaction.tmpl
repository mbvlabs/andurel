package models

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"

	"{{.ModuleName}}/models/internal/db"
	"{{.ModuleName}}/internal/storage"
)

type PaymentTransaction struct {
	ID                   uuid.UUID
	CreatedAt            time.Time
	UpdatedAt            time.Time
	ProviderTransactionID  string
	ProviderCustomerID     string
	Status               string
	Amount               string
	Currency             string
	InvoiceNumber        string
	BilledAt             time.Time
	CompletedAt          time.Time
	RawData              []byte
}

func FindPaymentTransactionByID(
	ctx context.Context,
	exec storage.Executor,
	id uuid.UUID,
) (PaymentTransaction, error) {
	row, err := queries.QueryPaymentTransactionByID(ctx, exec, id)
	if err != nil {
		return PaymentTransaction{}, err
	}

	return rowToPaymentTransaction(row)
}

func FindPaymentTransactionByProviderID(
	ctx context.Context,
	exec storage.Executor,
	paddleTransactionID string,
) (PaymentTransaction, error) {
	row, err := queries.QueryPaymentTransactionByProviderID(ctx, exec, paddleTransactionID)
	if err != nil {
		return PaymentTransaction{}, err
	}

	return rowToPaymentTransaction(row)
}

type CreatePaymentTransactionData struct {
	ProviderTransactionID string
	ProviderCustomerID    string
	Status                string
	Amount              string
	Currency            string
	InvoiceNumber       string
	BilledAt            time.Time
	CompletedAt         time.Time
	RawData             []byte
}

func CreatePaymentTransaction(
	ctx context.Context,
	exec storage.Executor,
	data CreatePaymentTransactionData,
) (PaymentTransaction, error) {
	params := db.BuildInsertPaymentTransactionParams(
		uuid.New(),
		data.ProviderTransactionID,
		data.ProviderCustomerID,
		data.Status,
		data.Amount,
		data.Currency,
		sql.NullString{String: data.InvoiceNumber, Valid: data.InvoiceNumber != ""},
		sql.NullTime{Time: data.BilledAt, Valid: !data.BilledAt.IsZero()},
		sql.NullTime{Time: data.CompletedAt, Valid: !data.CompletedAt.IsZero()},
		data.RawData,
	)

	row, err := queries.InsertPaymentTransaction(ctx, exec, params)
	if err != nil {
		return PaymentTransaction{}, err
	}

	return rowToPaymentTransaction(row)
}

func UpdatePaymentTransactionStatus(
	ctx context.Context,
	exec storage.Executor,
	paddleTransactionID string,
	status string,
	completedAt time.Time,
) (PaymentTransaction, error) {
	params := db.BuildUpdatePaymentTransactionStatusParams(
		paddleTransactionID,
		status,
		sql.NullTime{Time: completedAt, Valid: !completedAt.IsZero()},
	)

	row, err := queries.UpdatePaymentTransactionStatus(ctx, exec, params)
	if err != nil {
		return PaymentTransaction{}, err
	}

	return rowToPaymentTransaction(row)
}

func rowToPaymentTransaction(row db.PaymentTransaction) (PaymentTransaction, error) {
	return PaymentTransaction{
		ID:                    row.ID,
		CreatedAt:             row.CreatedAt.Time,
		UpdatedAt:             row.UpdatedAt.Time,
		ProviderTransactionID: row.ProviderTransactionID,
		ProviderCustomerID:    row.ProviderCustomerID,
		Status:                row.Status,
		Amount:                row.Amount,
		Currency:              row.Currency,
		InvoiceNumber:         row.InvoiceNumber.String,
		BilledAt:              row.BilledAt.Time,
		CompletedAt:           row.CompletedAt.Time,
		RawData:               row.RawData,
	}, nil
}
