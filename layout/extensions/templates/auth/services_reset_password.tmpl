package services

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"{{.ModuleName}}/config"
	"{{.ModuleName}}/database"
	"{{.ModuleName}}/email"
	"{{.ModuleName}}/models"
	"{{.ModuleName}}/router/routes"
)

const userResetPassword = "user_password_reset"

var (
	ErrInvalidResetCode = errors.New("invalid reset code")
	ErrExpiredResetCode = errors.New("reset code has expired")
)

type RequestResetPasswordData struct {
	Email string
}

func RequestResetPassword(
	ctx context.Context,
{{- if eq .Database "postgresql" }}
	db database.Postgres,
{{- else if eq .Database "sqlite" }}
	db database.SQLite,
{{- end }}
	salt string,
	emailClient email.Client,
	data RequestResetPasswordData,
) error {
	tx, err := db.BeginTx(ctx)
	if err != nil {
		return err
	}
{{- if eq .Database "postgresql" }}
	defer tx.Rollback(ctx)
{{- else if eq .Database "sqlite" }}
	defer tx.Rollback()
{{- end }}

	user, err := models.FindUserByEmail(ctx, tx, data.Email)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}
		return err
	}

	meta, err := json.Marshal(map[string]string{
		"email": user.Email,
	})
	if err != nil {
		return err
	}

	token, err := models.CreateToken(
		ctx,
		tx,
		salt,
		userResetPassword,
		time.Now().Add(1*time.Hour), // 1 hour expiry
		meta,
	)
	if err != nil {
		return err
	}

	resetURL := fmt.Sprintf("%s%s", config.Domain, routes.PasswordEdit.GetPath(token))

	if err := emailClient.SendResetPasswordEmail(ctx, user.Email, resetURL); err != nil {
		return err
	}

{{- if eq .Database "postgresql" }}
	return tx.Commit(ctx)
{{- else if eq .Database "sqlite" }}
	return tx.Commit()
{{- end }}
}

type ResetPasswordData struct {
	Token           string
	Password        string
	ConfirmPassword string
}

func ResetPassword(
	ctx context.Context,
{{- if eq .Database "postgresql" }}
	db database.Postgres,
{{- else if eq .Database "sqlite" }}
	db database.SQLite,
{{- end }}
	salt string,
	data ResetPasswordData,
) error {
	tx, err := db.BeginTx(ctx)
	if err != nil {
		return err
	}
{{- if eq .Database "postgresql" }}
	defer tx.Rollback(ctx)
{{- else if eq .Database "sqlite" }}
	defer tx.Rollback()
{{- end }}

	if data.Password != data.ConfirmPassword {
		return errors.New("passwords do not match")
	}

	if len(data.Password) < 8 {
		return errors.New("password must be at least 8 characters")
	}

	token, err := models.FindTokenByScopeAndHash(
		ctx,
		tx,
		salt,
		userResetPassword,
		data.Token,
	)
	if err != nil {
		return ErrInvalidResetCode
	}

	if !token.IsValid() {
		return ErrExpiredResetCode
	}

	var meta map[string]string
	if err := json.Unmarshal(token.MetaData, &meta); err != nil {
		return err
	}

	email, ok := meta["email"]
	if !ok {
		return errors.New("token metadata missing email")
	}

	user, err := models.FindUserByEmail(ctx, tx, email)
	if err != nil {
		return err
	}

	hashedPassword := models.HashToken(data.Password, salt)

	_, err = models.UpdateUser(ctx, tx, models.UpdateUserData{
		ID:    user.ID,
		Email: user.Email,
		EmailValidatedAt: sql.NullTime{
			Time:  user.EmailValidatedAt,
			Valid: !user.EmailValidatedAt.IsZero(),
		},
		Password: hashedPassword,
		IsAdmin:  user.IsAdmin,
	})
	if err != nil {
		return err
	}

	if err := models.DestroyToken(ctx, tx, token.ID); err != nil {
		return err
	}

{{- if eq .Database "postgresql" }}
	return tx.Commit(ctx)
{{- else if eq .Database "sqlite" }}
	return tx.Commit()
{{- end }}
}
