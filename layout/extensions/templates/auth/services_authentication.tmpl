package services

import (
	"bytes"
	"context"
	"database/sql"
	"errors"

	"{{.ModuleName}}/database"
	"{{.ModuleName}}/models"
)

var (
	ErrInvalidCredentials = errors.New("invalid email or password")
	ErrEmailNotVerified   = errors.New("email not verified")
)

type LoginData struct {
	Email    string
	Password string
}

func AuthenticateUser(
	ctx context.Context,
{{- if eq .Database "postgresql" }}
	db database.Postgres,
{{- else if eq .Database "sqlite" }}
	db database.SQLite,
{{- end }}
	salt string,
	data LoginData,
) (models.User, error) {
	tx, err := db.BeginTx(ctx)
	if err != nil {
		return models.User{}, err
	}
{{- if eq .Database "postgresql" }}
	defer tx.Rollback(ctx)
{{- else if eq .Database "sqlite" }}
	defer tx.Rollback()
{{- end }}

	user, err := models.FindUserByEmail(ctx, tx, data.Email)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return models.User{}, ErrInvalidCredentials
		}
		return models.User{}, err
	}

	hashedPassword := models.HashToken(data.Password, salt)
	if !bytes.Equal(user.Password, hashedPassword) {
		return models.User{}, ErrInvalidCredentials
	}

	if user.EmailValidatedAt.IsZero() {
		return models.User{}, ErrEmailNotVerified
	}

{{- if eq .Database "postgresql" }}
	if err := tx.Commit(ctx); err != nil {
{{- else if eq .Database "sqlite" }}
	if err := tx.Commit(); err != nil {
{{- end }}
		return models.User{}, err
	}

	return user, nil
}
