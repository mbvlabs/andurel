package services

import (
{{- if eq .Database "sqlite" }}
	"bytes"
{{- end }}
	"context"
	"database/sql"
	"errors"

	"{{.ModuleName}}/database"
	"{{.ModuleName}}/models"
)

var (
	ErrInvalidCredentials = errors.New("invalid email or password")
	ErrEmailNotVerified   = errors.New("email not verified")
)

type LoginData struct {
	Email    string
	Password string
}

func AuthenticateUser(
	ctx context.Context,
{{- if eq .Database "postgresql" }}
	db database.Postgres,
{{- else if eq .Database "sqlite" }}
	db database.SQLite,
{{- end }}
	salt string,
	data LoginData,
) (models.User, error) {
{{- if eq .Database "postgresql" }}
	user, err := models.FindUserByEmail(ctx, db.Conn(), data.Email)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return models.User{}, ErrInvalidCredentials
		}

		return models.User{}, err
	}

	validPassword, err := user.ValidPassword(data.Password, salt)
	if err != nil {
		return models.User{}, err
	}

	if !validPassword {
		return models.User{}, errors.New("invalid password")
	}

	if user.EmailValidatedAt.IsZero() {
		return models.User{}, ErrEmailNotVerified
	}

	return user, nil
{{- else if eq .Database "sqlite" }}
	tx, err := db.BeginTx(ctx)
	if err != nil {
		return models.User{}, err
	}
	defer tx.Rollback()

	user, err := models.FindUserByEmail(ctx, tx, data.Email)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return models.User{}, ErrInvalidCredentials
		}
		return models.User{}, err
	}

	hashedPassword := models.HashToken(data.Password, salt)
	if !bytes.Equal(user.Password, hashedPassword) {
		return models.User{}, ErrInvalidCredentials
	}

	if user.EmailValidatedAt.IsZero() {
		return models.User{}, ErrEmailNotVerified
	}

	if err := tx.Commit(); err != nil {
		return models.User{}, err
	}

	return user, nil
{{- end }}
}
