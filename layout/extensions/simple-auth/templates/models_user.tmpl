package models

import (
	"context"
	"crypto/subtle"
	"errors"
	"fmt"
	"time"

	"{{.ModuleName}}/models/internal/db"

	"github.com/google/uuid"
	"golang.org/x/crypto/argon2"
{{if eq .Database "postgresql"}}
	"github.com/jackc/pgx/v5/pgtype"
{{end}}
)

type User struct {
	ID        uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
	Email     string
	IsAdmin   bool
	Password  []byte
}

type CreateUserPayload struct {
	Email    string `validate:"required,email,max=255"`
	Password string `validate:"required,min=8,max=72"`
}

func HashPassword(password, salt string) []byte {
	return argon2.IDKey(
		[]byte(password),
		[]byte(salt),
		2,
		19*1024,
		1,
		32,
	)
}

func (u User) ValidatePassword(providedPassword, salt string) error {
	if t := subtle.ConstantTimeCompare(HashPassword(providedPassword, salt), []byte(u.Password)); t == 1 {
		return nil
	}

	return errors.New("invalid password")
}

func VerifyPassword(hashedPassword []byte, plainPassword string) bool {
	if len(hashedPassword) < 16 {
		return false
	}

	salt := hashedPassword[:16]
	storedHash := hashedPassword[16:]

	computedHash := argon2.IDKey([]byte(plainPassword), salt, 2, 19456, 1, 32)

	return subtle.ConstantTimeCompare(storedHash, computedHash) == 1
}

type PasswordPair struct {
	Password        string `validate:"required,gte=6"`
	ConfirmPassword string `validate:"required,gte=6"`
}

type NewUserPayload struct {
	Email        string `validate:"required,email"`
	PasswordPair PasswordPair
}

func NewUser(
	ctx context.Context,
	dbtx db.DBTX,
	passwordSalt string,
	payload NewUserPayload,
) (User, error) {
	if err := validate.Struct(payload); err != nil {
		return User{}, fmt.Errorf("validation failed: %w", err)
	}

	dbUser, err := db.New().CreateUser(ctx, dbtx, db.CreateUserParams{
		ID:            uuid.New().String(),
		Email:         payload.Email,
		Password:      HashPassword(payload.PasswordPair.Password, passwordSalt),
		EmailVerified: 0,
		IsAdmin:       0,
	})
	if err != nil {
		return User{}, fmt.Errorf("failed to create user: %w", err)
	}

	return rowToUser(dbUser)
}

func FincUserByEmail(ctx context.Context, dbtx db.DBTX, email string) (User, error) {
	dbUser, err := db.New().GetUserByEmail(ctx, dbtx, email)
	if err != nil {
		return User{}, fmt.Errorf("failed to get user by email: %w", err)
	}

	return rowToUser(dbUser)
}

func FindUser(ctx context.Context, dbtx db.DBTX, userID uuid.UUID) (User, error) {
	dbUser, err := db.New().GetUserByID(ctx, dbtx, userID.String())
	if err != nil {
		return User{}, fmt.Errorf("failed to get user by ID: %w", err)
	}

	return rowToUser(dbUser)
}

func rowToUser(row db.User) (User, error) {
	id, err := uuid.Parse(row.ID)
	if err != nil {
		return User{}, err
	}

	return User{
		ID:        id,
		CreatedAt: row.CreatedAt,
		UpdatedAt: row.UpdatedAt,
		Email:     row.Email,
		IsAdmin:   row.IsAdmin == 1,
		Password:  row.Password,
	}, nil
}
