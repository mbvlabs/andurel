// Package router provides the application routes and middleware setup.
package router

import (
	"context"
	"encoding/gob"
	"errors"
	"net/http"
	"strings"

	"{{.ModuleName}}/config"
	"{{.ModuleName}}/controllers"
	"{{.ModuleName}}/internal/server"
	"{{.ModuleName}}/router/cookies"
	"{{.ModuleName}}/router/middleware"
	"{{.ModuleName}}/router/routes"
	"{{.ModuleName}}/telemetry"

	"github.com/google/uuid"
	"github.com/gorilla/sessions"
	"github.com/labstack/echo-contrib/session"
	"github.com/labstack/echo/v5"
	"go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"

	echomw "github.com/labstack/echo/v5/middleware"
)

type Router struct {
	Handler     *echo.Echo
	HTTPHandler http.Handler
}

func New(
	ctx context.Context,
	cfg config.Config,
	enableHTTPInstrumentation bool,
	globalMiddleware []echo.MiddlewareFunc,
) (*Router, error) {
	_ = ctx
	_ = cfg
	gob.Register(uuid.UUID{})
	gob.Register(cookies.FlashMessage{})

	router := echo.New()

	if config.Env != server.ProdEnvironment {
		router.Debug = true
	}

	router.Use(globalMiddleware...)

	httpHandler := http.Handler(router)
	if enableHTTPInstrumentation {
		httpHandler = otelhttp.NewHandler(router, "http")
	}

	return &Router{
		Handler:     router,
		HTTPHandler: httpHandler,
	}, nil
}

func SetupGlobalMiddleware(
	cfg config.Config,
	tel *telemetry.Telemetry,
	authKey []byte,
	encKey []byte,
	mw middleware.Middleware,
	csrfName string,
) []echo.MiddlewareFunc {
	return []echo.MiddlewareFunc{
		mw.TraceRouteAttributes(tel),
		mw.Logger(tel),
		session.Middleware(
			sessions.NewCookieStore(
				authKey,
				encKey,
			),
		),
		mw.ValidateSession,
		mw.RegisterAppContext,
		mw.RegisterFlashMessagesContext,
		echomw.CORSWithConfig(echomw.CORSConfig{
			AllowOrigins:     []string{"https://*", "http://*"},
			AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"},
			AllowHeaders:     []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
			AllowCredentials: true,
			MaxAge:           300,
		}),
		echomw.CSRFWithConfig(
			echomw.CSRFConfig{
				Skipper: func(c *echo.Context) bool {
					return strings.Contains(c.Request().URL.Path, routes.APIPrefix) ||
						strings.Contains(c.Request().URL.Path, routes.AssetsPrefix)
				}, TokenLookup: "cookie:" + csrfName, CookiePath: "/", CookieDomain: func() string {
					if config.Env == server.ProdEnvironment {
						return config.Domain
					}

					return ""
				}(), CookieSecure: config.Env == server.ProdEnvironment, CookieHTTPOnly: true, CookieSameSite: http.SameSiteStrictMode,
			}),

		echomw.Recover(),
	}
}

func (r *Router) RegisterCtrlRoutes(
	mw middleware.Middleware,
{{- range .Blueprint.Controllers.SortedConstructors}}
	{{.VarName}} {{.Type}},
{{- end}}
) error {
	errs := []error{}

	err := registerAPIRoutes(r.Handler, api)
	if err != nil {
		errs = append(errs, err)
	}

	err = registerAssetsRoutes(r.Handler, assets)
	if err != nil {
		errs = append(errs, err)
	}

	err = registerPagesRoutes(r.Handler, pages)
	if err != nil {
		errs = append(errs, err)
	}

	err = registerSessionsRoutes(r.Handler, sessions)
	if err != nil {
		errs = append(errs, err)
	}

	err = registerRegistrationsRoutes(r.Handler, registrations)
	if err != nil {
		errs = append(errs, err)
	}

	err = registerConfirmationsRoutes(r.Handler, confirmations)
	if err != nil {
		errs = append(errs, err)
	}

	err = registerResetPasswordsRoutes(r.Handler, resetPasswords)
	if err != nil {
		errs = append(errs, err)
	}
{{- range .Blueprint.Routes.SortedRegistrationFunctions}}

	err = {{.FunctionName}}(r.Handler, {{.ControllerVarName}})
	if err != nil {
		errs = append(errs, err)
	}
{{- end}}

	return errors.Join(errs...)
}

func (r *Router) RegisterCustomRoutes(
	riverHandler interface{ ServeHTTP(http.ResponseWriter, *http.Request) },
	notFoundHandler echo.HandlerFunc,
) {
	r.Handler.Any("/riverui*", echo.WrapHandler(riverHandler))
	r.Handler.RouteNotFound("/*", notFoundHandler)
}
