// Package router provides the application routes and middleware setup.
package router

import (
	"context"
	"encoding/gob"
	"encoding/hex"
	"log/slog"
	"net/http"
	"strings"
	"time"

	"{{.ModuleName}}/config"
	"{{.ModuleName}}/controllers"
	"{{.ModuleName}}/pkg/telemetry"
	"{{.ModuleName}}/router/cookies"
	"{{.ModuleName}}/router/routes"

	"github.com/google/uuid"
	"github.com/gorilla/sessions"
	"github.com/labstack/echo-contrib/session"
	"github.com/labstack/echo/v4"
	"go.opentelemetry.io/contrib/instrumentation/github.com/labstack/echo/otelecho"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
{{- if eq .Database "postgresql"}}
	"riverqueue.com/riverui"
{{- end}}

	echomw "github.com/labstack/echo/v4/middleware"
)

type Router struct {
	Handler     *echo.Echo
	controllers controllers.Controllers
	telemetry   *telemetry.Telemetry
}

func New(
	ctx context.Context,
	controllers controllers.Controllers,
	cfg config.Config,
	tel *telemetry.Telemetry,
{{- if eq .Database "postgresql"}}
	riverHandler *riverui.Handler,
{{- end}}
) (*Router, error) {
	gob.Register(uuid.UUID{})
	gob.Register(cookies.FlashMessage{})

	router := echo.New()

	if config.Env != config.ProdEnvironment {
		router.Debug = true
	}

	authKey, err := hex.DecodeString(cfg.App.SessionKey)
	if err != nil {
		return nil, err
	}
	encKey, err := hex.DecodeString(cfg.App.SessionEncryptionKey)
	if err != nil {
		return nil, err
	}

	//csrfName := strings.ToLower(config.ProjectName) + "_" + "dev_csrf"
	//if config.Env == config.ProdEnvironment {
	//	csrfName = strings.ToLower(config.ProjectName) + "_" + "csrf"
	//}
	// TODO: make changing name work with d-*
	csrfName := "_csrf"

	middleware := []echo.MiddlewareFunc{
		otelecho.Middleware(config.ServiceName),
		logger(tel),
		session.Middleware(
			sessions.NewCookieStore(
				authKey,
				encKey,
			),
		),
		registerAppContext,
		registerFlashMessagesContext,

		echomw.CSRFWithConfig(echomw.CSRFConfig{Skipper: func(c echo.Context) bool {
			return strings.HasPrefix(c.Request().URL.Path, routes.APIRoutePrefix) ||
				strings.HasPrefix(c.Request().URL.Path, routes.AssetsRoutePrefix)
		}, TokenLookup: "cookie:" + csrfName, CookiePath: "/", CookieDomain: func() string {
			if config.Env == config.ProdEnvironment {
				return config.Domain
			}

			return ""
		}(), CookieSecure: config.Env == config.ProdEnvironment, CookieHTTPOnly: true, CookieSameSite: http.SameSiteStrictMode}),

		echomw.Recover(),
	}

	router.Use(middleware...)

{{- if eq .Database "postgresql"}}
	router.Any("/riverui*", echo.WrapHandler(riverHandler))
{{- end}}

	registrar(router, controllers)

	return &Router{
		router,
		controllers,
		tel,
	}, nil
}

func registerAppContext(
	next echo.HandlerFunc,
) echo.HandlerFunc {
	return func(c echo.Context) error {
		if strings.HasPrefix(c.Request().URL.Path, routes.AssetsRoutePrefix) ||
			strings.HasPrefix(c.Request().URL.Path, routes.APIRoutePrefix) {
			return next(c)
		}

		c.Set(string(cookies.AppKey), cookies.GetApp(c))

		return next(c)
	}
}

func registerFlashMessagesContext(
	next echo.HandlerFunc,
) echo.HandlerFunc {
	return func(c echo.Context) error {
		if strings.HasPrefix(c.Request().URL.Path, routes.AssetsRoutePrefix) ||
			strings.HasPrefix(c.Request().URL.Path, routes.APIRoutePrefix) {
			return next(c)
		}

		flashes, err := cookies.GetFlashes(c)
		if err != nil {
			slog.Error("Error getting flash messages from session", "error", err)
			return next(c)
		}

		c.Set(string(cookies.FlashKey), flashes)

		return next(c)
	}
}


func logger(tel *telemetry.Telemetry) echo.MiddlewareFunc {
	var httpRequestsTotal metric.Int64Counter
	var httpDuration metric.Float64Histogram
	var httpInFlight metric.Int64UpDownCounter

	if tel.HasMetrics() {
		var err error
		httpRequestsTotal, err = telemetry.HTTPRequestsTotal()
		if err != nil {
			slog.Warn("failed to create http_requests_total metric", "error", err)
		}
		httpDuration, err = telemetry.HTTPRequestDuration()
		if err != nil {
			slog.Warn("failed to create http_request_duration metric", "error", err)
		}
		httpInFlight, err = telemetry.HTTPRequestsInFlight()
		if err != nil {
			slog.Warn("failed to create http_requests_in_flight metric", "error", err)
		}

		meter := telemetry.GetMeter(config.ServiceName)
		if err := telemetry.SetupRuntimeMetricsInCallback(meter); err != nil {
			slog.Warn("failed to setup runtime metrics", "error", err)
		}
	}

	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			if strings.Contains(c.Request().URL.Path, routes.APIRoutePrefix) ||
				strings.Contains(c.Request().URL.Path, routes.AssetsRoutePrefix) {
				return next(c)
			}

			ctx := c.Request().Context()
			start := time.Now()

			if tel.HasMetrics() && httpInFlight != nil {
				httpInFlight.Add(ctx, 1)
				defer httpInFlight.Add(ctx, -1)
			}

			err := next(c)
			duration := time.Since(start)
			statusCode := c.Response().Status

			if tel.HasMetrics() && httpRequestsTotal != nil && httpDuration != nil {
				attrs := []attribute.KeyValue{
					attribute.String("method", c.Request().Method),
					attribute.String("route", c.Path()),
					attribute.Int("status_code", statusCode),
				}
				httpRequestsTotal.Add(ctx, 1, metric.WithAttributes(attrs...))
				httpDuration.Record(ctx, duration.Seconds(), metric.WithAttributes(attrs...))
			}

			slog.InfoContext(ctx, "HTTP request completed",
				"method", c.Request().Method,
				"path", c.Request().URL.Path,
				"status", statusCode,
				"remote_addr", c.RealIP(),
				"user_agent", c.Request().UserAgent(),
				"duration", duration.String(),
			)

			return err
		}
	}
}
