// Package router provides the application routes and middleware setup.
package router

import (
	"context"
	"encoding/gob"
	"encoding/hex"
	"fmt"
	"log/slog"
	"net/http"
	"reflect"
	"slices"
	"strings"

	"{{.ModuleName}}/config"
	"{{.ModuleName}}/controllers"
	"{{.ModuleName}}/router/cookies"
	"{{.ModuleName}}/router/routes"

	"github.com/google/uuid"
	"github.com/gorilla/sessions"
	"github.com/labstack/echo-contrib/session"
	"github.com/labstack/echo/v4"

	echomw "github.com/labstack/echo/v4/middleware"
)

type Router struct {
	Handler     *echo.Echo
	controllers controllers.Controllers
}

func New(
	ctx context.Context,
	controllers controllers.Controllers,
	cfg config.Config,
) (*Router, error) {
	gob.Register(uuid.UUID{})
	gob.Register(cookies.FlashMessage{})

	router := echo.New()

	if config.Env != config.ProdEnvironment {
		router.Debug = true
	}

	authKey, err := hex.DecodeString(cfg.Auth.SessionKey)
	if err != nil {
		return nil, err
	}
	encKey, err := hex.DecodeString(cfg.Auth.SessionEncryptionKey)
	if err != nil {
		return nil, err
	}

	//csrfName := strings.ToLower(config.ProjectName) + "_" + "dev_csrf"
	//if config.Env == config.ProdEnvironment {
	//	csrfName = strings.ToLower(config.ProjectName) + "_" + "csrf"
	//}
	// TODO: make changing name work with d-*
	csrfName := "_csrf"

	router.Use(
		logger(),
		session.Middleware(
			sessions.NewCookieStore(
				authKey,
				encKey,
			),
		),
		registerAppContext,
		registerFlashMessagesContext,

		echomw.CSRFWithConfig(echomw.CSRFConfig{Skipper: func(c echo.Context) bool {
			return strings.HasPrefix(c.Request().URL.Path, routes.APIRoutePrefix) ||
				strings.HasPrefix(c.Request().URL.Path, routes.AssetsRoutePrefix)
		}, TokenLookup: "cookie:" + csrfName, CookiePath: "/", CookieDomain: func() string {
			if config.Env == config.ProdEnvironment {
				return config.Domain
			}

			return ""
		}(), CookieSecure: config.Env == config.ProdEnvironment, CookieHTTPOnly: true, CookieSameSite: http.SameSiteStrictMode}),

		echomw.Recover(),
	)

	return &Router{
		router,
		controllers,
	}, nil
}

func (r *Router) SetupRoutes() *echo.Echo {
	registeredRoutes := []string{}
	controllersValue := reflect.ValueOf(r.controllers)

	for _, route := range routes.BuildRoutes {
		if registered := slices.Contains(registeredRoutes, route.Name); registered {
			panic(
				fmt.Sprintf(
					"%s is registered more than once",
					route.Name,
				),
			)
		}

		if route.Controller == "" || route.ControllerMethod == "" {
			panic("Route must specify Controller and ControllerMethod fields")
		}

		controllerField := controllersValue.FieldByName(route.Controller)
		if !controllerField.IsValid() {
			panic(
				fmt.Sprintf(
					"Controller field %s not found in controllers struct",
					route.Controller,
				),
			)
		}

		controller := controllerField.Interface()
		controllerFunc := getHandlerFunc(controller, route.ControllerMethod)

		var middlewareFuncs []echo.MiddlewareFunc
		for _, mw := range route.Middleware {
			middlewareFuncs = append(middlewareFuncs, echo.MiddlewareFunc(mw))
		}

		switch route.Method {
		case http.MethodGet:
			registeredRoutes = append(registeredRoutes, route.Name)
			r.Handler.GET(route.Path, controllerFunc, middlewareFuncs...).Name = route.Name
		case http.MethodPost:
			registeredRoutes = append(registeredRoutes, route.Name)
			r.Handler.POST(route.Path, controllerFunc, middlewareFuncs...).Name = route.Name
		case http.MethodPut:
			registeredRoutes = append(registeredRoutes, route.Name)
			r.Handler.PUT(route.Path, controllerFunc, middlewareFuncs...).Name = route.Name
		case http.MethodDelete:
			registeredRoutes = append(registeredRoutes, route.Name)
			r.Handler.DELETE(route.Path, controllerFunc, middlewareFuncs...).Name = route.Name
		}
	}

	r.Handler.RouteNotFound(
		"/*",
		getHandlerFunc(r.controllers.Pages, "NotFound"),
	)

	return r.Handler
}

func getHandlerFunc(controller any, methodName string) echo.HandlerFunc {
	appType := reflect.TypeOf(controller)
	method, found := appType.MethodByName(methodName)
	if !found {
		panic(fmt.Sprintf("Controller method %s not found", methodName))
	}

	return func(c echo.Context) error {
		values := method.Func.Call([]reflect.Value{
			reflect.ValueOf(controller),
			reflect.ValueOf(c),
		})

		if len(values) != 1 {
			panic(
				fmt.Sprintf(
					"Controller method %s does not return exactly one value",
					methodName,
				),
			)
		}

		if values[0].IsNil() {
			return nil
		}

		return values[0].Interface().(error)
	}
}

func registerAppContext(
	next echo.HandlerFunc,
) echo.HandlerFunc {
	return func(c echo.Context) error {
		if strings.HasPrefix(c.Request().URL.Path, routes.AssetsRoutePrefix) ||
			strings.HasPrefix(c.Request().URL.Path, routes.APIRoutePrefix) {
			return next(c)
		}

		c.Set(string(cookies.AppKey), cookies.GetApp(c))

		return next(c)
	}
}

func registerFlashMessagesContext(
	next echo.HandlerFunc,
) echo.HandlerFunc {
	return func(c echo.Context) error {
		if strings.HasPrefix(c.Request().URL.Path, routes.AssetsRoutePrefix) ||
			strings.HasPrefix(c.Request().URL.Path, routes.APIRoutePrefix) {
			return next(c)
		}

		flashes, err := cookies.GetFlashes(c)
		if err != nil {
			slog.Error("Error getting flash messages from session", "error", err)
			return next(c)
		}

		c.Set(string(cookies.FlashKey), flashes)

		return next(c)
	}
}

type LogExporter interface {
	Name() string
	GetSlogHandler(
		ctx context.Context,
	) (slog.Handler, error)

	Shutdown(ctx context.Context) error
}

func NewLogger(
	ctx context.Context,
	exporter LogExporter,
) (*slog.Logger, func(ctx context.Context) error) {
	handler, err := exporter.GetSlogHandler(ctx)
	if err != nil {
		panic(err)
	}

	return slog.New(handler), exporter.Shutdown
}

func logger() echo.MiddlewareFunc {
	otelMiddleware := otelecho.Middleware(
		config.ProjectName,
	)
	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			if strings.Contains(c.Request().URL.Path, routes.APIRoutePrefix) ||
				strings.Contains(c.Request().URL.Path, routes.AssetsRoutePrefix) {
				return next(c)
			}

			start := time.Now()

			var statusCode int
			wrappedNext := func(c echo.Context) error {
				err := next(c)
				statusCode = c.Response().Status
				return err
			}

			err := otelMiddleware(wrappedNext)(c)
			duration := time.Since(start)

			slog.InfoContext(c.Request().Context(), "HTTP request completed",
				"method", c.Request().Method,
				"path", c.Request().URL.Path,
				"status", statusCode,
				"remote_addr", c.RealIP(),
				"user_agent", c.Request().UserAgent(),
				"duration", duration.String(),
			)

			return err
		}
	}
}
