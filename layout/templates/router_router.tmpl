// Package router provides the application routes and middleware setup.
package router

import (
	"context"
	"encoding/gob"
	"encoding/hex"
	"fmt"
	"log/slog"
	"net/http"
	"os"
	"reflect"
	"slices"
	"strings"
	"time"

	"{{.ModuleName}}/config"
	"{{.ModuleName}}/controllers"
	"{{.ModuleName}}/router/cookies"
	"{{.ModuleName}}/router/routes"
	"{{.ModuleName}}/telemetry"

	"github.com/google/uuid"
	"github.com/gorilla/sessions"
	"github.com/labstack/echo-contrib/session"
	"github.com/labstack/echo/v4"
	"go.opentelemetry.io/contrib/instrumentation/github.com/labstack/echo/otelecho"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"

	echomw "github.com/labstack/echo/v4/middleware"
)

type Router struct {
	Handler     *echo.Echo
	controllers controllers.Controllers
	telemetry   *telemetry.Telemetry
}

func New(
	ctx context.Context,
	controllers controllers.Controllers,
	cfg config.Config,
	tel *telemetry.Telemetry,
) (*Router, error) {
	gob.Register(uuid.UUID{})
	gob.Register(cookies.FlashMessage{})

	router := echo.New()

	if config.Env != config.ProdEnvironment {
		router.Debug = true
	}

	authKey, err := hex.DecodeString(cfg.App.SessionKey)
	if err != nil {
		return nil, err
	}
	encKey, err := hex.DecodeString(cfg.App.SessionEncryptionKey)
	if err != nil {
		return nil, err
	}

	//csrfName := strings.ToLower(config.ProjectName) + "_" + "dev_csrf"
	//if config.Env == config.ProdEnvironment {
	//	csrfName = strings.ToLower(config.ProjectName) + "_" + "csrf"
	//}
	// TODO: make changing name work with d-*
	csrfName := "_csrf"

	middleware := []echo.MiddlewareFunc{
		logger(tel, cfg.Telemetry.ServiceName),
		session.Middleware(
			sessions.NewCookieStore(
				authKey,
				encKey,
			),
		),
		registerAppContext,
		registerFlashMessagesContext,

		echomw.CSRFWithConfig(echomw.CSRFConfig{Skipper: func(c echo.Context) bool {
			return strings.HasPrefix(c.Request().URL.Path, routes.APIRoutePrefix) ||
				strings.HasPrefix(c.Request().URL.Path, routes.AssetsRoutePrefix)
		}, TokenLookup: "cookie:" + csrfName, CookiePath: "/", CookieDomain: func() string {
			if config.Env == config.ProdEnvironment {
				return config.Domain
			}

			return ""
		}(), CookieSecure: config.Env == config.ProdEnvironment, CookieHTTPOnly: true, CookieSameSite: http.SameSiteStrictMode}),

		echomw.Recover(),
	}

	if tel.HasTracing() {
		middleware = append([]echo.MiddlewareFunc{otelecho.Middleware(cfg.Telemetry.ServiceName)}, middleware...)
	}

	router.Use(middleware...)

	return &Router{
		router,
		controllers,
		tel,
	}, nil
}

func (r *Router) SetupRoutes() *echo.Echo {
	registeredRoutes := []string{}
	controllersValue := reflect.ValueOf(r.controllers)

	for _, route := range routes.Registry {
		if registered := slices.Contains(registeredRoutes, route.Name); registered {
			fmt.Fprintf(os.Stderr, "Error: Route '%s' (Path: %s) is registered more than once\n", route.Name, route.Path)
			os.Exit(1)
		}

		if route.Controller == "" || route.ControllerMethod == "" {
			fmt.Fprintf(os.Stderr, "Error: Route '%s' (Path: %s) must specify Controller and ControllerMethod fields\n", route.Name, route.Path)
			os.Exit(1)
		}

		controllerField := controllersValue.FieldByName(route.Controller)
		if !controllerField.IsValid() {
			fmt.Fprintf(os.Stderr, "Error: Tried to register Route '%s' (Path: %s) on Controller: %s Method: %s but Controller '%s' does not exist\n",
				route.Name, route.Path, route.Controller, route.ControllerMethod, route.Controller)
			os.Exit(1)
		}

		controller := controllerField.Interface()
		controllerFunc := getHandlerFunc(controller, route.ControllerMethod)

		var middlewareFuncs []echo.MiddlewareFunc
		for _, mw := range route.Middleware {
			middlewareFuncs = append(middlewareFuncs, echo.MiddlewareFunc(mw.Handler()))
		}

		switch route.Method {
		case http.MethodGet:
			registeredRoutes = append(registeredRoutes, route.Name)
			r.Handler.GET(route.Path, controllerFunc, middlewareFuncs...).Name = route.Name
		case http.MethodPost:
			registeredRoutes = append(registeredRoutes, route.Name)
			r.Handler.POST(route.Path, controllerFunc, middlewareFuncs...).Name = route.Name
		case http.MethodPut:
			registeredRoutes = append(registeredRoutes, route.Name)
			r.Handler.PUT(route.Path, controllerFunc, middlewareFuncs...).Name = route.Name
		case http.MethodDelete:
			registeredRoutes = append(registeredRoutes, route.Name)
			r.Handler.DELETE(route.Path, controllerFunc, middlewareFuncs...).Name = route.Name
		}
	}

	r.Handler.RouteNotFound(
		"/*",
		getHandlerFunc(r.controllers.Pages, "NotFound"),
	)

	return r.Handler
}

func getHandlerFunc(controller any, methodName string) echo.HandlerFunc {
	appType := reflect.TypeOf(controller)
	method, found := appType.MethodByName(methodName)
	if !found {
		controllerName := appType.String()
		fmt.Fprintf(os.Stderr, "Error: Controller method '%s' not found on Controller: %s\n", methodName, controllerName)
		os.Exit(1)
	}

	return func(c echo.Context) error {
		values := method.Func.Call([]reflect.Value{
			reflect.ValueOf(controller),
			reflect.ValueOf(c),
		})

		if len(values) != 1 {
			panic(
				fmt.Sprintf(
					"Controller method %s does not return exactly one value",
					methodName,
				),
			)
		}

		if values[0].IsNil() {
			return nil
		}

		return values[0].Interface().(error)
	}
}

func registerAppContext(
	next echo.HandlerFunc,
) echo.HandlerFunc {
	return func(c echo.Context) error {
		if strings.HasPrefix(c.Request().URL.Path, routes.AssetsRoutePrefix) ||
			strings.HasPrefix(c.Request().URL.Path, routes.APIRoutePrefix) {
			return next(c)
		}

		c.Set(string(cookies.AppKey), cookies.GetApp(c))

		return next(c)
	}
}

func registerFlashMessagesContext(
	next echo.HandlerFunc,
) echo.HandlerFunc {
	return func(c echo.Context) error {
		if strings.HasPrefix(c.Request().URL.Path, routes.AssetsRoutePrefix) ||
			strings.HasPrefix(c.Request().URL.Path, routes.APIRoutePrefix) {
			return next(c)
		}

		flashes, err := cookies.GetFlashes(c)
		if err != nil {
			slog.Error("Error getting flash messages from session", "error", err)
			return next(c)
		}

		c.Set(string(cookies.FlashKey), flashes)

		return next(c)
	}
}


func logger(tel *telemetry.Telemetry, serviceName string) echo.MiddlewareFunc {
	var httpRequestsTotal metric.Int64Counter
	var httpDuration metric.Float64Histogram
	var httpInFlight metric.Int64UpDownCounter

	if tel.HasMetrics() {
		var err error
		httpRequestsTotal, err = telemetry.HTTPRequestsTotal(serviceName)
		if err != nil {
			slog.Warn("failed to create http_requests_total metric", "error", err)
		}
		httpDuration, err = telemetry.HTTPRequestDuration(serviceName)
		if err != nil {
			slog.Warn("failed to create http_request_duration metric", "error", err)
		}
		httpInFlight, err = telemetry.HTTPRequestsInFlight(serviceName)
		if err != nil {
			slog.Warn("failed to create http_requests_in_flight metric", "error", err)
		}

		meter := telemetry.GetMeter(serviceName)
		if err := telemetry.SetupRuntimeMetricsInCallback(meter); err != nil {
			slog.Warn("failed to setup runtime metrics", "error", err)
		}
	}

	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			if strings.Contains(c.Request().URL.Path, routes.APIRoutePrefix) ||
				strings.Contains(c.Request().URL.Path, routes.AssetsRoutePrefix) {
				return next(c)
			}

			ctx := c.Request().Context()
			start := time.Now()

			if tel.HasMetrics() && httpInFlight != nil {
				httpInFlight.Add(ctx, 1)
				defer httpInFlight.Add(ctx, -1)
			}

			err := next(c)
			duration := time.Since(start)
			statusCode := c.Response().Status

			if tel.HasMetrics() && httpRequestsTotal != nil && httpDuration != nil {
				attrs := []attribute.KeyValue{
					attribute.String("method", c.Request().Method),
					attribute.String("route", c.Path()),
					attribute.Int("status_code", statusCode),
				}
				httpRequestsTotal.Add(ctx, 1, metric.WithAttributes(attrs...))
				httpDuration.Record(ctx, duration.Seconds(), metric.WithAttributes(attrs...))
			}

			slog.InfoContext(ctx, "HTTP request completed",
				"method", c.Request().Method,
				"path", c.Request().URL.Path,
				"status", statusCode,
				"remote_addr", c.RealIP(),
				"user_agent", c.Request().UserAgent(),
				"duration", duration.String(),
			)

			return err
		}
	}
}
