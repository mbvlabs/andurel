package main

import (
	"context"
	"fmt"
	"log/slog"
	"net"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"time"

	"{{.ModuleName}}/config"
	"{{.ModuleName}}/controllers"
	"{{.ModuleName}}/database"
	"{{.ModuleName}}/pkg/telemetry"
	"{{.ModuleName}}/router"
	"{{.ModuleName}}/queue"
	"{{.ModuleName}}/queue/workers"
	"riverqueue.com/riverui"
{{- range .Blueprint.Controllers.SortedDependencies}}
{{- if .ImportPath}}
	"{{.ImportPath}}"
{{- end}}
{{- end}}
{{- range .Blueprint.Main.Imports.Items}}
	"{{.}}"
{{- end}}

	"github.com/labstack/echo/v4"
	"golang.org/x/sync/errgroup"
)

var appVersion string

func startServer(ctx context.Context, srv *http.Server, processor queue.Processor, env string) error {
	if env == config.ProdEnvironment {
		eg, egCtx := errgroup.WithContext(ctx)

		eg.Go(func() error {
			if err := srv.ListenAndServe(); err != nil &&
				err != http.ErrServerClosed {
				return fmt.Errorf("server error: %w", err)
			}
			return nil
		})

		eg.Go(func() error {
			<-egCtx.Done()
			slog.InfoContext(ctx, "initiating graceful shutdown")
			shutdownCtx, cancel := context.WithTimeout(
				ctx,
				10*time.Second,
			)
			defer cancel()
			slog.InfoContext(ctx, "shutting down processor")
			if err := processor.Stop(shutdownCtx); err != nil {
				return fmt.Errorf("processor shutdown error: %w", err)
			}
			if err := srv.Shutdown(shutdownCtx); err != nil {
				return fmt.Errorf("shutdown error: %w", err)
			}
			return nil
		})

		if err := eg.Wait(); err != nil {
			slog.InfoContext(ctx, "wait error", "e", err)
			return err
		}

		return nil
	}

	return srv.ListenAndServe()
}

func setupControllers(
{{- range $i, $dep := .Blueprint.Controllers.SortedDependencies}}
	{{$dep.Name}} {{$dep.Type}},
{{- end}}
	insertOnly queue.InsertOnly,
) (controllers.Controllers, error) {
	ctrl, err := controllers.New(
{{- range .Blueprint.Controllers.SortedDependencies}}
		{{.Name}},
{{- end}}
		insertOnly,
	)
	if err != nil {
		return controllers.Controllers{}, err
	}

	return ctrl, nil
}

func setupRouter(
	ctx context.Context,
	ctrl controllers.Controllers,
	cfg config.Config,
	tel *telemetry.Telemetry,
	riverHandler *riverui.Handler,
) (*echo.Echo, error) {
	r, err := router.New(
		ctx,
		ctrl,
		cfg,
		tel,
		riverHandler,
	)
	if err != nil {
		return nil, err
	}

	return r.Handler, nil
}

func parseHeaders(headersStr string) map[string]string {
	headers := make(map[string]string)
	if headersStr == "" {
		return headers
	}

	pairs := strings.SplitSeq(headersStr, ",")
	for pair := range pairs {
		kv := strings.SplitN(pair, "=", 2)
		if len(kv) == 2 {
			headers[strings.TrimSpace(kv[0])] = strings.TrimSpace(kv[1])
		}
	}

	return headers
}

func buildTelemetry(ctx context.Context, cfg config.Config) (*telemetry.Telemetry, error) {
	opts := []telemetry.Option{
		telemetry.WithService(cfg.Telemetry.ServiceName, cfg.Telemetry.ServiceVersion),
		telemetry.WithBatchConfig(cfg.Telemetry.BatchSize, cfg.Telemetry.BatchTimeoutMs, 2048),
		telemetry.WithTraceSampleRate(cfg.Telemetry.TraceSampleRate),
	}

	opts = append(opts, telemetry.WithLogExporters(telemetry.NewStdoutExporter()))

	if cfg.Telemetry.OtlpMetricsEndpoint != "" {
		opts = append(opts, telemetry.WithMetricExporters(
			telemetry.NewOtlpMetricExporter(cfg.Telemetry.OtlpMetricsEndpoint, parseHeaders(cfg.Telemetry.OtlpHeaders))))
	}

	if cfg.Telemetry.OtlpTracesEndpoint != "" {
		opts = append(opts, telemetry.WithTraceExporters(
			telemetry.NewOtlpTraceExporter(cfg.Telemetry.OtlpTracesEndpoint, parseHeaders(cfg.Telemetry.OtlpHeaders))))
	} else {
		opts = append(opts, telemetry.WithTraceExporters(telemetry.NewNoopTraceExporter()))
	}

	return telemetry.New(ctx, opts...)
}

func run(ctx context.Context) error {
	ctx, cancel := signal.NotifyContext(ctx, os.Interrupt)
	defer cancel()

	cfg := config.NewConfig()

	tel, err := buildTelemetry(ctx, cfg)
	if err != nil {
		return fmt.Errorf("failed to initialize telemetry: %w", err)
	}
	defer func() {
		shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()
		if err := tel.Shutdown(shutdownCtx); err != nil {
			slog.Error("telemetry shutdown error", "error", err)
		}
	}()

	if err := tel.HealthCheck(ctx); err != nil {
		slog.Warn("telemetry health check failed", "error", err)
	}


	db, err := database.NewPostgres(ctx, cfg.DB.GetDatabaseURL())
	if err != nil {
		return err
	}

{{- range .Blueprint.Controllers.SortedDependencies}}
{{- if .InitExpr}}
	{{.Name}} := {{.InitExpr}}
{{- end}}
{{- end}}

{{- range .Blueprint.Main.SortedInitializations}}
	{{.VarName}} := {{.Expression}}
{{- end}}

	wrks, err := workers.Register(emailClient, emailClient)
	if err != nil {
		return err
	}

	insertOnly, err := queue.NewInsertOnly(
		db.Conn(),
		wrks,
	)
	if err != nil {
		return err
	}

	processor, err := queue.NewProcessor(
		ctx,
		db.Conn(),
		wrks,
	)
	if err != nil {
		return err
	}

{{- range .Blueprint.Main.SortedPreRunHooks}}
	// Pre-run hook: {{.Name}}
	{{.Code}}
{{- end}}

	controllers, err := setupControllers(
{{- range .Blueprint.Controllers.SortedDependencies}}
		{{.Name}},
{{- end}}
		insertOnly,
	)
	if err != nil {
		return err
	}

	endpoints := riverui.NewEndpoints(processor.Client, nil)
	opts := &riverui.HandlerOpts{
		Endpoints: endpoints,
		Logger:    slog.Default(),
		Prefix:    "/riverui", // mount the UI and its APIs under /riverui or another path
	}
	riverHandler, err := riverui.NewHandler(opts)
	if err != nil {
		return err
	}

	riverHandler.Start(ctx)

	handler, err := setupRouter(ctx, controllers, cfg, tel, riverHandler)
	if err != nil {
		return err
	}

	go func() error {
		slog.InfoContext(ctx, "starting queue processor")
		if err := processor.Start(ctx); err != nil {
			slog.ErrorContext(ctx, "error stopping queue processor", "error", err)
			return err
		}

		return nil
	}()

{{- range .Blueprint.Main.SortedBackgroundWorkers}}
	// Start background worker: {{.Name}}
	go {{.FunctionCall}}
{{- end}}

	srv := &http.Server{
		Addr:         fmt.Sprintf("%v:%v", cfg.App.Host, cfg.App.Port),
		Handler:      handler,
		ReadTimeout:  1 * time.Second,
		WriteTimeout: 5 * time.Second,
		BaseContext:  func(_ net.Listener) context.Context { return ctx },
	}

	slog.InfoContext(ctx, "starting server", "host", cfg.App.Host, "port", cfg.App.Port)
	return startServer(ctx, srv, processor, config.Env)
}

func main() {
	ctx := context.Background()
	if err := run(ctx); err != nil {
		fmt.Fprintf(os.Stderr, "%s\n", err)
		os.Exit(1)
	}
}
