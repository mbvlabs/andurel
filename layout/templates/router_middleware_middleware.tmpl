// Package middleware provides HTTP middleware for the Echo web framework,
package middleware

import (
	"errors"
	"log/slog"
	"net/http"
	"strings"
	"time"

	"{{.ModuleName}}/config"
	"{{.ModuleName}}/internal/server"
	"{{.ModuleName}}/internal/storage"
	"{{.ModuleName}}/router/cookies"
	"{{.ModuleName}}/router/routes"
	"{{.ModuleName}}/telemetry"

	"github.com/labstack/echo/v5"
	echomw "github.com/labstack/echo/v5/middleware"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/semconv/v1.26.0"
	"go.opentelemetry.io/otel/trace"
)

type Middleware struct {
	db storage.Pool
}

func New(db storage.Pool) Middleware {
	return Middleware{db: db}
}

func (m Middleware) RegisterAppContext(
	next echo.HandlerFunc,
) echo.HandlerFunc {
	return func(c *echo.Context) error {
		if strings.Contains(c.Request().URL.Path, routes.AssetsPrefix) ||
			strings.Contains(c.Request().URL.Path, routes.APIPrefix) {
			return next(c)
		}

		c.Set(string(cookies.AppKey), cookies.GetApp(c))

		return next(c)
	}
}

func (m Middleware) RegisterFlashMessagesContext(
	next echo.HandlerFunc,
) echo.HandlerFunc {
	return func(c *echo.Context) error {
		if strings.Contains(c.Request().URL.Path, routes.AssetsPrefix) ||
			strings.Contains(c.Request().URL.Path, routes.APIPrefix) {
			return next(c)
		}

		flashes, err := cookies.GetFlashes(c)
		if err != nil {
			slog.Error("Error getting flash messages from session", "error", err)
			return next(c)
		}

		c.Set(string(cookies.FlashKey), flashes)

		return next(c)
	}
}


func (m Middleware) ValidateSession(
	next echo.HandlerFunc,
) echo.HandlerFunc {
	return func(c *echo.Context) error {
		// Skip session validation for static assets and API routes
		if strings.Contains(c.Request().URL.Path, routes.AssetsPrefix) ||
			strings.Contains(c.Request().URL.Path, routes.APIPrefix) {
			return next(c)
		}

		return next(c)
	}
}

func (m Middleware) Logger(tel *telemetry.Telemetry) echo.MiddlewareFunc {
	var httpRequestsTotal metric.Int64Counter
	var httpDuration metric.Float64Histogram
	var httpInFlight metric.Int64UpDownCounter

	if tel.HasMetrics() {
		var err error
		httpRequestsTotal, err = telemetry.HTTPRequestsTotal()
		if err != nil {
			slog.Warn("failed to create http_requests_total metric", "error", err)
		}
		httpDuration, err = telemetry.HTTPRequestDuration()
		if err != nil {
			slog.Warn("failed to create http_request_duration metric", "error", err)
		}
		httpInFlight, err = telemetry.HTTPRequestsInFlight()
		if err != nil {
			slog.Warn("failed to create http_requests_in_flight metric", "error", err)
		}

		meter := telemetry.GetMeter(config.ServiceName)
		if err := telemetry.SetupRuntimeMetricsInCallback(meter); err != nil {
			slog.Warn("failed to setup runtime metrics", "error", err)
		}
	}

	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c *echo.Context) error {
			if strings.Contains(c.Request().URL.Path, routes.AssetsPrefix) ||
				strings.Contains(c.Request().URL.Path, routes.APIPrefix) {
				return next(c)
			}

			ctx := c.Request().Context()
			start := time.Now()

			if tel.HasMetrics() && httpInFlight != nil {
				httpInFlight.Add(ctx, 1)
				defer httpInFlight.Add(ctx, -1)
			}

			err := next(c)
			duration := time.Since(start)
			route := c.Path()

			statusCode := 0
			if resp, unwrapErr := echo.UnwrapResponse(c.Response()); unwrapErr == nil {
				statusCode = resp.Status
			}

			if tel.HasMetrics() && httpRequestsTotal != nil && httpDuration != nil {
				attrs := []attribute.KeyValue{
					attribute.String("method", c.Request().Method),
					attribute.String("route", route),
					attribute.Int("status_code", statusCode),
				}
				httpRequestsTotal.Add(ctx, 1, metric.WithAttributes(attrs...))
				httpDuration.Record(ctx, duration.Seconds(), metric.WithAttributes(attrs...))
			}

			slog.InfoContext(ctx, "HTTP request completed",
				"method", c.Request().Method,
				"path", c.Request().URL.Path,
				"status", statusCode,
				"remote_addr", c.RealIP(),
				"user_agent", c.Request().UserAgent(),
				"duration", duration.String(),
			)

			return err
		}
	}
}

func (m Middleware) TraceRouteAttributes(tel *telemetry.Telemetry) echo.MiddlewareFunc {
	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c *echo.Context) error {
			if strings.Contains(c.Request().URL.Path, routes.AssetsPrefix) ||
				strings.Contains(c.Request().URL.Path, routes.APIPrefix) {
				return next(c)
			}

			err := next(c)
			if !tel.HasTracing() {
				return err
			}

			routeInfo := c.RouteInfo()
			if routeInfo.Path == "" {
				return err
			}

			span := trace.SpanFromContext(c.Request().Context())
			if !span.SpanContext().IsValid() {
				return err
			}

			span.SetAttributes(
				semconv.HTTPTarget(routeInfo.Path),
				semconv.HTTPRoute(routeInfo.Path),
			)

			return err
		}
	}
}

func (m Middleware) CSRFMiddleware(cfg config.Config, csrfName string) ([]echo.MiddlewareFunc, error) {
	if !cfg.App.CSRFEnabled {
		return nil, nil
	}

	strategy := strings.TrimSpace(cfg.App.CSRFStrategy)
	if strategy == "" {
		strategy = "header_only"
	}

	switch strategy {
	case "header_only", "header_or_legacy_token":
	default:
		return nil, errors.New("invalid CSRF strategy")
	}

	trustedOrigins := m.csrfTrustedOrigins(cfg)
	csrfConfig := echomw.CSRFConfig{
		Skipper: func(c *echo.Context) bool {
			return strings.Contains(c.Request().URL.Path, routes.APIPrefix) ||
				strings.Contains(c.Request().URL.Path, routes.AssetsPrefix)
		},
		TokenLookup: "cookie:" + csrfName,
		CookiePath:  "/",
		CookieDomain: func() string {
			if config.Env == server.ProdEnvironment {
				return config.Domain
			}

			return ""
		}(),
		CookieSecure:   config.Env == server.ProdEnvironment,
		CookieHTTPOnly: true,
		CookieSameSite: http.SameSiteStrictMode,
		TrustedOrigins: trustedOrigins,
	}

	csrfMiddleware := echomw.CSRFWithConfig(csrfConfig)
	var legacyTokenMiddleware echo.MiddlewareFunc
	if strategy == "header_or_legacy_token" {
		csrfConfig.TokenLookup = "header:X-CSRF-Token,form:_csrf"
		csrfMiddleware = echomw.CSRFWithConfig(csrfConfig)
		legacyTokenMiddleware = func(next echo.HandlerFunc) echo.HandlerFunc {
			return func(c *echo.Context) error {
				if strings.Contains(c.Request().URL.Path, routes.APIPrefix) ||
					strings.Contains(c.Request().URL.Path, routes.AssetsPrefix) {
					return next(c)
				}

				secFetchSite := strings.ToLower(strings.TrimSpace(c.Request().Header.Get("Sec-Fetch-Site")))
				if secFetchSite == "same-origin" || secFetchSite == "same-site" || secFetchSite == "cross-site" {
					return next(c)
				}

				if c.Request().Header.Get("X-CSRF-Token") == "" && c.FormValue("_csrf") != "" {
					slog.Warn("CSRF check fell back to legacy token")
				}

				return next(c)
			}
		}
	}

	middlewares := []echo.MiddlewareFunc{
		m.csrfVaryHeader,
		m.csrfStrictHeaderOnly(strategy),
	}

	if legacyTokenMiddleware != nil {
		middlewares = append(middlewares, legacyTokenMiddleware)
	}

	middlewares = append(middlewares, csrfMiddleware)
	return middlewares, nil
}

func (m Middleware) csrfTrustedOrigins(cfg config.Config) []string {
	origins := []string{}
	if len(cfg.App.CSRFTrustedOrigins) > 0 {
		origins = append(origins, cfg.App.CSRFTrustedOrigins...)
	}

		if config.Env == server.ProdEnvironment && config.BaseURL != "" {
			origins = append(origins, config.BaseURL)
		}

		if config.Env == server.ProdEnvironment && len(origins) == 0 {
			return nil
		}

		return origins

}

func (m Middleware) csrfStrictHeaderOnly(strategy string) echo.MiddlewareFunc {
	if strategy != "header_only" {
		return func(next echo.HandlerFunc) echo.HandlerFunc {
			return func(c *echo.Context) error {
				return next(c)
			}
		}
	}

	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c *echo.Context) error {
			if strings.Contains(c.Request().URL.Path, routes.AssetsPrefix) ||
				strings.Contains(c.Request().URL.Path, routes.APIPrefix) {
				return next(c)
			}

			method := c.Request().Method
			if method == http.MethodGet || method == http.MethodHead || method == http.MethodOptions || method == http.MethodTrace {
				return next(c)
			}

			secFetchSite := strings.ToLower(strings.TrimSpace(c.Request().Header.Get("Sec-Fetch-Site")))
			if secFetchSite == "" || secFetchSite == "none" {
				return echo.NewHTTPError(http.StatusForbidden, "CSRF verification failed: missing Sec-Fetch-Site header")
			}

			return next(c)
		}
	}
}

func (m Middleware) csrfVaryHeader(next echo.HandlerFunc) echo.HandlerFunc {
	return func(c *echo.Context) error {
		c.Response().Header().Add("Vary", "Sec-Fetch-Site")
		return next(c)
	}
}
