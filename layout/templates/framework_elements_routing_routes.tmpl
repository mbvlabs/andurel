// Package routing provides implementations of different kinds of routes.
// Code generated and maintained by the andurel framework. DO NOT EDIT.
package routing

import (
	"log/slog"
	"strings"

	"github.com/google/uuid"
)

func configureName(name, prefix string) string {
	if prefix == "" {
		return name
	}

	return prefix + "." + name
}

func configurePath(path, prefix, name string) string {
	return sanitizePath(buildPath(path, prefix, name), name)
}

func buildPath(path, prefix, name string) string {
	if prefix == "" {
		return path
	}

	// Empty path means index route - just use prefix as-is
	if path == "" {
		return prefix
	}

	prefixEndsWithSlash := strings.HasSuffix(prefix, "/")
	pathStartsWithSlash := strings.HasPrefix(path, "/")

	if prefixEndsWithSlash != pathStartsWithSlash {
		return prefix + path
	}

	if prefixEndsWithSlash && pathStartsWithSlash {
		slog.Warn("unexpected prefix/path configuration. double slash between prefix and path", "route", name, "prefix", prefix, "path", path)
		return prefix + path[1:]
	}

	slog.Warn("unexpected prefix/path configuration. missing slash between prefix and path", "route", name, "prefix", prefix, "path", path)
	return prefix + "/" + path
}

func sanitizePath(path, name string) string {
	// Ensure path starts with '/'
	if !strings.HasPrefix(path, "/") {
		slog.Warn("path does not start with '/'. prepending '/'", "route", name, "path", path)
		path = "/" + path
	}

	// Check for double slashes and fix
	if !strings.Contains(path, "//") {
		return path
	}

	slog.Warn("path contains double slashes. removing", "route", name, "path", path)

	// Single pass: build result without consecutive slashes
	var b strings.Builder
	b.Grow(len(path))
	prevSlash := false
	for i := 0; i < len(path); i++ {
		if path[i] == '/' {
			if prevSlash {
				continue
			}
			prevSlash = true
		} else {
			prevSlash = false
		}
		b.WriteByte(path[i])
	}

	return b.String()
}

type Route struct {
	name   string
	path   string
	prefix string
}

var _ SimpleRoute = (*Route)(nil)

// NewSimpleRoute creates a base route that takes no parameters
func NewSimpleRoute(path, name, prefix string) Route {
	return Route{name, path, prefix}
}

func (r Route) URL() string {
	return configurePath(r.path, r.prefix, r.name)
}

func (r Route) Name() string {
	return configureName(r.name, r.prefix)
}

func (r Route) Path() string {
	return configurePath(r.path, r.prefix, r.name)
}

type RouteWithID Route

var _ IDRoute = (*RouteWithID)(nil)

// NewRouteWithID creates an id route that takes a uuid as a parameter
func NewRouteWithID(path, name, prefix string) RouteWithID {
	return RouteWithID{name, path, prefix}
}

func (r RouteWithID) Name() string {
	return configureName(r.name, r.prefix)
}

func (r RouteWithID) Path() string {
	return configurePath(r.path, r.prefix, r.name)
}

func (r RouteWithID) URL(id uuid.UUID) string {
	return strings.Replace(r.Path(), ":id", id.String(), 1)
}

type RouteWithIDs Route

var _ IDsRoute = (*RouteWithIDs)(nil)

// NewRouteWithMultipleIDs creates a route that takes a map[string]uuid as parameters
func NewRouteWithMultipleIDs(path, name, prefix string) RouteWithIDs {
	return RouteWithIDs{name, path, prefix}
}

func (r RouteWithIDs) Name() string {
	return configureName(r.name, r.prefix)
}

func (r RouteWithIDs) Path() string {
	return configurePath(r.path, r.prefix, r.name)
}

func (r RouteWithIDs) URL(ids map[string]uuid.UUID) string {
	route := r.Path()
	for param, id := range ids {
		route = strings.Replace(route, ":"+param, id.String(), 1)
	}

	return route
}

type RouteWithSlug Route

var _ ParamRoute = (*RouteWithSlug)(nil)

func NewRouteWithSlug(path, name, prefix string) RouteWithSlug {
	return RouteWithSlug{name, path, prefix}
}

func (r RouteWithSlug) Name() string {
	return configureName(r.name, r.prefix)
}

func (r RouteWithSlug) Path() string {
	return configurePath(r.path, r.prefix, r.name)
}

func (r RouteWithSlug) URL(slug string) string {
	return strings.Replace(r.Path(), ":slug", slug, 1)
}

type RouteWithToken Route

var _ ParamRoute = (*RouteWithToken)(nil)

func NewRouteWithToken(path, name, prefix string) RouteWithToken {
	return RouteWithToken{name, path, prefix}
}

func (r RouteWithToken) Name() string {
	return configureName(r.name, r.prefix)
}

func (r RouteWithToken) Path() string {
	return configurePath(r.path, r.prefix, r.name)
}

func (r RouteWithToken) URL(token string) string {
	return strings.Replace(r.Path(), ":token", token, 1)
}

type RouteWithFile Route

var _ ParamRoute = (*RouteWithFile)(nil)

func NewRouteWithFile(path, name, prefix string) RouteWithFile {
	return RouteWithFile{name, path, prefix}
}

func (r RouteWithFile) Name() string {
	return configureName(r.name, r.prefix)
}

func (r RouteWithFile) Path() string {
	return configurePath(r.path, r.prefix, r.name)
}

func (r RouteWithFile) URL(file string) string {
	return strings.Replace(r.Path(), ":file", file, 1)
}
