package main

import (
{{- if eq .CSSFramework "tailwind" }}
	"bufio"
{{- end }}
	"context"
	"fmt"
	"net/http"
	"os"
	"os/exec"
	"os/signal"
{{- if eq .CSSFramework "tailwind" }}
	"strings"
{{- end }}
	"sync"
	"syscall"
	"time"

	"github.com/joho/godotenv"
)

const Version = "{{.RunToolVersion}}"

const (
	DefaultProxyPort = "3000"
	DefaultAppPort = "8080"
)

var (
	runningProcesses []*exec.Cmd
	processMutex     sync.Mutex
)

var verbose = os.Getenv("ANDUREL_VERBOSE") == "true"

func logDebug(format string, args ...interface{}) {
	if verbose {
		fmt.Printf(format+"\n", args...)
	}
}

func logInfo(format string, args ...interface{}) {
	fmt.Printf(format+"\n", args...)
}

func main() {
	ctx, cancel := context.WithCancel(context.Background())
	defer func() {
		cancel()
		cleanup()
	}()

	if err := godotenv.Load(); err != nil {
		fmt.Fprintf(os.Stderr, "Warning: could not load .env file: %v\n", err)
	}

	fmt.Printf("Starting run tool (version %s)\n", Version)

	proxyPort := os.Getenv("PROXY_PORT")
	if proxyPort == "" {
		proxyPort = DefaultProxyPort
	}
	appPort := os.Getenv("PORT")
	if appPort == "" {
		appPort = DefaultAppPort
	}

	broadcaster := NewBroadcaster()
	rebuildChan := make(chan struct{}, 1)
	templChange := make(chan TemplChange, 64)

	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

	var wg sync.WaitGroup
	errChan := make(chan error, 5)

	// Start proxy server
	wg.Add(1)
	go func() {
		defer wg.Done()
		if err := runProxyServer(ctx, proxyPort, appPort, broadcaster); err != nil {
			errChan <- fmt.Errorf("proxy-server: %w", err)
		}
	}()

	// Start Go file watcher
	wg.Add(1)
	go func() {
		defer wg.Done()
		if err := runGoWatcher(ctx, rebuildChan); err != nil {
			errChan <- fmt.Errorf("go-watcher: %w", err)
		}
	}()

	// Start templ watcher
	wg.Add(1)
	go func() {
		defer wg.Done()
		if err := runLiveTemplWithParser(ctx, templChange); err != nil {
			errChan <- fmt.Errorf("live-templ: %w", err)
		}
	}()

{{- if eq .CSSFramework "tailwind" }}
	// Start tailwind watcher
	wg.Add(1)
	go func() {
		defer wg.Done()
		if err := runLiveTailwind(ctx, broadcaster); err != nil {
			errChan <- fmt.Errorf("live-tailwind: %w", err)
		}
	}()
{{- end }}

	// App server manager
	appServer := NewAppServer(appPort, broadcaster)
	wg.Add(1)
	go func() {
		defer wg.Done()
		if err := appServer.Run(ctx, rebuildChan); err != nil {
			errChan <- fmt.Errorf("app-server: %w", err)
		}
	}()

	// Handle templ changes
	go func() {
		for {
			select {
			case <-ctx.Done():
				return
			case change := <-templChange:
				switch change {
				case TemplChangeNeedsBrowserReload:
					logInfo("[andurel] Template changed, reloading browser")
					broadcaster.Broadcast()
				case TemplChangeNeedsRestart:
					logInfo("[andurel] Template Go code changed, rebuilding")
					select {
					case rebuildChan <- struct{}{}:
					default:
					}
				}
			}
		}
	}()

	fmt.Printf("\n  Proxy server: http://localhost:%s\n", proxyPort)
	fmt.Printf("  App server:   http://localhost:%s (internal)\n", appPort)
	fmt.Printf("  TEMPL_DEV_MODE: enabled (fast template reloads)\n\n")

	go func() {
		select {
		case sig := <-sigChan:
			fmt.Printf("\nReceived signal: %v\n", sig)
			cancel()
		case err := <-errChan:
			if err != nil {
				fmt.Fprintf(os.Stderr, "Error: %v\n", err)
				fmt.Fprintf(os.Stderr, "Shutting down all processes...\n")
				cancel()
			}
		}
	}()

	wg.Wait()
	close(errChan)

	hasErrors := false
	for err := range errChan {
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error: %v\n", err)
			hasErrors = true
		}
	}

	if hasErrors {
		os.Exit(1)
	}
}

func addProcess(cmd *exec.Cmd) {
	processMutex.Lock()
	defer processMutex.Unlock()
	runningProcesses = append(runningProcesses, cmd)
}

func cleanup() {
	fmt.Printf("\nCleaning up processes...\n")

	processMutex.Lock()
	processes := make([]*exec.Cmd, len(runningProcesses))
	copy(processes, runningProcesses)
	processMutex.Unlock()

	for _, cmd := range processes {
		if cmd != nil && cmd.Process != nil {
			cmd.Process.Kill()
		}
	}

	wd, err := os.Getwd()
	if err == nil {
		exec.Command("pkill", "-f", wd+"/tmp/bin/main").Run()
	}

	port := os.Getenv("PORT")
	if port == "" {
		port = DefaultAppPort
	}
	exec.Command("fuser", "-k", port+"/tcp").Run()

	time.Sleep(500 * time.Millisecond)
	fmt.Printf("Cleanup complete.\n")
}

func runProxyServer(
	ctx context.Context,
	proxyPort, appPort string,
	broadcaster *Broadcaster,
) error {
	targetURL := fmt.Sprintf("http://localhost:%s", appPort)

	proxy, err := NewProxyServer(targetURL, WebSocketPath)
	if err != nil {
		return err
	}

	wsHandler := NewWebSocketHandler(broadcaster)
	handler := proxy.Handler(wsHandler)

	server := &http.Server{
		Addr:    ":" + proxyPort,
		Handler: handler,
	}

	go func() {
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			fmt.Fprintf(os.Stderr, "Proxy server error: %v\n", err)
		}
	}()

	<-ctx.Done()

	shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	return server.Shutdown(shutdownCtx)
}

{{- if eq .CSSFramework "tailwind" }}

func runLiveTailwind(ctx context.Context, broadcaster *Broadcaster) error {
	wd, err := os.Getwd()
	if err != nil {
		return err
	}

	cmd := exec.CommandContext(ctx, wd+"/bin/tailwindcli",
		"-i", "./css/base.css",
		"-o", "./assets/css/style.css",
		"--watch=always",
	)

	cmd.Dir = wd

	// Capture stdout to detect CSS rebuilds
	stdout, err := cmd.StdoutPipe()
	if err != nil {
		return err
	}
	cmd.Stderr = os.Stderr

	if err := cmd.Start(); err != nil {
		logInfo("Tailwind CLI not found. Run 'andurel sync' to download it.")
		return err
	}

	addProcess(cmd)

	// Parse tailwind output to detect rebuilds
	go func() {
		scanner := bufio.NewScanner(stdout)
		for scanner.Scan() {
			line := scanner.Text()
			logDebug("[tailwind] %s", line)

			// Tailwind outputs "Done in" when it finishes rebuilding
			if strings.Contains(line, "Done in") {
				logInfo("[andurel] CSS rebuilt, broadcasting reload")
				broadcaster.Broadcast()
			}
		}
	}()

	<-ctx.Done()
	if cmd.Process != nil {
		return cmd.Process.Kill()
	}
	return nil
}
{{- end }}
