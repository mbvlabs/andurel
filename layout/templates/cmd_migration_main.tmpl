package main

import (
	"errors"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"{{.ModuleName}}/config"

	"github.com/joho/godotenv"
	"gopkg.in/yaml.v3"
)

const (
	sqlcConfigPath    = "database/sqlc.yaml"
	migrationsDir     = "database/migrations"
	cmdCreate         = "create"
	cmdFix            = "fix"
	cmdNew            = "new"
	cmdUp             = "up"
	cmdDown           = "down"
	cmdReset          = "reset"
	cmdDownTo         = "down-to"
	cmdUpTo           = "up-to"
	gooseDriverPg     = "postgres"
	gooseDriverSQLite = "sqlite3"
)

type sqlcConfig struct {
	SQL []struct {
		Engine string `yaml:"engine"`
	} `yaml:"sql"`
}

func main() {
	if err := execute(); err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
}

func execute() error {
	if err := godotenv.Load(); err != nil {
		fmt.Fprintf(os.Stderr, "warning: could not load .env file: %v\n", err)
	}

	if len(os.Args) < 2 {
		printUsage()
		return errors.New("missing migration command")
	}

	engine, err := detectEngine(sqlcConfigPath)
	if err != nil {
		return err
	}

	driver, err := gooseDriver(engine)
	if err != nil {
		return err
	}

	cfg := config.NewConfig()
	dsn := cfg.DB.GetDatabaseURL()

	command := os.Args[1]
	args := os.Args[2:]

	switch command {
	case cmdCreate:
		if len(args) == 0 {
			return errors.New("create requires a migration name")
		}
		name := sanitizeMigrationName(args)
		if name == "" {
			return errors.New("provided migration name results in an empty identifier")
		}
		return runGoose(driver, dsn, cmdCreate, name, "sql")
	case cmdFix:
		return runGoose(driver, dsn, cmdFix)
	case cmdNew:
		if len(args) == 0 {
			return errors.New("new requires a migration name")
		}
		name := sanitizeMigrationName(args)
		if name == "" {
			return errors.New("provided migration name results in an empty identifier")
		}
		if err := runGoose(driver, dsn, cmdCreate, name, "sql"); err != nil {
			return err
		}
		return runGoose(driver, dsn, cmdFix)
	case cmdUp:
		return runGoose(driver, dsn, cmdUp)
	case cmdDown:
		return runGoose(driver, dsn, cmdDown)
	case cmdReset:
		if err := runGoose(driver, dsn, cmdDownTo, "0"); err != nil {
			return err
		}
		return runGoose(driver, dsn, cmdUp)
	case cmdDownTo:
		if len(args) == 0 {
			return errors.New("down-to requires a target version")
		}
		return runGoose(driver, dsn, cmdDownTo, args[0])
	case cmdUpTo:
		if len(args) == 0 {
			return errors.New("up-to requires a target version")
		}
		return runGoose(driver, dsn, cmdUpTo, args[0])
	default:
		printUsage()
		return fmt.Errorf("unknown migration command: %s", command)
	}
}

func printUsage() {
	fmt.Fprintln(os.Stderr, "usage: migration <command> [args]")
	fmt.Fprintln(os.Stderr, "\nAvailable commands:")
	fmt.Fprintln(os.Stderr, "  new <name>   create a new SQL migration (auto-fixes numbering)")
	fmt.Fprintln(os.Stderr, "  up           apply all pending migrations")
	fmt.Fprintln(os.Stderr, "  down         roll back the most recent migration")
	fmt.Fprintln(os.Stderr, "  reset        roll back everything and re-apply all migrations")
	fmt.Fprintln(os.Stderr, "  up-to <ver>  apply migrations up to the specified version")
	fmt.Fprintln(os.Stderr, "  down-to <ver> roll back to the specified version")
	fmt.Fprintln(os.Stderr, "  fix          renumber migrations to fix gaps")
}

func sanitizeMigrationName(parts []string) string {
	joined := strings.Join(parts, "_")
	replaced := strings.Map(func(r rune) rune {
		switch {
		case r >= 'a' && r <= 'z':
			return r
		case r >= '0' && r <= '9':
			return r
		case r >= 'A' && r <= 'Z':
			return r + ('a' - 'A')
		case r == '-' || r == ' ':
			return '_'
		case r == '_':
			return r
		default:
			return -1
		}
	}, joined)

	return strings.Trim(replaced, "_")
}

func gooseDriver(engine string) (string, error) {
	switch engine {
	case "postgresql":
		return gooseDriverPg, nil
	case "sqlite", "sqlite3":
		return gooseDriverSQLite, nil
	default:
		return "", fmt.Errorf("unsupported database engine: %s", engine)
	}
}

func detectEngine(path string) (string, error) {
	contents, err := os.ReadFile(path)
	if err != nil {
		return "", fmt.Errorf("unable to read sqlc config: %w", err)
	}

	var cfg sqlcConfig
	if err := yaml.Unmarshal(contents, &cfg); err != nil {
		return "", fmt.Errorf("unable to parse sqlc config: %w", err)
	}

	if len(cfg.SQL) == 0 || cfg.SQL[0].Engine == "" {
		return "", errors.New("no engine defined in sqlc config")
	}

	return cfg.SQL[0].Engine, nil
}

func runGoose(driver, dsn string, action string, extra ...string) error {
	wd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("could not determine working directory: %w", err)
	}

	args := []string{"tool", "goose", "-dir", filepath.Join(wd, migrationsDir), driver, dsn, action}
	if len(extra) > 0 {
		args = append(args, extra...)
	}

	cmd := exec.Command("go", args...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Stdin = os.Stdin
	cmd.Dir = wd

	return cmd.Run()
}
