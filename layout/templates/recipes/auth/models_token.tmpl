package models

import (
	"context"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base32"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"{{.ModuleName}}/database"
	"github.com/google/uuid"
{{if eq .Database "postgresql"}}
	"github.com/jackc/pgx/v5/pgtype"
{{end}}
)

type (
	Scope    string
	Resource string
)

const (
	ScopeEmailVerification Scope = "email_verification"
	ScopeResetPassword     Scope = "password_reset"

	ResourceUser Resource = "users"
)

type MetaInformation struct {
	Resource   Resource  `validate:"required" json:"resource"`
	ResourceID uuid.UUID `validate:"required,uuid" json:"resource_id"`
	Scope      Scope     `validate:"required" json:"scope"`
}

type Token struct {
	ID         uuid.UUID
	CreatedAt  time.Time
	Expiration time.Time
	Value      string
	Meta       MetaInformation
}

type NewTokenPayload struct {
	Expiration time.Time       `validate:"required"`
	Meta       MetaInformation `validate:"required" json:"meta"`
}

func generateToken() (string, error) {
	bytes := make([]byte, 15)
	if _, err := rand.Read(bytes); err != nil {
		return "", fmt.Errorf("failed to generate token: %w", err)
	}

	token := base32.StdEncoding.WithPadding(base32.NoPadding).EncodeToString(bytes)
	return strings.ToLower(token), nil
}

func generateHash(token string) string {
	hash := sha256.Sum256([]byte(token))
	return hex.EncodeToString(hash[:])
}

{{if eq .Database "postgresql"}}
func NewHashedToken(ctx context.Context, dbtx database.Postgres, data NewTokenPayload) (Token, error) {
	if err := validate.Struct(data); err != nil {
		return Token{}, fmt.Errorf("validation failed: %w", err)
	}

	token, err := generateToken()
	if err != nil {
		return Token{}, err
	}

	t, err := newToken(ctx, dbtx, data.Expiration, data.Meta, token)
	if err != nil {
		return Token{}, err
	}

	return t, nil
}

func newToken(ctx context.Context, dbtx database.Postgres, expiration time.Time, meta MetaInformation, token string) (Token, error) {
	hash := generateHash(token)
	tokenID := uuid.New()

	metaJSON, err := json.Marshal(meta)
	if err != nil {
		return Token{}, fmt.Errorf("failed to marshal meta information: %w", err)
	}

	if err := dbtx.InsertToken(ctx, database.InsertTokenParams{
		ID:              pgtype.UUID{Bytes: tokenID, Valid: true},
		CreatedAt:       pgtype.Timestamptz{Time: time.Now(), Valid: true},
		Hash:            hash,
		ExpiresAt:       pgtype.Timestamptz{Time: expiration, Valid: true},
		MetaInformation: metaJSON,
	}); err != nil {
		return Token{}, fmt.Errorf("failed to insert token: %w", err)
	}

	return Token{
		ID:         tokenID,
		CreatedAt:  time.Now(),
		Expiration: expiration,
		Value:      token,
		Meta:       meta,
	}, nil
}

func GetHashedToken(ctx context.Context, dbtx database.Postgres, token string) (Token, error) {
	hash := generateHash(token)

	dbToken, err := dbtx.QueryTokenByHash(ctx, hash)
	if err != nil {
		return Token{}, fmt.Errorf("failed to get token: %w", err)
	}

	var meta MetaInformation
	if err := json.Unmarshal(dbToken.MetaInformation, &meta); err != nil {
		return Token{}, fmt.Errorf("failed to unmarshal meta information: %w", err)
	}

	return Token{
		ID:         dbToken.ID.Bytes,
		CreatedAt:  dbToken.CreatedAt.Time,
		Expiration: dbToken.ExpiresAt.Time,
		Value:      token,
		Meta:       meta,
	}, nil
}

func DeleteToken(ctx context.Context, dbtx database.Postgres, tokenID uuid.UUID) error {
	if err := dbtx.DeleteToken(ctx, pgtype.UUID{Bytes: tokenID, Valid: true}); err != nil {
		return fmt.Errorf("failed to delete token: %w", err)
	}

	return nil
}

func DeleteUserTokensByScope(ctx context.Context, dbtx database.Postgres, userID uuid.UUID, scope Scope) error {
	if err := dbtx.DeleteUserTokensByScope(ctx, database.DeleteUserTokensByScopeParams{
		Column1: userID.String(),
		Column2: string(scope),
	}); err != nil {
		return fmt.Errorf("failed to delete user tokens by scope: %w", err)
	}

	return nil
}
{{else}}
func NewHashedToken(ctx context.Context, dbtx database.SQLite, data NewTokenPayload) (Token, error) {
	if err := validate.Struct(data); err != nil {
		return Token{}, fmt.Errorf("validation failed: %w", err)
	}

	token, err := generateToken()
	if err != nil {
		return Token{}, err
	}

	t, err := newToken(ctx, dbtx, data.Expiration, data.Meta, token)
	if err != nil {
		return Token{}, err
	}

	return t, nil
}

func newToken(ctx context.Context, dbtx database.SQLite, expiration time.Time, meta MetaInformation, token string) (Token, error) {
	hash := generateHash(token)
	tokenID := uuid.New()

	metaJSON, err := json.Marshal(meta)
	if err != nil {
		return Token{}, fmt.Errorf("failed to marshal meta information: %w", err)
	}

	if err := dbtx.InsertToken(ctx, database.InsertTokenParams{
		ID:              tokenID.String(),
		CreatedAt:       time.Now().Format("2006-01-02 15:04:05"),
		Hash:            hash,
		ExpiresAt:       expiration.Format("2006-01-02 15:04:05"),
		MetaInformation: string(metaJSON),
	}); err != nil {
		return Token{}, fmt.Errorf("failed to insert token: %w", err)
	}

	return Token{
		ID:         tokenID,
		CreatedAt:  time.Now(),
		Expiration: expiration,
		Value:      token,
		Meta:       meta,
	}, nil
}

func GetHashedToken(ctx context.Context, dbtx database.SQLite, token string) (Token, error) {
	hash := generateHash(token)

	dbToken, err := dbtx.QueryTokenByHash(ctx, hash)
	if err != nil {
		return Token{}, fmt.Errorf("failed to get token: %w", err)
	}

	var meta MetaInformation
	if err := json.Unmarshal([]byte(dbToken.MetaInformation), &meta); err != nil {
		return Token{}, fmt.Errorf("failed to unmarshal meta information: %w", err)
	}

	parsedID, _ := uuid.Parse(dbToken.ID)
	createdAt, _ := time.Parse("2006-01-02 15:04:05", dbToken.CreatedAt)
	expiresAt, _ := time.Parse("2006-01-02 15:04:05", dbToken.ExpiresAt)

	return Token{
		ID:         parsedID,
		CreatedAt:  createdAt,
		Expiration: expiresAt,
		Value:      token,
		Meta:       meta,
	}, nil
}

func DeleteToken(ctx context.Context, dbtx database.SQLite, tokenID uuid.UUID) error {
	if err := dbtx.DeleteToken(ctx, tokenID.String()); err != nil {
		return fmt.Errorf("failed to delete token: %w", err)
	}

	return nil
}

func DeleteUserTokensByScope(ctx context.Context, dbtx database.SQLite, userID uuid.UUID, scope Scope) error {
	if err := dbtx.DeleteUserTokensByScope(ctx, database.DeleteUserTokensByScopeParams{
		Column1: userID.String(),
		Column2: string(scope),
	}); err != nil {
		return fmt.Errorf("failed to delete user tokens by scope: %w", err)
	}

	return nil
}
{{end}}

func (t Token) IsValid() bool {
	return time.Now().Before(t.Expiration)
}