package telemetry

import (
	"context"
	"crypto/tls"
	"fmt"
	"log/slog"
	"net/http"
	"os"
	"strings"

	"github.com/lmittmann/tint"
	"go.opentelemetry.io/otel/exporters/otlp/otlplog/otlploghttp"
	sdklog "go.opentelemetry.io/otel/sdk/log"
)

type StdoutExporter struct {
	LogLevel slog.Level
}

func NewStdoutExporter() *StdoutExporter {
	return &StdoutExporter{
		LogLevel: slog.LevelInfo,
	}
}

func NewStdoutExporterWithLevel(level slog.Level) *StdoutExporter {
	return &StdoutExporter{
		LogLevel: level,
	}
}

func (s *StdoutExporter) GetSlogHandler(ctx context.Context) (slog.Handler, error) {
	handler := tint.NewHandler(os.Stdout, &tint.Options{
		Level:      s.LogLevel,
		TimeFormat: "15:04:05",
		AddSource:  true,
	})

	return handler, nil
}

func (s *StdoutExporter) Name() string {
	return "stdout"
}

func (s *StdoutExporter) Shutdown(ctx context.Context) error {
	return nil
}

var _ LogExporter = (*StdoutExporter)(nil)

type OtlpLogExporter struct {
	endpoint   string
	headers    map[string]string
	insecure   bool
	exporter   *otlploghttp.Exporter
	processor  *sdklog.BatchProcessor
}

func NewOtlpLogExporter(endpoint string, headers map[string]string) *OtlpLogExporter {
	if endpoint == "" {
		return nil
	}
	return &OtlpLogExporter{
		endpoint: endpoint,
		headers:  headers,
		insecure: false,
	}
}

func NewOtlpLogExporterInsecure(endpoint string, headers map[string]string) *OtlpLogExporter {
	if endpoint == "" {
		return nil
	}
	return &OtlpLogExporter{
		endpoint: endpoint,
		headers:  headers,
		insecure: true,
	}
}

func (o *OtlpLogExporter) GetSlogHandler(ctx context.Context) (slog.Handler, error) {
	opts := []otlploghttp.Option{
		otlploghttp.WithEndpoint(o.endpoint),
	}

	if o.insecure {
		opts = append(opts, otlploghttp.WithInsecure())
	} else {
		opts = append(opts, otlploghttp.WithTLSClientConfig(&tls.Config{
			MinVersion: tls.VersionTLS12,
		}))
	}

	if len(o.headers) > 0 {
		opts = append(opts, otlploghttp.WithHeaders(o.headers))
	}

	exporter, err := otlploghttp.New(ctx, opts...)
	if err != nil {
		return nil, fmt.Errorf("failed to create OTLP log exporter: %w", err)
	}
	o.exporter = exporter

	processor := sdklog.NewBatchProcessor(exporter)
	o.processor = processor

	provider := sdklog.NewLoggerProvider(
		sdklog.WithProcessor(processor),
	)

	handler := &otlpLogHandler{
		provider: provider,
		logger:   provider.Logger("default"),
	}

	return handler, nil
}

func (o *OtlpLogExporter) Name() string {
	return "otlp-http-logs"
}

func (o *OtlpLogExporter) Shutdown(ctx context.Context) error {
	var errs []string
	if o.processor != nil {
		if err := o.processor.Shutdown(ctx); err != nil {
			errs = append(errs, fmt.Sprintf("processor shutdown: %v", err))
		}
	}
	if o.exporter != nil {
		if err := o.exporter.Shutdown(ctx); err != nil {
			errs = append(errs, fmt.Sprintf("exporter shutdown: %v", err))
		}
	}
	if len(errs) > 0 {
		return fmt.Errorf("OTLP log exporter shutdown errors: %s", strings.Join(errs, "; "))
	}
	return nil
}

var _ LogExporter = (*OtlpLogExporter)(nil)

type otlpLogHandler struct {
	provider *sdklog.LoggerProvider
	logger   sdklog.Logger
	attrs    []slog.Attr
	group    string
}

func (h *otlpLogHandler) Enabled(ctx context.Context, level slog.Level) bool {
	return true
}

func (h *otlpLogHandler) Handle(ctx context.Context, record slog.Record) error {
	return nil
}

func (h *otlpLogHandler) WithAttrs(attrs []slog.Attr) slog.Handler {
	newAttrs := make([]slog.Attr, len(h.attrs)+len(attrs))
	copy(newAttrs, h.attrs)
	copy(newAttrs[len(h.attrs):], attrs)
	return &otlpLogHandler{
		provider: h.provider,
		logger:   h.logger,
		attrs:    newAttrs,
		group:    h.group,
	}
}

func (h *otlpLogHandler) WithGroup(name string) slog.Handler {
	groupName := name
	if h.group != "" {
		groupName = h.group + "." + name
	}
	return &otlpLogHandler{
		provider: h.provider,
		logger:   h.logger,
		attrs:    h.attrs,
		group:    groupName,
	}
}
