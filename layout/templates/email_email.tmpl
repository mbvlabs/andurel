package email

import (
	"context"

	"strings"

	"golang.org/x/net/html"
)

type Sender interface {
	SendTransactional(ctx context.Context, to, from, subject, htmlBody, textBody string) error
}

type Client struct {
	sender Sender
}

func New(sender Sender) Client {
	return Client{
		sender: sender,
	}
}

func (c Client) SendTransactional(ctx context.Context, to, from, subject, htmlBody, textBody string) error {
	return c.sender.SendTransactional(ctx, to, from, subject, htmlBody, textBody)
}

func HTMLToText(htmlContent string) (string, error) {
	doc, err := html.Parse(strings.NewReader(htmlContent))
	if err != nil {
		return "", err
	}

	var result strings.Builder
	var extract func(*html.Node)

	extract = func(n *html.Node) {
		if n.Type == html.ElementNode {
			switch n.Data {
			case "style", "script", "head":
				return
			case "a":
				var linkText strings.Builder
				var extractLinkText func(*html.Node)
				extractLinkText = func(node *html.Node) {
					if node.Type == html.TextNode {
						linkText.WriteString(node.Data)
					}
					for child := node.FirstChild; child != nil; child = child.NextSibling {
						extractLinkText(child)
					}
				}
				extractLinkText(n)

				var href string
				for _, attr := range n.Attr {
					if attr.Key == "href" {
						href = attr.Val
						break
					}
				}

				text := strings.TrimSpace(linkText.String())
				if text != "" {
					result.WriteString(text)
				}

				if href != "" && href != text {
					result.WriteString(" (")
					result.WriteString(href)
					result.WriteString(")")
				}
				result.WriteString(" ")
				return
			}
		}

		if n.Type == html.TextNode {
			text := strings.TrimSpace(n.Data)
			if text != "" {
				result.WriteString(text)
				result.WriteString(" ")
			}
		}

		if n.Type == html.ElementNode {
			switch n.Data {
			case "p", "div", "br", "h1", "h2", "h3", "h4", "h5", "h6":
				result.WriteString("\n")
			case "tr", "li":
				result.WriteString("\n")
			}
		}

		for c := n.FirstChild; c != nil; c = c.NextSibling {
			extract(c)
		}

		if n.Type == html.ElementNode {
			switch n.Data {
			case "p", "div", "h1", "h2", "h3", "h4", "h5", "h6":
				result.WriteString("\n")
			}
		}
	}

	extract(doc)

	text := result.String()
	text = strings.TrimSpace(text)

	for strings.Contains(text, "\n\n\n") {
		text = strings.ReplaceAll(text, "\n\n\n", "\n\n")
	}

	return text, nil
}
